unit MainFm;

//---------------------------------------------------------------------------
interface

//---------------------------------------------------------------------------
uses
  Messages, SysUtils, Classes, Controls, Forms, Dialogs, ExtCtrls, Windows,
  ComCtrls, Buttons, XPMan, StdCtrls, GeoFunctions, GeoClasses, Math,
  MMSystem, GeoString, GeoFiles, Menus, ShellAPI;

//---------------------------------------------------------------------------
type

  TMainForm = class(TForm)
    Panel1: TPanel;
    Panel5: TPanel;
    PopupMenu1: TPopupMenu;
    N1: TMenuItem;
    N2: TMenuItem;
    N3: TMenuItem;

    procedure N3Click(Sender: TObject);

    type TLatLong = record
      lat, long :Double
    end;

     Type TMyPoint = Record
       x, y : Double;
     end;

    function GetWGSCursor : TLatLong;

    procedure SaveTrack;

    procedure CutLineByBufferedFrame(var x,y,x2,y2: Double);
    procedure CutLineByFrame(var x,y,x2,y2: Double);

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormActivate(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure RxMemoKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure Panel2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure Panel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure MenuUnscroll;
    procedure Panel1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure SpeedButton2Click(Sender: TObject);
    procedure SpeedButton3Click(Sender: TObject);
    procedure SpeedButton4Click(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure Panel1Resize(Sender: TObject);
    procedure Panel1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckNearestMarkers(X, Y : Integer);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure N1Click(Sender: TObject);
    procedure N2Click(Sender: TObject);
  private
    { Private declarations }
    AsphTicks: Integer;

    procedure OnDeviceCreate(Sender: TObject; Param: Pointer;
     var Handled: Boolean);

    procedure Autorun;
    procedure InitAutoMode;
    procedure SaveLogFile;
    procedure InitData;

    procedure ShiftMap(Key : Byte);

    procedure TimerEvent(Sender: TObject);
    procedure ProcessEvent(Sender: TObject);
    procedure RenderEvent(Sender: TObject);
    procedure RenderMenus;
    procedure AxelScale;

    procedure DrawScaleAndNord (Mas: Double);

    procedure DrawArrowToNearest;
    function  DrawArrowToCurrentRoute: boolean;
    procedure DrawArrowToNextRoute;
    procedure DrawArrowToBase;

    procedure SmartMenuKeyCommand(Key : Byte);
    procedure MenuKeyCommand(Key : Byte);

    procedure DrawZone(x1,y1,x2,y2,x3,y3,x4,y4:Double);
    procedure MyLine(x,y,x2,y2:Double; Dash:Boolean; Col: Cardinal);
    procedure CrackDot(x,y: Double; Col:Cardinal);
    procedure FatLine(x,y,x2,y2:Double; Thin:integer; Dash:Boolean; Col: Cardinal);

    procedure WMDisplayChange(var message:TMessage); message WM_DISPLAYCHANGE;

    procedure SetCurrentRouteByName(RouteName:string);
    procedure GoToNextRoute;
    procedure CurToNextDist;

    procedure PutBaseHere( B,L :double);

    procedure FollowCurrentRoute(RouteN: integer; _CurTime: real; cx,cy :Double);

    function GetRouteAngle(RouteN:integer): Double;
    function GetDistToRoute(RouteN : integer; x, y: double): Double;

    procedure GetDistToBase(cx,cy : double);
    procedure GetNearestRoute(cx,cy : double);

    procedure SKToWGS(x, y, h: Double; var B, L: Double);
    procedure WGSToSK(B, L, H: Double; var x, y: Double; Zone:Integer; autozone : boolean);

    procedure AnalyseStr(s:String);
    procedure AnalyseAUXStr(s:String; AddToLog: boolean);
    procedure GPSTimerEvent;
    procedure AppendPoint (T :Real; x,y,Sh,Dol, h1,h2:double ; fl:Boolean);  ///// ИННОКЕНТИЙ
    procedure ReDrawLines(dash:Boolean);
    procedure ReDrawMaps;
    procedure ReDrawTrack;
    procedure ReDrawRoutes;
    procedure ReDrawBase;
    procedure ReDrawMarkers;
    procedure ReDrawTurnPoints;

    procedure AxelAzimuth(az2: double);
    procedure AxelHgts;

    function GetNormalPt(xb, yb, xe,ye, x, y: double; isRight: boolean; Dist: double): TMyPoint;
  public
   procedure AddMarker(Mname:string; mB, mL :Double);
   procedure DelMarker(DelI:integer);
   procedure EditMarker(I:integer; Mname:string; mB, mL :Double);
   procedure RefreshMarkerList;

   procedure SetCurrentRoute(RouteN:integer);
   procedure GetNextRoute;

   function GetTurnPoints(xp, yp, azmt, x1, y1, x2 ,y2, MinR, MaxR : double):boolean;

   procedure ReLoadRoutes(FileName:String);
   procedure SetNewRouteStatus(N, Stat :Integer);
   procedure ReComputeRoutes(WFZ:Boolean);
   procedure ReComputeTracks(WFZ:Boolean);
   procedure ReComputeMaps(WFZ:Boolean);
   procedure ClearGPS;
   procedure OpenEmulFile(FileName:String);
   function AskJoysticKey: integer;
   function AskJoystic: integer;

   procedure LoadMaps(Filename:String);
   procedure ResetMaps;

   procedure LoadAUXProt(FName:string);
    {
  Type TMyPoint = Record
      x, y : Double;
  end;}

  Type TMyPoint3D = Record
      x, y, z : Double;
  end;

  Type TMarker = Record
     B, L : Double;
     iX, iY, iW : Integer;
     x, y : Double;
     Caption : String;
     OnScreen, Show : boolean;
  End;

  const
   MenuNMax = 10;
   MapModesCount = 9;
   FrameMax = 100;
   MaxMashtab = 12 ;
   TMashtab : Array [0.. MaxMashtab-1 ] of Integer =
                    (10, 20, 50,
                     100, 200, 500,
                     1000, 2000, 5000,
                     10000, 20000, 50000);
   MenuCount: array [0..MenuNMax] of Integer = (0, 7, MapModesCount, MaxMashtab-1,
                                              2, 1, 1, 1, 1, 1, 2);

   MenuButtonSize: array [0..MenuNMax] of Integer = (0, 70, 50, 40, 50,
                                                      40, 40, 50, 50, 50, 50);

   MapModeDoRotate: array [0..MapModesCount] of Boolean = (false, false, true,
                                             false, true, true,false,true,false,true);
  var
    SID, AID : string;

    MashtabNames : Array [0.. MaxMashtab-1 ] of String;
    MapModeNames: array [0..MapModesCount] of String;
    MapModeShortNames: array [0..MapModesCount] of String;
    MapModeSubNames: array [0..MapModesCount] of String;
    MapModeShortSubNames: array [0..MapModesCount] of String;
    Inf: array [1..100] of String;

    ReCalcWay, SpecialTP: boolean;

    Markers : array [0..1000] of TMarker;
    MarkerCount: Integer;

    RoutesDatum, RoutesCS : integer;
    isRoutesDatum : boolean;
    RoutesXTab, RoutesYTab, RoutesZTab, RoutesNameTab, RoutesTabStart,
    RoutesX2Tab, RoutesY2Tab, RoutesZ2Tab : Integer;

    Center : TMyPoint ;
    Base : array [1..2] of TMyPoint;
    FramePoints : array [0..FrameMax,1..2] of TMyPoint3D;

    EnableCom2 : boolean;
    LocalTP : boolean;
    ShowActiveZone : boolean;
    SmartMenu : boolean;
    AskReturn: boolean; AskR: integer;
//    SmartCount :integer;

    MyDir, LogDir, DataDir, GPSDataDir, LogDataDir, RepDataDir, Rep2DataDir : String;
    LangExe : String;
    GPSBuffer, EmulBuffer, AUXBuffer, GPSLog, Odo, Report :TStringList;

    WaitForZone, ShowFrame : boolean;
    DrawScale, ShowInfo, HgtLine, DrawLines, DashLines, ShowCracks, ShowMaps, ShowCur : boolean;
    MinMap, MaxMap : integer;
    MapAlpha : integer;
    RealTime : boolean;
    AllowMouse : boolean;
    AllowJoyStick : boolean;

    StartFrom1st : boolean;
    RoundFly : boolean;
    HideNext : boolean;

    ShowTP : boolean;

    South, UTM: Boolean;

    HgtID : integer;

    SmoothAzimuth: Boolean;

    /// COLORS
    RoutesColor, BackGroundColor, LinesColor,
    ChoosedColor, TrackColor, MenuChoosedColor, Dop1Color, RouteOKColor,
    IntColor, DoneColor, CurColor : Cardinal;

    DopFat: byte;
    MaxDotsVisible : Integer;

    MaxHgtL, MaxHgtR,  MinHgtL, MinHgtR, MaxSpd : Integer;

    EmulSpeed: Integer;

    BigCur, BigText, CountAz: Boolean;

    RecieveList, RecieveList2 :TStringList;

    AutoOn : boolean;
    AutoM : array [1..9] of Integer;

    TurnPoints:array [0..64] of TMyPoint;
    TPCount : Integer;

    MinR, MaxR : Integer;

    MapMode : Integer;

    MyZone : Integer;
    Azimuth, Az : Double;

    GeoidR, GeoidH, H : real;

    ComSpd1, ComSpd2 : Integer;

    
    ShowFPS : boolean;

    Smooth, CropRoutes, Optimized : Boolean;

    RouteStep : integer;
    RouteMaxDist,  MinDistToCurrent : integer;

    GPSProt, COMProt: integer;

    HideTrack : boolean;

    OpenGL : boolean;

    MinDistToFix :integer;

    const DJ: array[1..12] of Integer = (1, 2, 4, 8, 16, 32, 64,
                                          128, 256, 512, 1024, 2048);

    var JoyKeyPress : array [1..12] of Boolean;
        JoyResetN : integer;

    JCom : Array [1..9] of Integer;
    { Public declarations }
  end;

const
  SmoothScale = true;
  SmartCount = 7;
var /// Info

  SatCount, CurTime, CurX, CurY, CurB, CurL, CurOdo, CurTrip,
  CurHgt, CurHgt2, CurHgt3, CurDOP, CurGeoHGT, CurDGeo :String;
  Panel1CursorX, Panel1CursorY : Integer;

  ChangeAutoM: boolean;

  FromBegin: boolean;

  AskMark : integer;

  GpsLogFileName, _GPSLogFileName, ReportFileName,
  Report2FileName, TrackFileName :String;

  CurrentRoute : Integer =-1;
  PrevRoute    : Integer =-1;
  NextRoute    : Integer =-1;

  WGS: Integer;
  SK:  Integer;

  AfterEnd, BeforeBegin : Boolean;

  LocalR1 : integer = -1;
  LocalR2 : integer = -1;
  
  HideArrow : Boolean;

  ReflyCurrent : Boolean = false;
  RouteAsk : integer;
  AskForNext : Boolean;

  NearestDist, NearestRoute : Integer;
  AzimuthToRoute : Double;

  RouteProgress: Integer;

  WorstDist : Boolean;

  AllowAuto: Boolean;

  DistToCurrent, DistToNext, DistToBase :Integer;
  CurrentTime, LastFollowedTime : Real;

  ShowNext : boolean;
  ShowNextTime : real;

  Follow : boolean;

  AzimuthToNearest, AzimuthToCurrent, AzimuthToBase, CurrentRouteAngle : Double;

  VYShift : Integer;

  ShowCurXY : boolean = false;

  SumDist : Double = 0;
  NumDist : Integer = 0;
  NumBadHgt : Integer = 0;
  BadDist : Boolean = false;

  BackStep : Boolean = false;

  LagCount: Single;

//------------ИННОКЕНТИЙ

  var

  MShiftX, MShiftY, MShiftY0 : Integer;
  ScrollMenu, TapOnMenu : Boolean;

  const

  MinDist: integer = 50;
  MinDotDist: integer = 10;

  MenuW = 200;
  LogsMax = 100;
  MaxLogSize = 50000;

  Type TAUXProt = Record
    RName, LName : String;
    RSepN, LSepN : Integer;
    RSep, LSep : string;
    RDataType, LDataType : integer;
    RParN, LParN : Integer;
    LCoef, RCoef : Single;
  End;  

  Type TTrackRecord =  Record
    Flag    : Boolean ;
    Crack   : Boolean;
    Time    : Real;
    TimeString : String;
    Lat     : Double ;
    Long    : Double ;
    mZone   : Integer;
    mUTM    : Boolean;
    x, y    : Double ;
    h, hg   : Double ;
    hl, hr  : Integer;
    Lx, Ly  : Double ;
    OdoMr   : Double;
    RouteNm : String;
    RDist    : Integer;
    RProgress : Integer;
  end ;


  Type TRoute = record
    Name : String; // Array [0..20] of Char ;
    Status : byte; /// 0 -undone, 1- Current, 2 - Done good, 3 - Done bad.
    AverageDist : double;
    badHgts : integer;
    StartTime, EndTime, RLabel :string;
    //Flag : Boolean;
    Geo : Boolean;
    x1, x2 : double;
    y1, y2 : double;
    Gx1, Gx2 : double;
    Gy1, Gy2 : double;
    Gz1, Gz2 : double;
  end ;

  TMap = Record
      imgN : integer;
      imgName : String;
      x,y : array [1..4] of Double;
      Gx,Gy : array [1..4] of Double;
  end ;

  Var Route : Array [0..2000] of TRoute ;
      RouteCount : Integer ;

 const
     MaxDotsCount = 1000000;

 {var SizePVPP : Integer ;
     Pv_PP : Array [0..MaxDotsCount] of TPV_PP ;   }

 Var
    SizeTrackRecord : Integer ;
    TrackRecord : Array [0..MaxDotsCount] of TTrackRecord ;
    StepTrackRecord : Double = 0.1;

    OpenPort1 : Boolean = false;
    OpenPort2 : Boolean = false;

 var CurrentS : String;
    Gx : double;
    Gy : double;
    OldGx : double;
    OldGY : Double;

    Speed : Double;

    Odometr   : Double;
    Trip   : Double;

    Mashtab : Integer;

    EmulProgress : Double;
    OldEmulProgress : Integer;

//---------------------------------------------------------------------------

var
  MainForm: TMainForm;

  ChoosedMenu :integer;

  SmartN, SmartY, SmartKeyY :integer;
  SmartX : real;
  inSmart : Boolean;

  AUXProt : TAUXProt;

  HAGR, HAGL, _HAGL, _HAGR : Real;

  MenuN, MenuScroll, MenuScroll0 : integer;
  _MenuScroll : Double;

  JustStarted : boolean;

  Scale  :Double =1;
  _Scale  :Double =1;



  Frame, FrameGeo : boolean;
  FrameCount : Integer;
  FrameFile : String;

  MapList : Array of TMap;
  
//---------------------------------------------------------------------------
implementation
uses
 Vectors2, Vectors2px, AsphyreTimer, AsphyreFactory, AsphyreTypes, AsphyreDb,
 AbstractDevices, AsphyreImages, AsphyreFonts, DX9Providers, RTypes,
 AbstractCanvas, OGLProviders;
{$R *.dfm}

//---------------------------------------------------------------------------

  type TPosAndDist = record
      Pos, Dist, DistTo0, x, y :Double;
  end;

function GetPosAndDist(xb, yb, xe, ye, x, y: double): TPosAndDist;
var x1, y1, x2, y2, _x, _y, t, c, _y0: Double;
begin
  Result.Dist := 0;
  Result.Pos := 0;
  try
     x1 := xb;
     x2 := xe;
     y1 := yb;
     y2 := ye;

     if x1=x2 then
     begin
       _y := y;
       _x := x1;
        c := (_y - y1) / (y2 - y1);
     end
        else
     if y1=y2 then
     begin
       _y := y1;
       _x := x;
        c := (_x - x1) / (x2 - x1);
     end
        else
     if abs(x2-x1)>abs(y2-y1) then
     Begin
       t :=  (y2-y1)/(x2-x1);
       c := 1/t;

       _y0 := c*(x-x1) + (y-y1);

       _x := x1 + (  _y0/(t+c) );
       _y := y1 + ( t*(_x-x1) );

      

        c := (_x - x1) / (x2 - x1);
     End
        else
          Begin
            t := (x2-x1)/(y2-y1);
            c := 1/t;

            _y0 := (x-x1) + c*(y-y1);

            _y := y1 + (  _y0/(t+c) );
            _x := x1 + ( t*(_y-y1) );

            c := (_y - y1) / (y2 - y1);
          End;

     Result.x := _x;
     Result.y := _y;
     Result.Pos  := c;
     Result.Dist := SQRT(SQR(x-_x)+SQR(y-_y));
     Result.DistTo0 := c*SQRT(SQR(x2-x1)+SQR(y2-y1));
  except
    Result.Dist := 0;
  end;


end;

{Type TMyPoint = Record
       x, y : Double;
     end; }

function TMainForm.GetNormalPt(xb, yb, xe,ye, x, y: double; isRight: boolean; Dist: double): TMyPoint;
var
  a : double;
  PD :TPosandDist;
begin

   try
    PD := GetPosAndDist(xb, yb, xe, ye, x, y);
    a := arctan2(xe-xb,ye-yb);

    if isRight then
      a := a + pi/2
      else
        a:= a - pi/2;

     Result.x := PD.x + sin(a)*Dist;
     Result.y := PD.y + cos(a)*Dist;

   except
   end;

end;


function GetCols(str: string; ColN, ColCount:integer; Spc:byte): string;
var j,stl,b :integer;
    sep :String;
begin
   result:='';
   stl:=0;
   b:=1;
   sep:=' ';

   Case Spc of
     0: sep:=' ';
     1: sep:=#$9;
     2: sep:='/';// LoadRData.Spacer.Text[1];
     3: sep:=';';
     4: sep:=',';
   end;

   for j:=1 to length(Str)+1 do
   Begin

     if ((copy(Str,j,1)=sep)or(j=length(Str)+1))and(copy(Str,j-1,1)<>sep) then
     begin

       if (stl>=ColN) and (Stl<ColN+ColCount) then
       Begin
        if result='' then
          Result:=(Copy(Str,b,j-b))
            else
              Result:=Result+' '+(Copy(Str,b,j-b));
       End;

       inc(stl);
       b:=j+1;

       if stl>ColN+ColCount then
          break;
     end;

  End;

  if result <> '' then
    for j:= 1 to length(Result)+1 do
        if ((result[j] = '.') or (result[j] = ','))and(result[j]<>sep) then
           result[j] := DecimalSeparator;
end;


function CopToStr ( var cc ): String ;      {ИННОКЕНТИЙ}
var c : Array [0..1000] of char absolute cc ;
    i : Integer ;
    s : string ;
begin
       i := 0;
       s := '' ;
       while c[i] <> #0 do
          begin
             s := s + c[i];
             i := i +1;
          end ;
       CopToStr := s;
end;

procedure StrLong ( Data : int64; var str : String );   {ИННОКЕНТИЙ}
var s, s1 : string ;
       fl : boolean;
begin
    s := '';
    fl := FALSE ;
    repeat
      system.Str ( Data mod 1000, s1 );
      while Length ( s1 ) <3 do s1 := '0'+s1;
      IF FL THEN
            s := s1 + '.'+s
        ELSE s := s1 ;
      Data := Data div 1000;
      FL := TRUE ;
    until Data <1000;
      system.str ( data, s1 );
      while Length ( s1 ) <3 do s1 := '0'+s1;
      s := s1 + '.'+s;
     str := s ;
 end;

function DecChar(c :Char) :Integer;  {ИННОКЕНТИЙ}
begin
  DecChar := Ord (c) - Ord ('0');
end;

function HexToInt(Value: String): LongInt;
var
  L : Longint;
  B : Byte;
begin
  Result := 0;
  if Length(Value) <> 0 then
  begin
    L := 1;
    B := Length(Value) + 1;
    repeat
      dec(B);
      if Value[B] <= '9' then
        Result := Result + StrToInt(Value[B]) * L
      else
        Result := Result + (Ord(Value[B]) - 65) * L;
      L := L * 16;
    until B = 1;
  end;
end;

function ExecuteFile(const FileName, Params, DefaultDir: string; ShowCmd: Integer): THandle;
begin
  if fileexists(FileName) then
    Result := ShellExecute(Application.MainForm.Handle, nil, PChar(FileName), PChar(Params),
      PChar(DefaultDir), ShowCmd);
end;

procedure TMainForm.CheckNearestMarkers(X, Y: Integer);
var I :Integer;
begin
  PopupMenu1.Items[2].Visible := false;
  for i := 0 to MarkerCount - 1 do
   if (X > Markers[i].iX-20) and (X < Markers[i].iX+20) then
    if (Y > Markers[i].iY-20) and (Y < Markers[i].iY+20) then
    begin
      AskMark := i;
      PopupMenu1.Items[2].Visible := true;
      PopupMenu1.Items[2].Caption := Inf[57]+'"'+Markers[I].Caption+'"';
      break;
    end;
end;

procedure TMainForm.ClearGPS;
begin
   SaveTrack;
   SizeTrackRecord := 0;

   SatCount := ''; CurB:= ''; CurL:= ''; CurOdo:= '';
   CurTime:= '';   CurX:= ''; CurY:= ''; CurTrip:= '';
   CurGeoHgt:= ''; CurHgt:= '-';  CurDGeo:= ''; 
   CurDOP:= '';  CurHgt2:= '-'; CurHgt3:= '-';

   HAGL := 0;
   HAGR := 0;
   _HAGR := 0;
   _HAGL := 0;

   Center.x := 0;
   Center.y := 0;
end;

procedure TMainForm.CrackDot(x, y: Double; Col: Cardinal);
begin
  if (x > 0) and (y > 0) and (X <(DisplaySize.X - MenuW)) and (y < DisplaySize.y) then
  Begin
       AsphCanvas.UseImagePx(AsphImages.Image['dot.image'], pxBounds4(0, 0, 8, 8));
       AsphCanvas.TexMap(pRotate4c(Point2(x,y),Point2(8, 8), 0),cColor4(Col));

  End;
end;

procedure TMainForm.CurToNextDist;
var PD : TPosAndDist;
begin
  DistToNext := 0;

  if (CurrentRoute>-1)and(CurrentRoute < RouteCount) then
    if (NextRoute>-1)and(NextRoute < RouteCount) then
    begin
       PD := GetPosAndDist(Route[CurrentRoute].x1,Route[CurrentRoute].y1,
                      Route[CurrentRoute].x2,Route[CurrentRoute].y2,
                     (Route[NextRoute].x1+Route[NextRoute].x2)/2,
                     (Route[NextRoute].y1+Route[NextRoute].y2)/2);

      {DistToNext := Round( Sqrt ( Sqr( (Route[CurrentRoute].x1+Route[CurrentRoute].x2)/2
                     - (Route[NextRoute].x1+Route[NextRoute].x2)/2) +
                     Sqr( (Route[CurrentRoute].y1+Route[CurrentRoute].y2)/2
                     - (Route[NextRoute].y1+Route[NextRoute].y2)/2)));}


      DistToNext := round(PD.Dist);
    end;

                     

end;


procedure TMainForm.CutLineByBufferedFrame(var x, y, x2, y2: Double);
const
 bx = 1024;
 by = 1024;
begin
  if not( (x < 0 - bx) and (x2 < 0 - bx)) then
  if not( (x > (DisplaySize.X + bx)) and (x2 > (DisplaySize.X + bx))) then
  if not( (y < 0 - by) and (y2 < 0 - by)) then
  if not( (y > DisplaySize.y + by) and (y2 > DisplaySize.y + by)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
    if x < 0 - bx then
    begin
      if abs(x2-x) > 0 then
        y := round( ((-bx-x)/(x2-x))*(y2-y)+y)
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0 - bx;
    end
      else
       if x > (DisplaySize.X) + bx then
       begin
          if abs(x2-x) > 0 then
              y := round((((DisplaySize.X)+bx-x)/(x2-x))*(y2-y)+y)
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X) + bx;
       end;

    if x2 < 0 - bx then
    begin
      if abs(x2-x) > 0 - bx then
        y2 := round(((-bx-x)/(x2-x))*(y2-y)+y)
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0 - bx;
    end
      else
       if x2 > (DisplaySize.X)+bx then
       begin
          if abs(x2-x) > 0 then
              y2 := round((((DisplaySize.X)+bx-x)/(x2-x))*(y2-y)+y)
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X) + bx;
       end;

    if y < 0 - by then
    begin
      if abs(y2-y)>0 then
          x := round(((-by-y)/(y2-y))*(x2-x)+x)
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0 - by;
    end
      else
       if y > DisplaySize.y + by then
       begin
          if abs(y2-y) > 0 then
               x := round(((DisplaySize.y+by-y)/(y2-y))*(x2-x)+x)
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y + by;
       end;

   if y2 < 0 - by then
    begin
      if abs(y2-y) > 0 then
          x2 := round(((-by-y)/(y2-y))*(x2-x)+x)
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0 - by;
    end
      else
       if y2 > DisplaySize.y + by then
       begin
          if abs(y2-y) > 0 then
               x2 := round(((DisplaySize.y+by-y)/(y2-y))*(x2-x)+x)
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y + by;
       end;
  End;
end;

procedure TMainForm.CutLineByFrame(var x, y, x2, y2 : Double);
begin
  if not( (x < 0) and (x2 < 0)) then
  if not( (x > (DisplaySize.X - MenuW)) and (x2 > (DisplaySize.X - MenuW))) then
  if not( (y < 0) and (y2 < 0)) then
  if not( (y > DisplaySize.y) and (y2 > DisplaySize.y)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
    if x < 0 then
    begin
      if abs(x2-x) > 0 then
        y := round( ((-x)/(x2-x))*(y2-y)+y)
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0;
    end
      else
       if x > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y := round((((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y)
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X - MenuW);
       end;

    if x2 < 0 then
    begin
      if abs(x2-x) >0 then
        y2 := round(((-x)/(x2-x))*(y2-y)+y)
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0;
    end
      else
       if x2 > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y2 := round((((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y)
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X - MenuW);
       end;

    if y < 0 then
    begin
      if abs(y2-y)>0 then
          x := round(((-y)/(y2-y))*(x2-x)+x)
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0;
    end
      else
       if y > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x := round(((DisplaySize.y-y)/(y2-y))*(x2-x)+x)
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y;
       end;

   if y2 < 0 then
    begin
      if abs(y2-y) > 0 then
          x2 := round(((-y)/(y2-y))*(x2-x)+x)
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0;
    end
      else
       if y2 > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x2 := round(((DisplaySize.y-y)/(y2-y))*(x2-x)+x)
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y;
       end;
  End;

end;

procedure TMainForm.AddMarker(Mname: string; mB, mL: Double);
begin
///
  if MarkerCount<1000 then
     Inc(MarkerCount);

  Markers[MarkerCount-1].B := mB;
  Markers[MarkerCount-1].L := mL;

  Markers[MarkerCount-1].Caption := mName;

  RefreshMarkerList;
end;


{procedure TMainForm.Autorun;
var S, RS:TStringList;
    ShowSets: boolean;
begin

  SmartMenu := true;
//  SmartCount := 6;
  SmartN := 1;
  SmartX := 0;

  ShowSets := false;
  Optimized :=true;
  ShowCracks := true;

  InitData;
  InitAutoMode;
  S := TStringList.Create;
  Settings.AcceptButton.OnClick(nil);
  if Fileexists(MainForm.DataDir+'Load.config') then
  try

      S.LoadFromFile(MainForm.DataDir+'Load.config');
      if S.Count>2 then
        if s[2]='1' then
          Begin
            BorderStyle := bsNone;
            WindowState := wsMaximized;
            Settings.FScreen.Checked := true;
          End;

      if S.Count>3 then
      if S[3]='1' then
      begin
        ShowFPS := True;
        Settings.FPS.Checked := true;
      end
       else
        begin
            ShowFPS := false;
            Settings.FPS.Checked := false;
        end;

    if S.Count>4 then
      if S[3]='1' then
      begin
        Settings.ShowReport.Checked := true;
      end
       else
           Settings.ShowReport.Checked := false;

     if S.Count>5 then
      if S[4]='1' then
      begin
        Settings.AReport.Checked := true;
      end
       else
           Settings.AReport.Checked := false;

    if S.Count>1 then
      if S[0]='1' then
      begin
        Settings.CFile.Text := S[1];
        Settings.ARun.Checked := true;
        Settings.LoadSettings(S[1]);
        Settings.AcceptButton.OnClick(nil);
      end
      else
      begin
        Timer.Enabled:= False;
        ShowSets := true;
       // Settings.ShowModal;
      end;

  except

  end
   else
      ShowSets := true;

  S.Destroy;


  if Fileexists(MainForm.DataDir+'Reg.config') then
  Begin
    try
      AID := GetHDSerNo;
      SID := Generate(AID);

      RS := TStringList.Create;
      RS.LoadFromFile(MainForm.DataDir+'Reg.config');
        if SID<>RS[0] then
          RegForm.ShowModal;

      RS.Destroy;
    except
       AID := GetHDSerNo; SID := Generate(AID);
       RegForm.ShowModal;
    end
  End
    else
    Begin
       AID := GetHDSerNo; SID := Generate(AID);
       RegForm.ShowModal;
    End;

  if ShowSets then
     Settings.ShowModal;
end;  }

procedure TMainForm.DrawScaleandNord (Mas: Double);
var s, s2 : String;
    w, j, i, k, _HgtId : integer;
    xm, ym, x2 : real;
    InfMd : boolean;
begin

  if DrawScale then
  Begin
    w := trunc(TMashtab[Mashtab]/Mas);

    AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-20 - w, DisplaySize.Y - 50,
                    (DisplaySize.X - MenuW), DisplaySize.Y),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    FatLine((DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 10,
                (DisplaySize.X - MenuW) - 10, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

    FatLine((DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 20,
                (DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

    FatLine((DisplaySize.X - MenuW) - 10, DisplaySize.Y - 20,
                (DisplaySize.X - MenuW) - 10, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

    w := trunc(w/2 + AsphFonts[Font4].TextWidth(MashtabNames[Mashtab])/2) ;

    AsphFonts[Font4].TextOut( Point2((DisplaySize.X - MenuW) - w -10, DisplaySize.Y - 45), MashtabNames[Mashtab],
                              clWhite2, 1.0);

  End;


end;

procedure TMainForm.ReDrawTurnPoints;
var dx, dy, dx2, dy2, x, y, x2, y2, fi,a : Double;
    csize: integer;
    i:integer;
begin

  if ShowTP = false then
     exit;

  if RouteCount < 2 then
     exit;

  if CurrentRoute = -1 then
     exit;

  if (MapMode<=2)or(MapMode>5) then
     exit;

  if not (LocalTP) then
  Begin
    if (not((BeforeBegin) or (AfterEnd))) then
      if not(ReflyCurrent) then
        exit;
  End;

  if RecalcWay then
  Begin

    if SpecialTP then
    Begin
        if NextRoute<>-1 then
        Begin

         a := arctan2(Route[CurrentRoute].x2-Route[CurrentRoute].x1,
                           Route[CurrentRoute].y2-Route[CurrentRoute].y1);
         if FromBegin then
            if GetTurnPoints(Route[CurrentRoute].x2+ Sin(a), Route[CurrentRoute].y2 + Cos(a),
                    a,
                   Route[NextRoute].x2,
                   Route[NextRoute].y2,
                   Route[NextRoute].x1,
                   Route[NextRoute].y1, MinR, MaxR) = false then
              exit;

          if not FromBegin then
              if GetTurnPoints(Route[CurrentRoute].x1+ Sin(a+pi), Route[CurrentRoute].y1+ Cos(a+pi),

                  (a+pi),

                   Route[NextRoute].x1,
                   Route[NextRoute].y1,
                   Route[NextRoute].x2,
                   Route[NextRoute].y2, MinR, MaxR) = false then
              exit;
        End
         else
          exit;


    End
     else
       BEGIN
         //if (not((BeforeBegin) or (AfterEnd))) then
          // if not(ReflyCurrent) then
           ///Begin


              x :=   TrackRecord [SizeTrackRecord -1].x;
              y :=   TrackRecord [SizeTrackRecord -1].y;

            if FromBegin then
                if GetTurnPoints(x, y,
                   Azimuth,
                   Route[CurrentRoute].x1,
                   Route[CurrentRoute].y1,
                   Route[CurrentRoute].x2,
                   Route[CurrentRoute].y2, MinR, MaxR) = false then
                exit;

             if not FromBegin then
                if GetTurnPoints(x, y,
                   Azimuth,
                   Route[CurrentRoute].x2,
                   Route[CurrentRoute].y2,
                   Route[CurrentRoute].x1,
                   Route[CurrentRoute].y1, MinR, MaxR) = false then
                exit;
       END;
  End;


   if TPCount=0 then
     exit;

   if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

   if MapMode = 5 then
        fi := - CurrentRouteAngle;

   for I := 1 to TPCount do
   Begin

     dx := (Center.x - TurnPoints[i-1].x)/ Scale ;
     dy := (Center.y - TurnPoints[i-1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     dx := (Center.x - TurnPoints[i].x)/ Scale ;
     dy := (Center.y - TurnPoints[i].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x2 := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y2 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     FatLine(x, y, x2, y2, 1 + DopFat, false, cRGB1(GetBValue(ChoosedColor),
             GetGValue(ChoosedColor),GetRValue(ChoosedColor),40));
      
   End;

   if not LocalTP then
      HideArrow := true;
//// Base
///
   {  if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     dx := (Center.x - Base[1].x)/ Scale ;
     dy := (Center.y - Base[1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     csize := 32;
     if BigCur then
        csize := 64;

     if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
         begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['flag_big.image'], pxBounds4(0, 0, 64, 64))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['flag.image'], pxBounds4(0, 0, 32, 32));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

         end;}
end;

procedure TMainForm.DrawZone(x1, y1, x2, y2, x3, y3, x4, y4: Double);
begin
  if not( (x1 < 0) and (x2 < 0) and (x3 < 0) and (x4 < 0)) then

  if not( (x1 > (DisplaySize.X)) and (x2 > (DisplaySize.X)) and
          (x3 > (DisplaySize.X)) and (x4 > (DisplaySize.X)) ) then

  if not( (y1 < 0) and (y2 < 0)and (y3 < 0) and (x4 < 0)) then

  if not( (y1 > DisplaySize.y) and (y2 > DisplaySize.y) and
          (y3 > DisplaySize.y) and (y4 > DisplaySize.y) ) then

  if not( (abs(y1-y2) < 1) and (abs(x1-x2) < 1) and (abs(y3-y4) < 1) and (abs(x3-x4) < 1) ) then

  try
     CutLineByBufferedFrame(x1,y1,x2,y2);
     CutLineByBufferedFrame(x3,y3,x4,y4);

     AsphCanvas.FillQuad(Point4(x1, y1, x2, y2, x3, y3, x4, y4),
                        cRGB4( GetBValue(ChoosedColor),GetGValue(ChoosedColor),
                                GetRValue(ChoosedColor),100));
  except

  end;

end;

procedure TMainForm.EditMarker(I: integer; Mname: string; mB, mL: Double);
begin
  with  Markers[I] do
  begin
    Caption := mName;
    B := mB;
    L := mL;
  end;

  RefreshMarkerList;
end;

procedure TMainForm.FatLine(x, y, x2, y2: Double; Thin:integer; Dash:Boolean; Col: Cardinal);
var i,j :integer;
begin
 for I := -Thin to Thin do
   for J := -Thin to Thin do
        MyLine( x+I, y+J, x2+I, y2+J, Dash, Col)

end;


procedure TMainForm.FormActivate(Sender: TObject);
begin

  //if JustStarted then
    // Autorun;

  JustStarted := false;

  AllowAuto := AutoOn;


  if not Timer.Enabled then
      Timer.Enabled:= true;


  Panel1.Cursor := crCross;

  if CropRoutes then
    MaxDotsVisible := 1000
     else
        MaxDotsVisible := MaxDotsCount;

  FormResize(nil);
end;

procedure TMainForm.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  //SaveLogFile;
 // SaveTrack;

  {if MarkerCount >0 then
  if MessageDlg(Mainform.Inf[59],mtConfirmation,[mbYes, mbNo],0) = 6 then
  Begin
    Settings.SaveDialog.FileName := Settings.MarkerFile.Text;
    if Settings.SaveDialog2.Execute() then
       Settings.SaveMarkers(Settings.SaveDialog2.FileName);
  End;       }

end;

procedure TMainForm.FormCreate(Sender: TObject);
  var Year, Month, Day : Word ;
      s : string;
      i : integer;
begin
 MyDir := GetCurrentDir + '\';

 GeoInit('Data\Sources.loc');
 SK := FindDatum('SK42');
 WGS := FindDatum('WGS84') ;

 JustStarted := true;
 MarkerCount := 0;

 // Enable Delphi debugger
 ReportMemoryLeaksOnShutdown:= DebugHook <> 0;

 // Set the display size
 DisplaySize:= Point2px(ClientWidth, ClientHeight);
 MenuX := DisplaySize.X - MenuW;

 // Indicate that we're using DirectX 9
 OpenGL := false;
 if ParamStr(1)='-gl' then
     OpenGL := true;
     
 if OpenGL then
   Factory.UseProvider(idOpenGL)
     else
      Factory.UseProvider(idDirectX9);

 // Create Asphyre components in run-time.
 AsphDevice:= Factory.CreateDevice();
 AsphCanvas:= Factory.CreateCanvas();
 AsphImages:= TAsphyreImages.Create();
 AsphMapImages:= TAsphyreImages.Create(); 

 AsphFonts:= TAsphyreFonts.Create();
 AsphFonts.Images:= AsphImages;
 AsphFonts.Canvas:= AsphCanvas;

 MediaASDb:= TASDb.Create();
 MediaASDb.FileName:= ExtractFilePath(PChar(DataDir)) + 'media.asdb';
 MediaASDb.OpenMode:= opReadOnly;

 AsphDevice.WindowHandle:= Self.Handle;
 AsphDevice.Size    := DisplaySize;
 AsphDevice.Windowed:= True;
 AsphDevice.VSync   := True;

 EventDeviceCreate.Subscribe(OnDeviceCreate, 0);

 // Attempt to initialize Asphyre device.
 if (not AsphDevice.Initialize()) then
  begin
   ShowMessage('Failed to initialize Asphyre device.');
   Application.Terminate();
   Exit;
  end;

 // Create rendering timer.
 Timer.OnTimer  := TimerEvent;
 Timer.OnProcess:= ProcessEvent;
 Timer.Speed    := 60.0;
 Timer.MaxFPS   := 4000;
 Timer.Enabled  := True;

end;

//---------------------------------------------------------------------------
procedure TMainForm.FormDestroy(Sender: TObject);
begin
 Timer.Enabled:= False;

 FreeAndNil(AsphFonts);
 FreeAndNil(AsphImages);
 FreeAndNil(AsphMapImages);
 FreeAndNil(MediaASDb);
 FreeAndNil(AsphCanvas);
 FreeAndNil(AsphDevice);
end;

procedure TMainForm.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin

  if Key = VK_F2 then
    if Windowstate = wsMaximized then
    begin
      Windowstate := wsNormal;
      BorderStyle := BsSingle;
    end
      else
        Begin
          BorderStyle := BsNone;
          Windowstate := wsMaximized;
        End;

  if Key = VK_F1 then
  begin

  end;


  if Key = VK_F5 then
    Panel5.Visible := not (Panel5.Visible);

  if Key = VK_F4 then
    ShowFPS := not (ShowFPS);



{  if Key = VK_Up then
    MenuKeyCommand(1);

  if Key = VK_Down then
    MenuKeyCommand(2);

 if Key = VK_Left then
    MenuKeyCommand(3);

 if Key = VK_Right then
    MenuKeyCommand(4);

 if Key = VK_Return then
    MenuKeyCommand(5);

 if Key = VK_Escape then
    MenuKeyCommand(6);  }

//// + - клавиши

 if (Key = 187) or (Key = 107) then
    Shiftmap(1);

 if (Key = 189) or (Key = 109) then
    Shiftmap(0);

//// W S A D

 if (Key = 87) then
    Shiftmap(2);

 if (Key = 83) then
    Shiftmap(3);

 if (Key = 65) then
    Shiftmap(4);

 if (Key = 68) then
    Shiftmap(5);

end;

procedure TMainForm.FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
var Max : Integer;
begin
 if AllowMouse then
  BEGIN
   if MousePos.x < Panel1.ClientWidth-MenuW + Left then// Panel2.Left+MainForm.Left  then
   Begin
     if (AutoOn = false) or (ChangeAutoM) then
     ShiftMap(0)
   End
   else
    begin
     Max :=  MenuCount[MenuN];
     if (MenuN=5) or (MenuN=6) then
        Max :=  RouteCount-1;

     if (Max+1)*MenuButtonSize[MenuN]>DisplaySize.y then
       begin
         if MenuScroll > -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)  then
            MenuScroll := MenuScroll - MenuButtonSize[MenuN];
         if MenuScroll < -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y) then
            MenuScroll := -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)
       end;
    end;
  END;
end;

procedure TMainForm.FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
  if AllowMouse then
  BEGIN
   if MousePos.x < Panel1.ClientWidth-MenuW + Left then
   begin
     if (AutoOn = false) or (ChangeAutoM) then
     ShiftMap(1)
   end
    else
     begin
       if MenuScroll < 0 then
         MenuScroll := MenuScroll + MenuButtonSize[MenuN];
       if MenuScroll > 0 then
          MenuScroll := 0;
     end;
  END;
end;

procedure TMainForm.FormResize(Sender: TObject);
begin
  DisplaySize := Point2px(Panel1.ClientWidth, Panel1.ClientHeight);
  AsphDevice.Size := DisplaySize;
  MenuX := DisplaySize.X - MenuW;
end;

procedure TMainForm.FormShow(Sender: TObject);
begin

  if not Timer.Enabled then
      Timer.Enabled:= true;

  //if OpenGL then
   // begin
       // AsphDevice.Reset;
        Resize;
  //  end;
end;

{function TMainForm.GetTurnPoints(xp, yp, azmt, x1, y1, x2, y2, MinR, MaxR: double): boolean;

function ang(a:double):double;
begin
   while (a<0)or(a>2*pi) do
   begin
      if a < 0 then
        a := a + 2*pi;
      if a > 2*pi then
        a := a - 2*pi;
   end;
   result := a;
end;


var i,j,k:integer;

    Az1, _Az1, Az2, Az3, Az4, dA, _dA, dA0, _dA0, R, cx, cy, cx2, cy2, step : double;

    RP, RP2 : TPosAndDist;
    cxy : TMyPoint;

    Dmin,L : double;

    AngStep : real;
    isRight, SideStep, SideStep0, OddStep, NeedShift, NeedLC: boolean;
begin
    ReCalcWay := false;
    needlc := false;

//    STT := SpecialTP;

    if LocalTP then
    begin

      if not SPecialTP then
      if (LocalR1 = PrevRoute) and (LocalR2 = CurrentRoute) and (not ReflyCurrent) then
      Begin
        Result := true;
        exit;
       End;

        if ReflyCurrent then
           LocalR1 := -1;

       if not SPecialTP then
       if (PrevRoute = -1) or (CurrentRoute =-1) then
       Begin
         TPCount :=0;
         exit;
       End;

       SpecialTP := false;

       if CurrentRoute = PrevRoute then
           exit;

       if not ReflyCurrent then
       Begin
         LocalR1 := PrevRoute;
         LocalR2 := CurrentRoute;

       ///  Az2 := ang(arctan2(x2-x1,y2-y1));
       End;
    end;


    if LocalTP then
    Begin
       xp := xp +  MinR/4*Sin(azmt);
       yp := yp +  MinR/4*Cos(azmt);
    End;


    if SpecialTP then
      if NextRoute = -1 then
         exit;

    if ReflyCurrent then
           LocalR1 := -1;


    SpecialTP := false;

    TurnPoints[0].x := xp;
    TurnPoints[0].y := yp;

    TPCount :=1;
    NeedShift := false;
    try
      /// 1

      Az1 := ang(azmt);
      Az2 := ang(arctan2(x2-x1,y2-y1));

      isRight := ang(arctan2(xp-x1,yp-y1) - az2) < pi;

      dA  := ang(Az2 - Az1);
      _dA := ang(Az2 + pi - Az1);



     // isClockwise := not( (dA < pi/2)or( dA > 3*pi/2 ) );

      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);


       if (abs(dA) = pi) then
         R := RP.Dist/2
         else
         if (dA = 0)or(dA = 2*pi) then
           R := MaxR
           else
             R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

       SideStep0 := ( (dA < pi/2)or( dA > 3*pi/2 ));
       SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

       OddStep := true;
       AngStep := 0;
       _Az1 := Az1;

       if R < MinR then
        begin
          if (Sidestep) and(RP.Pos < 0) then
          Begin


              cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                    begin
                       TurnPoints[1].x :=  x1;
                       TurnPoints[1].y :=  y1;
                    end;

                  exit;

          End else
          while (R < minR) and (AngStep < pi) do
          Begin

              if OddStep then
                  AngStep := AngStep + 0.01;

              if OddStep then
                   Az1 := _Az1 - AngStep
                     else
                       Az1 := _Az1 + AngStep;

             if OddStep <> isRight then
              Begin
                  OddStep := not OddStep;
                   continue;
              End;

               dA  := ang(Az2 - Az1);
               _dA := ang(Az2 + pi - Az1);
               RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

               if (abs(dA) = pi) then
                 R := RP.Dist/2
                  else
                  if (dA = 0)or(dA = 2*pi) then
                     R := MaxR
                        else
                          R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

               SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

               OddStep := not OddStep;

          End;
        end;

      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);
      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

      if (SideStep0)and(RP.Dist < RouteMaxDist*1.5) then
      Begin

         cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

         TPCount := 1;
         TurnPoints[1].x :=   cxy.x;
         TurnPoints[1].y :=   cxy.y;
         if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
         Begin
            TurnPoints[1].x :=  x1;
            TurnPoints[1].y :=  y1;
         End;

        if RP.Dist< RouteMaxDist then
           TPCount := 0;
        exit;
      End;

      if R >= MaxR then
      Begin

        SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

        if not isRight then
        begin
           Az3 := az1+pi/2;
           dA0 := ang(Az2 +pi/2 - Az1);
           _da0 :=  -pi/2;
           Az4 := (Az2 + pi);

           R := (MaxR+MinR)/2;
           cx := xp - R*Sin(az3);
           cy := yp - R*Cos(az3);
           cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
           cx2 := cxy.x;
           cy2 := cxy.y;

           if SideStep Then
           Begin

             Az3 := Az1-pi/2;
             Az4 := (Az2 - pi);
             ///_da0 :=  -pi/2;

             R := MinR;
             cx := xp + R*Sin(az3+pi);
             cy := yp + R*Cos(az3+pi);

             cxy := GetNormalPt(x1, y1, x2, y2, cx + 2*R*Sin(az2) , cy + 2*R*Cos(az2), isRight, R);
             cx2 := cxy.x ;
             cy2 := cxy.y ;

             RP2 := GetPosAndDist(x1, y1, x2, y2, cx2, cy2);

             if RP2.Pos > 0 then
             Begin
               /// CANCEL!
               SideStep := false;
               Az3 := az1+pi/2;
               dA0 := ang(Az2 +pi/2 - Az1);
              ///_da0 :=  -pi/2;
               Az4 := (Az2 + pi);

               R := (MaxR+MinR)/2;
               cx := xp - R*Sin(az3);
               cy := yp - R*Cos(az3);
               cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
               cx2 := cxy.x;
               cy2 := cxy.y;


               if R < MinR then
               begin
                    OddStep := true;
                    AngStep := 0;
                    while (R < minR) and (AngStep < pi) do
                    Begin

                      if OddStep then
                        AngStep := AngStep + 0.01;

                      if OddStep then
                       Az1 := _Az1 - AngStep
                        else
                          Az1 := _Az1 + AngStep;

                      dA  := ang(Az2 - Az1);
                      _dA := ang(Az2 + pi - Az1);
                      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

                      if (abs(dA) = pi) then
                         R := RP.Dist/2
                            else
                            if (dA = 0)or(dA = 2*pi) then
                              R := MaxR
                                else
                                  R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

                      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));
                      OddStep := not OddStep;

                  End;
                end;

             End;


           End;

           if SideStep Then
           Begin
               if  RP.Dist > 2*MinR then
               BEGIN
                  step := ang(dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  MinR*Sin(az3+step*I)+cx;
                      TurnPoints[I].y :=  MinR*cos(az3+step*I)+cy;
                  end;


                 step := ang(-_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4-(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4-(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
               END
                ELSE
                BEGIN             

                  cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                  Begin
                    TurnPoints[1].x :=  x1;
                    TurnPoints[1].y :=  y1;
                  End;
                    exit;
                END;
           End
             else
              Begin

                  step := ang(-dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az3-step*I)+cx;
                      TurnPoints[I].y :=  R*cos(az3-step*I)+cy;
                  end;


                  step := ang(-_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4-(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4-(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
              End;

        end
           else
           begin

             Az3 := Az1-pi/2;
             dA0 := ang(Az2 -pi/2 - Az1);
             Az4 := (Az2 - pi);
             _da0 :=  pi/2;

             R := (MaxR+MinR)/2;
             cx := xp - R*Sin(az3);
             cy := yp - R*Cos(az3);
             cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
             cx2 := cxy.x;
             cy2 := cxy.y;

           if SideStep Then
           Begin

             Az3 := Az1 + pi/2;
             Az4 := (Az2 + pi);

             R := MinR;
             cx := xp + R*Sin(az3+pi);
             cy := yp + R*Cos(az3+pi);

             cxy := GetNormalPt(x1, y1, x2, y2, cx + 2*R*Sin(az2) , cy + 2*R*Cos(az2), isRight, R);
             cx2 := cxy.x ;
             cy2 := cxy.y ;

             RP2 := GetPosAndDist(x1, y1, x2, y2, cx2, cy2);

             if RP2.Pos > 0 then
             Begin
               //// Cancel!

                Az3 := Az1-pi/2;
                dA0 := ang(Az2 -pi/2 - Az1);
                Az4 := (Az2 - pi);
               // _da0 :=  pi/2;

                 R := (MaxR+MinR)/2;
                 cx := xp - R*Sin(az3);
                 cy := yp - R*Cos(az3);
                 cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
                 cx2 := cxy.x;
                 cy2 := cxy.y;

                 SideStep := false;

                 if R < MinR then
               begin
                    OddStep := true;
                    AngStep := 0;
                    while (R < minR) and (AngStep < pi) do
                    Begin

                      if OddStep then
                        AngStep := AngStep + 0.01;

                      if OddStep then
                       Az1 := _Az1 - AngStep
                        else
                          Az1 := _Az1 + AngStep;

                      dA  := ang(Az2 - Az1);
                      _dA := ang(Az2 + pi - Az1);
                      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

                      if (abs(dA) = pi) then
                         R := RP.Dist/2
                            else
                            if (dA = 0)or(dA = 2*pi) then
                              R := MaxR
                                else
                                  R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

                      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));
                      OddStep := not OddStep;

                  End;
                end;
             End;


           End;

           if SideStep Then
           Begin
               if  RP.Dist > 2*MinR then
               BEGIN
                  step := ang(-dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  MinR*Sin(az3-step*I)+cx;
                      TurnPoints[I].y :=  MinR*cos(az3-step*I)+cy;
                  end;


                 step := ang(_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4+(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4+(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
               END
                ELSE
                BEGIN
                  cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                  Begin
                     TurnPoints[1].x :=  x1;
                     TurnPoints[1].y :=  y1;
                  End;
                    exit;
                END;
           End
             else
              Begin

                  step := ang(dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az3+step*I)+cx;
                      TurnPoints[I].y :=  R*cos(az3+step*I)+cy;
                  end;


                  step := ang(_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4+(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4+(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
              End;

           end;


      End else
      Begin
       /// Caption := IntToStr(Trunc(RP.DistTo0));

        ///  4    if Ok
        if not isRight then
          az3 := az1+pi/2
           else
             az3 := az1-pi/2;

         cx := xp - R*Sin(az3);
         cy := yp - R*Cos(az3);

         RP2 := GetPosandDist(x1,y1,x2,y2,cx,cy);

        if ( ( abs(RP.DistTo0)<MaxR)and((R> MaxR)or(R<MinR)and(not SideStep0)) or (RP2.Pos > 0.01) ) and (R< MaxR)or(R<MinR) and
            ((not isRight)and((_dA)<pi)or
             ( isRight)and(ang(-_dA)<pi)) then
         begin
           NeedLC := true;

           if not isRight then
            Az1 := az2 - pi/2 //ang(az1-pi/4)
             else
               Az1 := az2 + pi/2;// ang(az1+pi/4);

            dA  := ang(Az2 - Az1);
            _dA := ang(Az2 + pi - Az1);

            if (abs(dA) = pi) then
                 R := RP.Dist/2
                  else
                  if (dA = 0)or(dA = 2*pi) then
                     R := MaxR
                        else
                          R := tan((_dA)/2) * (RP.Dist/Sin(_dA));
             if R < MinR then
             Begin
               R := MinR;
               NeedShift := true;
             End;

          if not isRight then
          az3 := az1+pi/2
           else
             az3 := az1-pi/2;

           cx := xp - R*Sin(az3);
           cy := yp - R*Cos(az3);

         end;

        // SideStep := ( (ang(dA) < pi/2)or( ang(dA) > 3*pi/2 ));
         SideStep :=  (not isRight) and (ang(dA) < pi/2)or (isRight) and ( ang(dA) > 3*pi/2 );

         if (SideStep0) and ((RP.Pos < 0) and not(ReflyCurrent)) Then
           Begin

              cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

              TPCount := 1;
              TurnPoints[1].x :=   cxy.x;
              TurnPoints[1].y :=   cxy.y;

              if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
              Begin
                 TurnPoints[1].x :=  x1;
                 TurnPoints[1].y :=  y1;
              End;

              exit;

           end;


       ///// if Ok      2

         TPCount := 24;

         if not isRight then
         Begin
           step := ang(-dA)/24;

           for I := 0 to 24 do
           begin
             TurnPoints[I].x :=  R*Sin(az3-step*I)+cx;
             TurnPoints[I].y :=  R*cos(az3-step*I)+cy;
           end;

         End
          else
          Begin
            step := ang(dA)/24;

            for I := 0 to 24 do
            begin
              TurnPoints[I].x :=  R*Sin(az3+step*I)+cx;
              TurnPoints[I].y :=  R*cos(az3+step*I)+cy;
            end;
          End;

       End;

       RP2 := GetPosAndDist(x1, y1, x2, y2, TurnPoints[TPCount].x, TurnPoints[TPCount].y);

       if NeedShift then
       for i:= 1 to TPCount do
       begin
          if not isRight then
            az4 := az2 + pi/2
              else
                az4 := az2 - pi/2;

          L := RP2.Dist;

          TurnPoints[i].x :=  TurnPoints[i].x - sin(az4)*L;
          TurnPoints[i].y :=  TurnPoints[i].y - cos(az4)*L;
       end;

      RP2 := GetPosAndDist(x1, y1, x2, y2, TurnPoints[TPCount].x, TurnPoints[TPCount].y);
      if RP2.Pos >0 then
      try


        dmin := pi;
        j:= 1;
        for i := 1 to TPcount do
        begin
          l := (ang(arctan2(TurnPoints[i].x - TurnPoints[i-1].x,
              TurnPoints[i].y - TurnPoints[i-1].y))-ang(pi+az2)) ;
          if abs(l) < abs(dmin) then
          begin
            dmin := l;
            j := i;
          end;
        end;



        L := sqrt(sqr(x2-x1)+sqr(y2-y1))*(RP2.Pos);
        for i:= j to TPCount do
        begin
               TurnPoints[i].x :=  TurnPoints[i].x - sin(az2)*L;
               TurnPoints[i].y :=  TurnPoints[i].y - cos(az2)*L;
        end;

      except
        TPCount := 0;
        exit;
      end;

      Result := true;

      

      if (localTP)and not(ReflyCurrent) then
      Begin

        TurnPoints[TPCount+2].x :=  TurnPoints[TPCount].x ;
        TurnPoints[TPCount+2].y :=  TurnPoints[TPCount].y ;

        inc(TPCount);
        for i:= TPCount Downto 1 do
        begin
               TurnPoints[i].x :=  TurnPoints[i-1].x - sin(az2)*MinR*1.5;
               TurnPoints[i].y :=  TurnPoints[i-1].y - cos(az2)*MinR*1.5;
        end;
        inc(TPCount);

       if LocalTP then
       Begin
        ///// SMOOTH!
          dmin := pi/4;
          j:= 0;

          for i := 2 to trunc(TPcount/1.5) do
          begin
            l := ang( ang(arctan2(TurnPoints[i+1].x - TurnPoints[i].x,
                     TurnPoints[i+1].y - TurnPoints[i].y))) -
                     ang(arctan2(TurnPoints[i].x - TurnPoints[0].x,
                     TurnPoints[i].y - TurnPoints[0].y));
            if abs(l) < abs(dmin) then
            begin
             dmin := l;
             dA0 :=  ang(arctan2(TurnPoints[i+1].x - TurnPoints[i].x,
                     TurnPoints[i+1].y - TurnPoints[i].y));
             j := i;
            end;
          end;

          if j<2 then
             exit;

          if abs(ang(az2 - dA0)) > pi/10 then
          Begin

                 TurnPoints[1].x :=  TurnPoints[0].x - sin(az2)*MinR/2;
                 TurnPoints[1].y :=  TurnPoints[0].y - cos(az2)*MinR/2;
           //   end;

             if dmin < pi/4 then
             for i:= 2 to j do
             Begin
               TurnPoints[i].x :=  TurnPoints[1].x + (i)/j*(TurnPoints[j+1].x- TurnPoints[1].x);
               TurnPoints[i].y :=  TurnPoints[1].y + (i)/j*(TurnPoints[j+1].y- TurnPoints[1].y);
             End;

             for i:= 1 to j do
             Begin
               TurnPoints[i].x := (TurnPoints[i-1].x +   TurnPoints[i+1].x )/2;
               TurnPoints[i].y := (TurnPoints[i-1].y +   TurnPoints[i+1].y )/2;
             End;


                   //
                  ///         TurnPoints[0].x :=  cx;
                  //    TurnPoints[0].y := cy;

             End;
           

       End;

      End;
    except
      Result := false;
    end;
end;        }



function TMainForm.GetWGSCursor: TLatLong;
var xm, ym, x2: double;
Begin

      xm := Panel1CursorX - (DisplaySize.X - MenuW)/2;
      ym := -Panel1CursorY + DisplaySize.Y/2 + VYShift;
      x2 := xm;
      if MapModeDoRotate[MapMode] then
      begin
        if MapMode=5 then
        begin
           xm := xm * Cos (CurrentRouteAngle) + ym * sin(CurrentRouteAngle);
           ym := ym * Cos (CurrentRouteAngle) - x2* sin(CurrentRouteAngle);
        end
          else
          begin
            xm := xm * Cos (azimuth) + ym * sin (azimuth);
            ym := ym * Cos (azimuth) - x2* sin (azimuth);
          end;
      end;

      xm := xm * Scale + Center.X;
      ym := ym * Scale + Center.Y;

      if UTM then
         UTMToGeo(WGS,ym,xm,South,Result.lat,Result.long)
        else
          SKToWGS(ym,xm,0,Result.lat,Result.long);

  // ShowMessage(DegToDMS(Result.lat,4)+' '+DegToDMS(Result.long,4));
End;


procedure TMainForm.GoToNextRoute;
var L,L2 : longInt;
    OldRoute : integer;
    s : string;
begin
    OldRoute := CurrentRoute;
    if NumDist>0 then
      if not ReflyCurrent then
      begin
        Route[CurrentRoute].AverageDist := (sqrt(SumDist/NumDist));
        Route[CurrentRoute].BadHgts := round(100*(NumBadHgt/NumDist));

        if Route[CurrentRoute].badHgts = 0 then
          s := '-'
            else
              s := IntTostr(Route[CurrentRoute].badHgts)+' %';
//        if RealTime then    z
        FromBegin := not (FromBegin);
        Route[CurrentRoute].EndTime :=  CurTime ;
        Report.Add( Route[CurrentRoute].Name + #$9 + Route[CurrentRoute].StartTime + #$9
                    + Route[CurrentRoute].EndTime + #$9
                    + format('%.1f',[Route[CurrentRoute].AverageDist]) + inf[20] + #$9 + #$9
                    + s + #$9
                    + Route[CurrentRoute].RLabel);

        Route[CurrentRoute].RLabel :='';
      end;

    if not BadDist then
    begin
      if Route[CurrentRoute].AverageDist < RouteMaxDist/2 then
      begin
       Route[CurrentRoute].Status := 2
      end
        else
          Route[CurrentRoute].Status := 3;
    end
      else
      Begin
         if MenuN = 4 then
         begin
           MenuN := 1;
           MenuScroll :=0;
           RouteAsk :=-1;
         end;

          if not WorstDist then
             Route[CurrentRoute].Status := 3
               else
                begin
                  ReflyCurrent := True;
                  BadDist := false;
                  WorstDist := false;
                end;
      End;

    if not ReflyCurrent then
    Begin
        if NextRoute=-1 then
          GetNextRoute;

        if NextRoute<>-1 then
          SetCurrentRoute(NextRoute)
            else
             Begin               /// Routes are over
                CurrentRoute :=-1;
                if AutoON then
                begin
                  RouteAsk :=-1;
                  MenuScroll :=0;
                  MenuN := 10;
                end;
             End;
    End;

    if OldRoute<>CurrentRoute then
       PrevRoute := OldRoute;

    ReFlyCurrent := false;
    SumDist := 0;
    NumDist := 0;
    NumBadHgt := 0;
    BadDist := false;
    WorstDist := false;
   // BackStep := not BackStep;
end;

procedure TMainForm.GPSTimerEvent;
begin

end;


procedure TMainForm.InitData;
begin

  MashtabNames [0] := '10 м' ;
  MashtabNames [1] := '20 м' ;
  MashtabNames [2] := '50 м' ;
  MashtabNames [3] := '100 м';
  MashtabNames [4] := '200 м';
  MashtabNames [5] := '500 м';
  MashtabNames [6] := '1 км' ;
  MashtabNames [7] := '2 км' ;
  MashtabNames [8] := '5 км' ;
  MashtabNames [9] := '10 км' ;
  MashtabNames [10] := '20 км' ;
  MashtabNames [11] := '50 км' ;

  MapModeNames [0] := 'Обзор карты'        ;
  MapModeNames [1] := 'Полет к ближайшему' ;
  MapModeNames [2] := 'Полет к ближайшему' ;
  MapModeNames [3] := 'Полет по маршрутам' ;
  MapModeNames [4] := 'Полет по маршрутам' ;
  MapModeNames [5] := 'Полет по маршрутам' ;
  MapModeNames [6] := 'Возвращение на базу';
  MapModeNames [7] := 'Возвращение на базу';
  MapModeNames [8] := 'Свободный полет';
  MapModeNames [9] := 'Свободный полет';


  MapModeShortNames [0]:= 'ОБЗОР';
  MapModeShortNames [1]:= 'БЛИЖ.';
  MapModeShortNames [2]:= 'БЛИЖ.';
  MapModeShortNames [3]:= 'МАРШ.';
  MapModeShortNames [4]:= 'МАРШ.';
  MapModeShortNames [5]:= 'МАРШ.';
  MapModeShortNames [6]:= 'БАЗА';
  MapModeShortNames [7]:= 'БАЗА';
  MapModeShortNames [8]:= 'СВОБ.';
  MapModeShortNames [9]:= 'СВОБ.';

  MapModeSubNames [0] := '(ориентация на Север)'   ;
  MapModeSubNames [1] := '(ориентация на Север)'   ;
  MapModeSubNames [2] := '(ориентация по азимуту)' ;
  MapModeSubNames [3] := '(ориентация на Север)'   ;
  MapModeSubNames [4] := '(ориентация по азимуту)' ;
  MapModeSubNames [5] := '(ориентация по маршруту)';
  MapModeSubNames [6] := '(ориентация на Север)'   ;
  MapModeSubNames [7] := '(ориентация по азимуту)' ;
  MapModeSubNames [8] := '(ориентация на Север)'   ;
  MapModeSubNames [9] := '(ориентация по азимуту)' ;

  MapModeShortSubNames [0] := ' (Север)'   ;
  MapModeShortSubNames [1] := ' (Север)'   ;
  MapModeShortSubNames [2] := ' (Аз.)' ;
  MapModeShortSubNames [3] := ' (Север)'   ;
  MapModeShortSubNames [4] := ' (Аз.)' ;
  MapModeShortSubNames [5] := ' (Марш.)';
  MapModeShortSubNames [6] := ' (Север)'   ;
  MapModeShortSubNames [7] := ' (Аз.)' ;
  MapModeShortSubNames [8] := ' (Север)'   ;
  MapModeShortSubNames [9] := ' (Аз.)' ;

  Inf [1] := 'Зона проекции:';
  Inf [2] := 'Спутники:';
  Inf [3] := 'Время GPS:';
  Inf [4] := 'Текущий путь:';
  Inf [5] := 'Полный путь:';
  Inf [6] := 'Для перемещения карты используйте';
  Inf [7] := 'левую кнопку мыши или клавиши W S A D';
  Inf [8] := 'Превышен допуск расстояния до маршрута';
  Inf [9] := 'Выполните повторный заход на маршрут';
  Inf [10] := 'Маршрут уже пройден. Выполнить повторное следование?';
  Inf [11] :=  'Удаление от маршрутов более 2 км. Продолжить съемку?';
  Inf [12] :=  'База достигнута';
  Inf [13] :=  'Нет непройденных маршрутов в очереди';
  Inf [14] :=  'Добавлено продолжений:';
  Inf [15] :=  'Настройки файла маршрутов заданы неверно или файл имеет некорректный формат!';
  Inf [16] :=  'Скорость: ';
  Inf [17] :=  ' км/ч';
  Inf [18] :=  'Азимут: ';
  Inf [19] :=  'Высота: ';
  Inf [20] :=  ' м';
  Inf [21] :=  'Режим:';
  Inf [22] :=  'Масштаб:';
  Inf [23] :=  'Текущий:';
  Inf [24] :=  'Следующий:';
  Inf [25] :=  ' км';
  Inf [26] :=  'От текущего:';
  Inf [27] :=  'Авторежим:';
  Inf [28] :=  'Вкл.';
  Inf [29] :=  'Выкл.';
  Inf [30] :=  'Пролететь текущий';
  Inf [31] :=  'Перейти к ближайшему';
  Inf [32] :=  'Продолжить следование';
  Inf [33] :=  'маршрут заново';
  Inf [34] :=  'маршруту';
  Inf [35] :=  'по текущему';
  Inf [36] :=  'Маршрут';
  Inf [37] :=  'Статус:';
  Inf [38] :=  'не пройден';
  Inf [39] :=  'текущий';
  Inf [40] :=  'пройден (Ок)';
  Inf [41] :=  'пройден (грубо)';
  Inf [42] :=  'Лететь заново';
  Inf [43] :=  'Отмена';
  Inf [44] :=  'К маршрутам';
  Inf [45] :=  'На базу';
  Inf [46] :=  'Продолжить полет';
  Inf [47] :=  'Завершить навигацию';
  Inf [48] :=  '(Полет к ближайшему)';
  Inf [49] :=  '(Обзор карты, авто: выкл)';
  Inf [50] :=  'Перепройти маршрут';
  Inf [51] :=  'Вернуться на базу';
  Inf [52] :=  'Выйти из режима авто';

  Inf [53] :=  'Не пройд.';
  Inf [54] :=  'ОК'; 
  Inf [55] :=  'Грубо';

  LangExe :='';

  with LoadRData do
  begin
    LatS := 'Широта B, ';
    LonS := 'Долгота L, ';
    XS := 'X, м'; YS := 'Y, м'; ZS := 'Z, м';
    NordS := 'Север, м';
    SouthS:= 'Юг, м';
    NSS := 'Север/Юг, м';
    EWS := 'Запад/Восток, м';
    WestS := 'Запад, м';
    EastS := 'Восток, м';
    NameS := 'Имя'
  end;

  Settings.ProtList;

  Settings.Languages.OnChange(nil);
  JoyResetN :=0;
  HgtID := 0;

  Center.x := 0;
  Center.y := 0;

  Mashtab := 7;

  MinR := 100;
  MaxR := 200;

  TPCount :=0;
  Settings.AutoZone.Checked := true;

  AskR :=  2500;
  AskReturn := true;
end;

procedure TMainForm.LoadAUXProt(FName:string);
var S: TStringList;
begin
   FName := DataDir+'Protocols\'+FName+'.prt';

   S:= TStringList.Create;
   
   try
    S.LoadFromFile(FName);

    with AUXProt do
    begin
      RName := s[0];
      RSepN := StrToInt(s[1]);
      RSep  := s[2];
      RParN := StrToInt(s[3]);
      RDataType  := StrToInt(s[4]);
      RCoef := StrToFloat2(s[5]);

      case RSepN  of
         0: RSep := ' ';
         1: RSep := #$9;
         2: RSep := ',';
         3: RSep := '.';
      end;

      LName := s[7];
      LSepN := StrToInt(s[8]);
      LSep  := s[9];
      LParN := StrToInt(s[10]);
      LDataType  := StrToInt(s[11]);
      LCoef := StrToFloat2(s[12]);

      case LSepN  of
         0: LSep := ' ';
         1: LSep := #$9;
         2: LSep := ',';
         3: LSep := '.';
      end;
    end;
   except
   end;

   S.Destroy;
end;

procedure TMainForm.LoadMaps(Filename:String);
var
 MapAsdb : TASDB;
 i, j, N, k : integer;
 S : TStringList;
 Stream : TFileStream;
 ImgName, CurImgName : String;
 xx, yy : Double;
begin

 FLoadGPS.Show;
 FLoadGPS.GPSLoad.Visible := false;
 FLoadGPS.GPSLoad2.Visible := false;
 FLoadGPS.MapLoad.Visible := true;
 FLoadGPS.LCount.Visible := true;
 FLoadGPS.Repaint;
 FloadGPS.ProgressBar1.Position := 0;


 MapASDb:= TASDb.Create();
 MapASDb.FileName:= FileName;
 MapASDb.OpenMode:= opReadOnly;

 MapAsdb.Update;

 S := TStringList.Create;
 //if fileexists(DataDir+'stream.tmp') then
   S.SaveToFile(DataDir+'stream.tmp');

 

 for I := 0 to MapASDb.RecordCount-1 do
   if MapASDb.RecordType[i] = recFile then
   Begin
     Stream := TFileStream.Create(DataDir+'stream.tmp',1);
   //  Stream := MapASDb.ReadStream(MapASDb.RecordKey[i])
     MapASDb.ReadStream(MapASDb.RecordKey[i] ,Stream);

     Stream.Destroy;
     S.Clear;
     //S.LoadFromStream(Stream);
     S.LoadFromFile(DataDir+'stream.tmp');

     ImgName := MapASDb.RecordKey[i];
     ImgName := Copy(ImgName,1,length(ImgName)-4);

     for J := 0 to S.Count - 1 do
     begin
          FLoadGPS.ProgressBar1.Position := Trunc(100*j/(S.Count-1));

          CurImgName := ImgName+'_'+GetCols(S[j],0,1,0)+'_'+GetCols(S[j],1,1,0);
          N := AsphMapImages.AddFromASDb(CurImgName+'_t', MapASDb, CurImgName+'_t', true);
          N := AsphMapImages.AddFromASDb(CurImgName+'_s', MapASDb, CurImgName+'_s', true);
          N := AsphMapImages.AddFromASDb(CurImgName, MapASDb, CurImgName, true);
          if N > -1 then
          Begin
//           AsphMapImages.Items[N].

            SetLength(MapList,Length(MapList)+1);
            MapList[Length(MapList)-1].imgName := CurImgName;
            MapList[Length(MapList)-1].imgN := N;

            for k := 1 to 4 do
            Begin
              MapList[Length(MapList)-1].Gx[k] := StrToFloat(GetCols(S[j],k*2,1,0));
              MapList[Length(MapList)-1].Gy[k] := StrToFloat(GetCols(S[j],k*2+1,1,0));

              if UTM then
                 GeoToUTM(WGS,MapList[Length(MapList)-1].Gx[k],
                          MapList[Length(MapList)-1].Gy[k],
                          South, yy,xx, Myzone, WaitForZone)
               else
                   WGSToSK(MapList[Length(MapList)-1].Gx[k],
                           MapList[Length(MapList)-1].Gy[k],
                           0, xx,yy, MyZone, WaitForZone);

              MapList[Length(MapList)-1].x[k] := xx;
              MapList[Length(MapList)-1].y[k] := yy;
            End;  /// k cycle

          End;  /// N>-1

     end;

   End;

// Stream.Destroy;
 FLoadGPS.Hide;
 S.Destroy;
 MapAsdb.Destroy;
end;

procedure TMainForm.MenuKeyCommand(Key: Byte);
var I, MN, OldMode:integer;
begin
///

  if inSmart then
  Begin
    SmartMenuKeyCommand(Key);
    exit;
  End;

  case Key of
    1: Begin  /// UP
        case (SmartMenu) and (MenuN=1) of
           true:  if ChoosedMenu > -1 then
                     Dec(ChoosedMenu)
                       else
                         if (MenuN<>5)and(MenuN<>6) then
                         Begin
                            ChoosedMenu := MenuCount[MenuN];
                            if (MenuN=1) then
                            begin
                                // ChangeAutoM := False;
                                if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
                                    ChoosedMenu := MenuCount[MenuN]-1;
                            end;

                         End;

           false: if ChoosedMenu > 0 then
                     Dec(ChoosedMenu);
        end;


       if (MenuN = 5 ) or (MenuN = 6) then
          RouteAsk :=  ChoosedMenu;

       if MenuN=1 then
          ChangeAutoM := False;
    End;
    
    2: Begin   /// DOWN
       if (MenuN = 5 ) or (MenuN = 6) then
       begin
         if ChoosedMenu < RouteCount-1 then
            Inc(ChoosedMenu);
            RouteAsk :=  ChoosedMenu;
       end else
          if ChoosedMenu < MenuCount[MenuN] then
              Inc(ChoosedMenu)
                else
                  if (SmartMenu) and (MenuN=1) then /// Если есть кнопка SmartMenu
                  begin
                     ChoosedMenu := -1;
                  end;

          if (MenuN=1) then
          begin
              ChangeAutoM := False;
              if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
                   ChoosedMenu := MenuCount[MenuN]-1;
          end;
    End;

    3: Begin   /// LEFT
       case MenuN of
          1: begin
            CASE ChoosedMenu OF
               0: if SmartMenu then
                   ChoosedMenu := -1;
               1: //if EnableCom2 then
                 begin
                    Dec(HgtID);
                    if HgtId<0 then
                    HgtId := 3;
                 end;
                  // else
                    // HgtId := 0;
               3:if not AutoOn then
                 begin
                 if MapMode>0 then
                   Dec(MapMode)
                    else
                      MapMode:= MapModesCount;
                   DistToBase := -1;
                   Follow := (MapMode>2)and(MapMode<6);
                 end;
               4: if AutoOn = false or ChangeAutoM then
                    if Mashtab > 0 then
                      Dec(Mashtab);

               5 : for I := CurrentRoute-1 Downto 0 do
                     if Route[i].Status=0 then
                       begin
                          SetCurrentRoute(i);
                          break;
                       end;

               6 : for I := NextRoute-1 Downto 0 do
                     if Route[i].Status=0 then
                       begin
                          NextRoute := i;
                          SpecialTP := true;
                          CurToNextDist;
                          break;
                       end;

               7: AutoOn := not AutoOn;
            END;
          end;



       end;

    End;

    4: Begin   ///  RIGHT
      case MenuN of
          1: begin
            CASE ChoosedMenu OF
               -1: ChoosedMenu := 0;
               1: //if EnableCom2 then
               begin
                    Inc(HgtID);
                    if HgtId>3 then
                    HgtId := 0;
               end;
                // else
                  // HgtId := 0;


               3:if not AutoOn then
                 begin
                   if MapMode< MapModesCount then
                    Inc(MapMode)
                     else
                       MapMode:=0 ;

                   DistToBase := -1;

                   //if MapMode>2 then
                    Follow := (MapMode>2)and(MapMode<6);
                 end;
                 
               4: if AutoOn = false or ChangeAutoM then
                    if Mashtab < MaxMashtab-1 then
                      Inc(Mashtab);

               5 : for I := CurrentRoute+1 to RouteCount - 1 do
                     if Route[i].Status=0 then
                       begin
                          SetCurrentRoute(i);
                          break;
                       end;

               6 : for I := NextRoute+1 to RouteCount - 1 do
                     if Route[i].Status=0 then
                       begin
                          NextRoute := i;
                          SpecialTP := true;
                          CurToNextDist;
                          break;
                       end;

               7: AutoOn := not AutoOn; 
            END;
          end;



       end;

    End;

    5: Begin   ///  ENTER
        case MenuN of
          1: begin
            case ChoosedMenu of
               -1: inSmart := true;


               1:   //if EnableCom2 then
               begin
                    Inc(HgtID);
                    if HgtId>3 then
                    HgtId := 0;
               end;
                // else
                  // HgtId := 0;
               3: if not AutoOn then
               begin
                  MenuN:=2;
                  ChoosedMenu := MapMode;
                  Menuscroll := 0;
               end;
               4: if AutoOn = false or ChangeAutoM then
               begin
                  MenuN:=3;
                  ChoosedMenu := Mashtab;
                  Menuscroll := 0;
               end
                else
                  if AutoOn then
                    ChangeAutoM := not ChangeAutoM;

               5: if RouteCount >0 then
               begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
               end;
               6: if RouteCount >0 then
               begin
                  MenuN:=6;
                  ChoosedMenu := NextRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
               end;
               7: AutoOn := not AutoOn;
            end;
            {if MenuN < 3 then
               ChoosedMenu := 0; }

          end;
          2: begin
            OldMode := MapMode;
            MapMode := ChoosedMenu;
            Follow := (MapMode>2)and(MapMode<6);
            if Follow then
                if RouteCount=0 then
                Begin
                    MapMode := OldMode;
                    Follow := false;
                End;

            MenuN:=1;
            ChoosedMenu := 3;
            Menuscroll := 0;
            DistToBase :=-1;
          end;
          3: begin
            Mashtab := ChoosedMenu;
            MenuN:=1;
            ChoosedMenu := 4;
            Menuscroll := 0;
          end;
          4: begin
            case ChoosedMenu of
              0: begin
                  ReflyCurrent := true;
                  WorstDist:= false;
                  BadDist := false;
                 end;
              1: begin
                   if SizeTrackRecord > 1 then
                   Begin
                      GetNearestRoute(TrackRecord[SizeTrackRecord -1].x,
                                      TrackRecord[SizeTrackRecord -1].y);
                      SetCurrentRoute(NearestRoute);
                      BadDist := false;
                      WorstDist:= false;
                      Route[CurrentRoute].RLabel := '*'+inf[69];
                   End;

                 end;
              2: Begin
                  WorstDist:= false;
                  BadDist := false;
                 End;
            end;
            MenuN:=1;
            ChoosedMenu := 4;
            Menuscroll := 0;
          end;
          5: begin
            if (ChoosedMenu >= 0) and (ChoosedMenu < RouteCount) then
               if Route[ChoosedMenu].Status > 1 then
               begin
                  MenuN:=7;
                  AskForNext := False;
                  RouteAsk :=  ChoosedMenu;
                  ChoosedMenu := 0;
               end
                else
                Begin
                  SetCurrentRoute(ChoosedMenu);
                  MenuN:=1;
                  ChoosedMenu := 5;
                  RouteAsk :=-1;
                End;

               Menuscroll := 0;
          end;
          6: begin
            if (ChoosedMenu >= 0) and (ChoosedMenu < RouteCount) then
               if Route[ChoosedMenu].Status > 1 then
               begin
                  MenuN:=7;
                  AskForNext := True;
                  RouteAsk :=  ChoosedMenu;
                  ChoosedMenu := 0;
               end
                else
                Begin
                  NextRoute := ChoosedMenu;
                  SpecialTP := true;
                  CurToNextDist;
                  MenuN:=1;
                  ChoosedMenu := 6;
                  RouteAsk :=-1;
                End;

               Menuscroll := 0;
          end;

          7: begin
            if (ChoosedMenu = 0 ) then
            BEGIN
               if (RouteAsk >= 0) and (RouteAsk < RouteCount) then
               Begin
                 Route[RouteAsk].Status := 0;
                 Route[RouteAsk].AverageDist:= 0;
                 if not AskForNext then
                    SetCurrentRoute(RouteAsk)
                      else
                      begin
                        NextRoute := ChoosedMenu;
                        SpecialTP := true;
                        CurToNextDist;
                      end;
               End;
               MenuN:=1;
               RouteAsk :=-1;
               Menuscroll := 0;
            END
             else
             Begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
             End;
          end;

          8: Begin
               RouteAsk :=-1;
               Menun:=1;
               if ChoosedMenu = 0 then
               begin
                  Mashtab := AutoM[3];
                  MapMode := 1 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
               end
                else
                begin
                  GetDistToBase(TrackRecord [SizeTrackRecord -1].x,
                                TrackRecord [SizeTrackRecord -1].y );
                  Mashtab := AutoM[3];
                  MapMode := 6 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
                end;

             End;

          9: Begin
               RouteAsk :=-1;
               Menun:=1;
               if ChoosedMenu = 0 then
               begin
                  Mashtab := AutoM[3];
                  MapMode := 1 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
               end
                else
                begin
                  ///Mashtab := AutoM[3];
                  AutoOn := false;
                  MapMode := 0;
                  Follow := (MapMode>2)and(MapMode<6);
                end;

             End;

          10: Begin
               RouteAsk :=-1;
               Menun:=1;
               case ChoosedMenu of
                  0:begin
                    MenuN:=5;
                    ChoosedMenu := 0;
                    RouteAsk :=  ChoosedMenu;
                    Menuscroll := 0;
                  end;
                  1:begin
                    Mashtab := AutoM[3];
                    MapMode := 6 + AutoM[4];
                    Follow := (MapMode>2)and(MapMode<6);
                  end;
                  2: begin
                    AutoOn := false;
                    MapMode := 0;
                    Follow := (MapMode>2)and(MapMode<6);
                  end;
               end;


             End;
        end;
        Follow := (MapMode>2)and(MapMode<6);
    End;

    6: Begin   ///  ESC
      if Menun<>1 then
      begin
         case menun of
           2: ChoosedMenu := 3;
           3: ChoosedMenu := 4;
           4: BadDist := false;

           5: ChoosedMenu := 5;

           6: ChoosedMenu := 6;

           7: Begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
              End;

           8: Begin
               Mashtab := AutoM[3];
               MapMode := 1 + AutoM[4];
               Follow := (MapMode>2)and(MapMode<6);
           End;
         end;
         RouteAsk :=-1;
         Menun:=1;
         MenuScroll := 0;
         ChangeAutoM := False;
      end;

    End;

  end;

  if AutoOn then
  begin
    //if (MapMode > 7)or(MapMode = 0) then
     //  ChangeAutoM := true;

    if ChangeAutoM then
    begin
       case MapMode of
         1,2,6,7 : if Speed < 10 then
                    AutoM[1] :=  Mashtab
                      else
                        AutoM[3] :=  Mashtab;
         3,4,5 : if not (BeforeBegin or AfterEnd or ReflyCurrent) then
                     AutoM[5] :=  Mashtab
                           else
                             AutoM[7] :=  Mashtab;
       end;
    end;

    if (MapMode = 0) or (MapMode > 7) then
       MapMode := 1;
  end;

  MN := ChoosedMenu;
  if MN=-1 then MN :=0;
  

  if (MN+1)*MenuButtonSize[MenuN] > AsphDevice.Size.y - MenuScroll then
      MenuScroll := MenuScroll - ( -AsphDevice.Size.y + MenuScroll
                    + (MN+1)*MenuButtonSize[MenuN]);

  if ChoosedMenu*MenuButtonSize[MenuN] < - MenuScroll then
      MenuScroll := MenuScroll + ( -MenuScroll - MN*MenuButtonSize[MenuN]);

end;

procedure TMainForm.MenuUnscroll;
var Max : Integer;
begin

    if MenuScroll < 0 then
    begin
        MenuScroll := MenuScroll + MenuButtonSize[MenuN];
    end;

    if MenuScroll > 0 then
       MenuScroll := 0;
    

    Max :=  MenuCount[MenuN];
     if (MenuN=5) or (MenuN=6) then
        Max :=  RouteCount-1;

     if (Max+1)*MenuButtonSize[MenuN]>DisplaySize.y then
       begin
         if MenuScroll > -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)  then
            MenuScroll := MenuScroll; //- MenuButtonSize[MenuN];
         if MenuScroll < -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y) then
            MenuScroll := -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)
       end
        else
           MenuScroll := 0;

end;

procedure TMainForm.MyLine(x,y,x2,y2:Double; Dash:Boolean; Col: Cardinal);
var i, l :integer;
    dx, dy :real;
const dashstep = 20;
begin
  if not( (x < 0) and (x2 < 0)) then
  if not( (x > (DisplaySize.X - MenuW)) and (x2 > (DisplaySize.X - MenuW))) then
  if not( (y < 0) and (y2 < 0)) then
  if not( (y > DisplaySize.y) and (y2 > DisplaySize.y)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
   { if x < 0 then
    begin
      if abs(x2-x) > 0 then
        y := ((-x)/(x2-x))*(y2-y)+y
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0;
    end
      else
       if x > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y := (((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X - MenuW);
       end;

    if x2 < 0 then
    begin
      if abs(x2-x) >0 then
        y2 := ((-x)/(x2-x))*(y2-y)+y
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0;
    end
      else
       if x2 > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y2 := (((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X - MenuW);
       end;

    if y < 0 then
    begin
      if abs(y2-y)>0 then
          x := ((-y)/(y2-y))*(x2-x)+x
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0;
    end
      else
       if y > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x := ((DisplaySize.y-y)/(y2-y))*(x2-x)+x
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y;
       end;

   if y2 < 0 then
    begin
      if abs(y2-y) > 0 then
          x2 := ((-y)/(y2-y))*(x2-x)+x
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0;
    end
      else
       if y2 > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x2 := ((DisplaySize.y-y)/(y2-y))*(x2-x)+x
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y;
       end;
  End;  }



   CutLineByFrame(x,y,x2,y2);

   try
    if Dash then
    Begin
       L := trunc(Sqrt (Sqr(x2-x)+sqr(y2-y)));
       if L>0 then
       BEGIN
          dx := (x2 - x)/L;
          dy := (y2 - y)/L;
          for I := 0 to L div dashstep do
          begin

            if Smooth {and Scale < NNN} then
                AsphCanvas.WuLine( Point2(x+i*dashstep*dx, y+i*dashstep*dy),
                Point2(x+(i+0.5)*dashstep*dx,y+(i+0.5)*dashstep*dy ), Col, Col)
            else
              AsphCanvas.Line( Point2(x+i*dashstep*dx, y+i*dashstep*dy),
                Point2(x+(i+0.5)*dashstep*dx,y+(i+0.5)*dashstep*dy ), Col, Col)

          end;

        

       END;



    End else
      Begin


          if Smooth then
          begin
            if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
                AsphCanvas.WuLine( Point2(x, y), Point2(x2, y2), Col, Col)
          end
          else
                AsphCanvas.Line( Point2(x, y), Point2(x2, y2), Col);


      End;

   except
   end;
  End;
end;

procedure TMainForm.N1Click(Sender: TObject);
var CurPosBL : TLatLong;
begin
  CurPosBL := GetWGSCursor;
  NewMarkerForm.Top := Top + Panel1CursorY + Panel1.Top;
  NewMarkerForm.Left := Left + Panel1CursorX + Panel1.Left;
  NewMarkerForm.ShowModal;

  if NewMarkerForm.isOk then
     AddMarker(NewMarkerForm.MarkerName.Text, CurPosBL.lat, CurPosBL.long);
end;

procedure TMainForm.N2Click(Sender: TObject);
var CurPosBL : TLatLong;
begin
  CurPosBL := GetWGSCursor;
  PutBaseHere(CurPosBL.lat, CurPosBL.long);
end;

procedure TMainForm.N3Click(Sender: TObject);
begin
 if AskMark<>-1 then
   DelMarker(AskMark);

  AskMark :=-1;
end;

//---------------------------------------------------------------------------
procedure TMainForm.OnDeviceCreate(Sender: TObject; Param: Pointer;
 var Handled: Boolean);
var
 Success: Boolean;
begin
 // This variable returns "Success" to Device initialization, so if you
 // set it to False, device creation will fail.
 Success:= PBoolean(Param)^;
 try
   AsphImages.RemoveAll();
   AsphMapImages.RemoveAll(); 
   AsphFonts.RemoveAll();

   // This image is used by our bitmap font.
   AsphImages.AddFromASDb('font0.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font3.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font4.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font5.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font6.image', MediaASDb, '', False);


   AsphImages.AddFromASDb('arrow1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow3.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow4.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('az.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('spd.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('spd2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('h.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('lh.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('rh.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('lock.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('unlock.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('flag.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('flag_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('marker1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('marker1_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow1_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('sat.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('dop.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('dot.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('hgtm.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('hgta.image', MediaASDb, '', False);

   AsphImages.AddFromASDb('s_inf.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_gps.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_aux.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_map.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_hgt.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_set.image', MediaASDb, '', False);
   
   AsphImages.AddFromASDb('s_tr1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_tr2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_tr3.image', MediaASDb, '', False);

   
   Font0:= AsphFonts.Insert('Data/media.asdb | font0.xml', 'font0.image');
   Font1:= AsphFonts.Insert('Data/media.asdb | font1.xml', 'font1.image');
   Font2:= AsphFonts.Insert('Data/media.asdb | font2.xml', 'font2.image');
   Font3:= AsphFonts.Insert('Data/media.asdb | font3.xml', 'font3.image');
   Font4:= AsphFonts.Insert('Data/media.asdb | font4.xml', 'font4.image');
   Font5:= AsphFonts.Insert('Data/media.asdb | font5.xml', 'font5.image');
   Font6:= AsphFonts.Insert('Data/media.asdb | font6.xml', 'font6.image');

   AsphFonts[Font0].Kerning:=2;
   AsphFonts[Font1].Kerning:=1.2;
   AsphFonts[Font2].Kerning:=-1.5;
   AsphFonts[Font3].Kerning:= -1.5;
   AsphFonts[Font4].Kerning:= -1.5;
 finally
   Success:= true ;
 end;

 PBoolean(Param)^:= Success;
end;

procedure TMainForm.OpenEmulFile(FileName: String);
var j, Added  : integer;
    i : LongInt;
    s, ext  : string;
    S2 : TStringList;
begin
  if Filename='' then
    exit;

  if Settings.ContainAUX.Checked then
     LoadAUXProt(Settings.AUXProt.Items[Settings.AUXProt.ItemIndex]);
    
  S2 := TStringList.Create;

  try
  FLoadGPS.Show;
  
  FLoadGPS.GPSLoad.Visible := false;
  FLoadGPS.GPSLoad2.Visible := false;
  
  if Settings.DataFilter.Checked then
    FLoadGPS.GPSLoad.Visible := true
      else
        FLoadGPS.GPSLoad2.Visible := true;

  FLoadGPS.MapLoad.Visible := false;
  FLoadGPS.LCount.Visible := false;
  FLoadGPS.Repaint;
  FloadGPS.ProgressBar1.Position := 0;

  Odometr := 0;
  Trip := 0;
  EmulProgress := 0;
  OldEmulProgress := 0;
  ClearGPS;
  EmulBuffer.LoadFromFile(FileName);

  if Settings.AddAll.Checked then
  begin

     for i := length(filename) Downto 1 do
       if filename[i]='.' then
       begin
          s := copy(Filename,1,i-1);
          ext := copy(Filename,i,length(filename)-i+1);
          break;
       end;
    // showmessage(s);
    // showmessage(ext);
     Added := 0;
     for I := 1 to LogsMax do
     begin
        if Fileexists(s+'_'+intTostr(i)+ext) then
        begin
          inc(Added);
          //showmessage(s+'_'+intTostr(i)+ext);
          S2.LoadFromFile(s+'_'+intTostr(i)+ext);
          for J := 0 to S2.Count - 1 do
            EmulBuffer.Add(S2[j]);
        end
          else
            break;
     end;
       if not Settings.LoadingS then
       showmessage(inf[14]+intTostr(Added));
  end;

  FloadGPS.ProgressBar1.Repaint;

  if Settings.DataFilter.Checked then
  BEGIN
    S2.Assign(EmulBuffer);
    EmulBuffer.Clear;
    
    for I := 0 To S2.Count-1 do
    begin
       { if  Pos( 'V', s2[i] ) = 0 then  }
           if ( (Pos ( 'RMC', s2[i]) > 0) or (Pos('GGA', s2[i]) > 0 ) )
            ///   or(Pos ( 'VTG', s2[i]) > 0) 
             or ( (Settings.ContainAUX.Checked) and
              ( (Pos( AUXProt.RName, s2[i] ) > 0) or (Pos( AuxProt.LName, s2[i] ) > 0 )) )
                then
                  EmulBuffer.Add(S2[i]);

      if i mod 50000 = 0 then
       Begin
         FloadGPS.ProgressBar1.Position := trunc(100*i/S2.Count);
         FloadGPS.ProgressBar1.Repaint;
       End;
    end;
  END;

  try
    floadGPS.Hide;
  except
  end;

  except
  end;
  
  S2.Destroy;
  GPSLog.SaveToFile(GPSLogFileName);
  Report.Clear;

  Report.Add(Inf[70]);
  Report.Add(FileName);
  Report.Add('');
  Report.Add(Inf[68]);
end;

//---------------------------------------------------------------------------
procedure TMainForm.TimerEvent(Sender: TObject);
begin

  if Timer.FrameRate>0 then
    LagCount := 1 // Timer.FrameRate
      else
        LagCount := 0;

  AsphDevice.Render(Panel1.Handle, RenderEvent, BackGroundColor);

  Timer.Process();
  
end;

//---------------------------------------------------------------------------
procedure TMainForm.Panel1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  TapOnMenu := false;
  if AllowMouse then
  Begin
    if X > MenuX  then
    begin
       MShiftY0 := y ;
       MShiftY  := y ;
       TapOnMenu := true;
       ScrollMenu := false;
    end
     else
      if MapMode = 0 then
      begin
          MShiftX := x ;
          MShiftY := y ;
      end;
  End;


end;

procedure TMainForm.Panel1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var Mas: Single;
    I,J,k: integer;
begin
  if not AllowMouse  then
  Begin
    Panel1.Cursor := crNone;
  End
    else
      Begin
        if X < Panel1.ClientWidth - MenuW then
          Panel1.Cursor := crCross
          else
             Panel1.Cursor := crArrow;

        if SmartMenu then
        Begin
          SmartN := -1;
          
          if (x > SmartX)and(x < SmartX+30) then
            if (y > SmartKeyY+30)and(y < SmartKeyY+70) then
            Begin
               ChoosedMenu := -1;
               SmartN := 0;

               Panel1.Cursor := crArrow;
            End;

          k := trunc(smartCount/4);
          
          if inSmart then
          Begin
            for I := 1 to 4 do
            for J := 0 to k do
            Begin
                //// SMARTBUTTONS
                if (x > SmartX+(i-1)*50-200)and(x <= SmartX+i*50-200) then
                  if (y > SmartY+j*50)and(y <= SmartY+(j+1)*50) then
                  Begin
                     SmartN := j*4+i;
                     Panel1.Cursor := crArrow;
                  End;
            End;
          End;

        End;

      End;


  if AllowMouse then
  begin
   Panel1CursorX  := x;
   Panel1CursorY  := y;

   ShowCurXY := ssRight in Shift;

   if MapMode = 0 then
   if not(TapOnMenu) then
    if ssLeft in Shift then
        begin
            Mas := {TMashtab[Mashtab]/50} Scale;
            Center.x := Center.x - ( x - MShiftX ) * Mas ;
            Center.y := Center.y + ( y - MShiftY ) * Mas ;
            MShiftX := x ;
            MShiftY := y ;
        end;
  end;

  if TapOnMenu then
    if ssLeft in Shift then
    BEGIN
      if not(ScrollMenu) then
      if abs(y-MShiftY0) > 100 then
      Begin
          ScrollMenu := true;
          MenuScroll0 := MenuScroll;
      End;

      if ScrollMenu then
      begin
        MenuScroll := MenuScroll0 + (y-MShiftY0) ;
        _MenuScroll := MenuScroll;

        //MenuUnscroll;
      end;
    END;

  if x > Panel1.ClientWidth - MenuW then
     Panel2MouseMove(nil,[], x-Panel1.ClientWidth, y)
end;

procedure TMainForm.Panel1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var w: integer;
begin

  if (X > Panel1.ClientWidth-MenuW)or(TapOnMenu) then
  begin

    if not(ScrollMenu) then
       Panel2MouseUp(nil, Button, Shift, X-Panel1.ClientWidth, Y)
         else
             MenuUnscroll;
  end
      else
      BEGIN
        if AllowMouse then
         if MapMode=0 then
         begin

            if Button = mbRight then
            begin
              if borderStyle<>bsNone then
                w:= GetSystemMetrics(SM_CYCAPTION)
              else
                w:=0;
              CheckNearestMarkers(x,y);
              PopupMenu1.Popup(x+left,y+top+w);
            end;
         end;
     // end
       //  else
          //   BEGIN
              // if Button = mbRight then
        if menun>1 then
          Panel2MouseUp(nil, mbRight, Shift, X-Panel1.ClientWidth, Y);

        if SmartMenu then
        Begin
          if inSmart then
             SmartMenuKeyCommand(5)
              else
               if ChoosedMenu = -1 then
                 MenuKeyCommand(5);
        End;

      END;

  ScrollMenu := false;
end;

procedure TMainForm.Panel1Resize(Sender: TObject);
begin
  MainForm.OnResize(nil);
end;

procedure TMainForm.Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var I, Max : Integer;
begin
  if AllowMouse then
  BEGIN
    Max :=  MenuCount[MenuN];
    if (MenuN=5) or (MenuN=6) then
      Max :=  RouteCount-1;

    for I := 0 to Max do
      if Y > i*MenuButtonSize[MenuN]+_MenuScroll then
       if Y < (i+1)*MenuButtonSize[MenuN]+_MenuScroll then
       begin
         ChoosedMenu :=i;
         if (MenuN=5) or (MenuN=6) then
           RouteAsk :=  ChoosedMenu;
         break;
       end;

    if (MenuN=1) then
    Begin

       if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
         ChoosedMenu := MenuCount[MenuN]-1;
       if AutoOn then
       Begin
         if ChangeAutoM then
            if ChoosedMenu<>4 then
                ChangeAutoM := false;

         if (MapMode>7) or (MapMode=0) then
           ChangeAutoM := true;
       End;
    End;
  END;
end;

procedure TMainForm.Panel2MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if AllowMouse then
  BEGIN
    Panel2MouseMove(sender,Shift,x,y);

    if Button = mbLeft then
      MenuKeyCommand(5);

    if Button = mbRight then
      MenuKeyCommand(6);
  END;
end;

procedure TMainForm.ProcessEvent(Sender: TObject);
var ScrollSpd : integer;
begin
 Inc(AsphTicks);
 // Caption := IntToStr(AsphTicks);
 if AsphTicks > 3141 then
 begin
   SaveLogFile;
   AsphTicks := 0;
 end;


 case inSmart of
   true:
      Begin
        if SmartX < 200 then
            SmartX := SmartX + LagCount*15;

        if SmartX > 200 then
            SmartX := 200;
      End;


   false:
       Begin
        if SmartX > 0 then
            SmartX :=  SmartX - LagCount*25;

        if SmartX < 0 then
            SmartX := 0;
      End;
 end;



   if _MenuScroll <> MenuScroll then
   Begin
      ScrollSpd := 5;
       if Abs(_MenuScroll - MenuScroll) > DisplaySize.y*2 then
         ScrollSpd := 150
         else
         if Abs(_MenuScroll - MenuScroll) > DisplaySize.y then
           ScrollSpd := 50
            else
            if Abs(_MenuScroll - MenuScroll) > DisplaySize.y/2 then
               ScrollSpd := 15;

     

      if _MenuScroll < MenuScroll then
      Begin
         _MenuScroll := _MenuScroll+LagCount*2*ScrollSpd;
         if _MenuScroll > MenuScroll then
             _MenuScroll := MenuScroll
      End
       else
         if _MenuScroll>MenuScroll then
       Begin
         _MenuScroll := _MenuScroll-LagCount*2*ScrollSpd;
         if _MenuScroll < MenuScroll then
             _MenuScroll := MenuScroll
       End
   End;

  //// ОПРОС ДЖОЙСТИКА
  
 GPSTimerEvent;
 if AllowJoystick then
     AskJoysticKey;
end;

procedure TMainForm.PutBaseHere(B, L:Double);
var xx, yy : Double;
begin
  Base[2].x := B;
  Base[2].y := L;
                                                   /// 11-05
  Settings.BaseB.Text := DegToDMS(B, true, 4, false);
  Settings.BaseL.Text := DegToDMS(L, false, 4, false);

  if UTM then
     GeoToUTM(WGS,Base[2].x,Base[2].y,South,yy,xx, Myzone, WaitForZone)
       else
          WGSToSK(Base[2].x,Base[2].y,0,xx,yy, MyZone, WaitForZone);
  Base[1].x := xx;
  Base[1].y := yy;
end;

//---------------------------------------------------------------------------
procedure TMainForm.ReComputeMaps(WFZ: Boolean);
var i,j :integer;
    xx, yy:Double;
begin
   WaitForZone := WFZ;

   for I := 0 to Length(MapList)- 1 do
      for j := 1 to 4 do
      Begin
         if UTM then
            GeoToUTM(WGS,MapList[i].Gx[j],MapList[i].Gy[j],South, yy,xx, Myzone, WaitForZone)
               else
                   WGSToSK(MapList[i].Gx[j],MapList[i].Gy[j],0, xx,yy, MyZone, WaitForZone);

         MapList[i].x[j] := xx;
         MapList[i].y[j] := yy;
         WaitForZone := false;
      End;
end;

procedure TMainForm.ReComputeRoutes(WFZ:Boolean);
var i:integer;
    xx,yy : Double;
    Str: String;
begin
  ReCalcWay := true;
  
  LoadedRoutesList.ListBox1.Clear;
  if  RouteCount > 0 then
  Begin
    LoadedRoutesList.StringGrid1.RowCount :=RouteCount +1;
  End
   else
      Begin
        LoadedRoutesList.StringGrid1.RowCount :=2;
        for I := 0 to LoadedRoutesList.StringGrid1.ColCount-1 do
          LoadedRoutesList.StringGrid1.Cells[I,1] := '';
      End;

  for I := 0 to RouteCount - 1 do
  begin
     if i=0 then
      WaitForZone := WFZ
       else
           WaitForZone := false;
           
     LoadedRoutesList.ListBox1.Items.Add(Route[i].Name);
                                                                             ///11-05
     LoadedRoutesList.StringGrid1.Cells[0,I+1] := Route[I].Name;
     LoadedRoutesList.StringGrid1.Cells[1,I+1] := DegToDMS(Route[I].Gx1,true,4,false);
     LoadedRoutesList.StringGrid1.Cells[2,I+1] := DegToDMS(Route[I].Gy1,false,4,false);
     LoadedRoutesList.StringGrid1.Cells[3,I+1] := DegToDMS(Route[I].Gx2,true,4,false);
     LoadedRoutesList.StringGrid1.Cells[4,I+1] := DegToDMS(Route[I].Gy2,false,4,false);
     case Route[i].Status of
                 0 : Str := inf[38];
                 1 : Str := inf[39];
                 2 : Str := inf[40];
                 3 : Str := inf[41];
     end;
     LoadedRoutesList.StringGrid1.Cells[5,I+1] := Str;
     { if Route[i].Geo = false then
      Begin
        if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,Route[i].x1, Route[i].y1,Settings.RSouth.Checked, xx, yy)
          else
           SKToWGS(Route[i].y1, Route[i].x1,0, xx, yy);
        Route[i].Gx1 := xx;
        Route[i].Gy1 := yy;

        if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,Route[i].x2, Route[i].y2,Settings.RSouth.Checked, xx, yy)
          else
            SKToWGS(Route[i].y2, Route[i].x2,0, xx, yy);
        Route[i].Gx2 := xx;
        Route[i].Gy2 := yy;

        Route[i].Geo := true;
      End;   }

      if Route[i].Geo then
      Begin
        if UTM then
            GeoToUTM(WGS,Route[i].gx1,Route[i].gy1,South,yy,xx, Myzone, WaitForZone)
             else
               WGSToSK(Route[i].gx1, Route[i].gy1,0, xx, yy, MyZone, WaitForZone);
        Route[i].x1 := xx;
        Route[i].y1 := yy;

        if UTM then
            GeoToUTM(WGS,Route[i].gx2,Route[i].gy2,South,yy, xx, Myzone, WaitForZone)
             else
                WGSToSK(Route[i].gx2, Route[i].gy2,0, xx, yy, MyZone, WaitForZone);
        Route[i].x2 := xx;
        Route[i].y2 := yy;
      End;

  end;

  if Frame then
  Begin
  { if FrameGeo = false then
   for I := 0 to FrameCount - 1 do
   begin
     if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,FramePoints[i,1].x, FramePoints[i,1].y,Settings.RSouth.Checked, xx, yy)
            else
              SKToWGS(FramePoints[i,1].y, FramePoints[i,1].x,0, xx, yy);
      FramePoints[i,2].x := xx;
      FramePoints[i,2].y := yy;
      FrameGeo := True;
   end;   }
   
   if FrameGeo then
   for I := 0 to FrameCount - 1 do
   begin
     if UTM then
        GeoToUTM(WGS,FramePoints[i,2].x,FramePoints[i,2].y,South,yy,xx,Myzone, WaitForZone)
          else
            WGSToSK(FramePoints[i,2].x, FramePoints[i,2].y,0, xx, yy, MyZone, WaitForZone);
      FramePoints[i,1].x := xx;
      FramePoints[i,1].y := yy;
   end;
  End;

  CurrentRouteAngle := GetRouteAngle(CurrentRoute);
  CurToNextDist;

  TPCount :=0;
  LocalR1 := -1;
end;

procedure TMainForm.ReComputeTracks(WFZ: Boolean);
var i,j:Integer;
    xx, yy :Double;
begin
    WaitForZone := WFZ;

   if SizeTrackRecord > 0 then
      for i := 0 to SizeTrackRecord - 1 do
         if (TrackRecord[i].mZone <> MyZone)
             or (UTM<>TrackRecord[i].mUTM) then
          Begin      // / zczxc

            if UTM then
              GeoToUTM(WGS,TrackRecord[i].Lat,TrackRecord[i].Long,South,yy,xx,Myzone, WaitForZone)
                else
                  WGSToSK(TrackRecord[i].Lat, TrackRecord[i].Long,0, xx, yy,MyZone, WaitForZone);

            TrackRecord[i].x := xx;
            TrackRecord[i].y := yy;
            TrackRecord[i].mZone := MyZone;
            TrackRecord[i].mUTM := UTM;
            WaitForZone := false;
          End;

   if Base[2].x<>0 then
   Begin
     if UTM then
      GeoToUTM(WGS,Base[2].x,Base[2].y,South, yy,xx, Myzone, WaitForZone)
        else
          WGSToSK(Base[2].x,Base[2].y,0, xx,yy, MyZone, WaitForZone);
      Base[1].x := xx;
      Base[1].y := yy;
   End;

   if ShowMaps then
     RecomputeMaps(False);

   if MarkerCount>0 then
     RefreshMarkerList;
end;

procedure TMainForm.ReDrawTrack;
var w, h   : Integer ;
  Mas      : double ;
  Cx, cy   : double ;
  dx, dy   : double ;
  dx2, dy2 : double ;
  Px, Py   : double ;
  i        : Integer ;
  x, y     : Integer ;
  _x,_y    : Integer;
  csize    : Integer;
  Fi, Fi2, Fi3  : double ;
  OldFlag  : Boolean ;
  NeedCrack : Boolean;
  Str: string;
begin

  if SizeTrackRecord=0 then
  Begin

    

    if (Center.x = 0) and (Center.y = 0) then
    Begin
      if ((Base[1].x<>0) and (Base[1].y<>0)) then
      Begin
         RecomputeTracks(WaitForZone);
         RecomputeMaps(false);
         RecomputeRoutes(false);
         Center.x  := Base[1].x;
         Center.y  := Base[1].y;
      End
      Else
      if (RouteCount > 0) then
      Begin
        RecomputeRoutes(WaitForZone);
        RecomputeMaps(false);
        Center.x := Route[0].x1;
        Center.y := Route[0].y1;
      End
       Else
      if (Length(MapList)> 0) then
      Begin
        RecomputeMaps(WaitForZone);
        Center.x := MapList[0].x[3];
        Center.y := MapList[0].y[3];
      End;

    End
      else
        Begin
            if ShowMaps then
              ReDrawMaps;

            if DrawLines then
             ReDrawLines(DashLines);

            ReDrawRoutes;
            RedrawBase;
            RedrawMarkers;
            ReDrawTurnPoints;
        End;
  End;


  if SizeTrackRecord>1 then
  Begin
   // if Not DrawFlag then exit ;

      w := (DisplaySize.X - MenuW);
      h := DisplaySize.y;

      Fi3 := 0;
      Mas := Scale;

      if (SizeTrackRecord > 0) then
      begin
          cx := TrackRecord [SizeTrackRecord -1].x ;
          cy := TrackRecord [SizeTrackRecord -1].y ;
          px := cx;
          py := cy;

      end;

      if MapMode > 0 then
      begin
          Center.x := Cx ;
          Center.y := Cy ;
      end
        else
          begin
            Cx := Center.x ;
            Cy := Center.y ;
          end ;

      px := (Cx - px) / Mas ;
      py := (Cy - py) / Mas ;
      px := round (w div 2 - px);
      py := h - round (h div 2 - py) + VYShift;

      x := trunc(px);
      y := trunc(py);

      i := SizeTrackRecord -1 ;
      dx := TrackRecord[i].x - TrackRecord [i-1].x ;
      dy := TrackRecord[i].y - TrackRecord [i-1].y ;

      if CountAz then
      Begin
        if (dx=0)and(dy=0) then
          fi := 0
           else
             fi := ArcTan2(dy, dx) - pi/2;

        if SmoothAzimuth then
          AxelAzimuth(-fi)
           else
           Begin
            Azimuth := - fi;
            if Azimuth<0 then
               Azimuth := Azimuth + 2*pi
                 else
            if Azimuth> 2*pi then
               Azimuth := Azimuth - 2*pi
           End;
      End
        else
          BEGIN
             if SmoothAzimuth then
               AxelAzimuth(Az)
                else
                  Azimuth := Az;


          END;

      OldFlag := false;

      if MapMode=5 then
        if abs(CurrentRouteAngle-Azimuth) > pi/2 then
                if CurrentRouteAngle > Azimuth then
                  CurrentRouteAngle := CurrentRouteAngle - pi
                      else
                          CurrentRouteAngle := CurrentRouteAngle + pi;

      if ShowMaps then
         ReDrawMaps;

      if DrawLines then
         ReDrawLines(DashLines);


      if MapModeDoRotate[MapMode]=false then     /// НЕ ВРАЩАЮ!
      Begin
          VYShift := 0;
          if not HideTrack then
          for i := SizeTrackRecord -1 downto 0 do
          begin
              if i < SizeTrackRecord - MaxDotsVisible then
                   break;

              if i < SizeTrackRecord -1 then
                   NeedCrack :=  TrackRecord[i+1].Crack;
              if not ShowCracks then
                   NeedCrack := false;

              _x := x;
              _y := y;

              dx := (Cx - TrackRecord[i].x) / Mas ;
              dy := (Cy - TrackRecord[i].y) / Mas ;

              x := round (w div 2 - dx);
              y := h - round (h div 2 - dy);


              if OldFlag <> TrackRecord[i].Flag then
              begin
                 //
              end
                 else
                  if NeedCrack = false then
                    FatLine(_x, _y, x, y, 0+DopFat, false, TrackColor)
                      else
                      begin
                        CrackDot( x, y, TrackColor);
                        CrackDot( _x, _y, TrackColor);
                        FatLine(_x, _y, x, y, 0, true, TrackColor)
                      end;

              OldFlag :=  TrackRecord[i].Flag;
          end;

          ReDrawRoutes;
          RedrawBase;
          RedrawMarkers;
          ReDrawTurnPoints;
          DrawArrowToNearest;

          csize := 32;
          if BigCur then
          begin
            csize := 64;
            AsphCanvas.UseImagePx(AsphImages.Image['arrow1_big.image'], pxBounds4(0, 0, 64, 64));
          end
            else
               AsphCanvas.UseImagePx(AsphImages.Image['arrow1.image'], pxBounds4(0, 0, 32, 32));

          if MapMode = 0 then
              AsphCanvas.TexMap(pRotate4c(
                      Point2(px, py),
                      Point2(CSize, CSize),
                      Azimuth),
                      cColor4(CurColor))
          else
              AsphCanvas.TexMap(pRotate4c(
                      Point2(w/2, h/2),
                      Point2(CSize, CSize),
                      Azimuth),
                      cColor4(CurColor));

      End
        Else             /////// ВРАЩАЮ!
        Begin

            VYShift := trunc (h* 0.3);

            fi3 := 0;

            if MapMode= 5 then
            begin
              fi3 := - CurrentRouteAngle;
              fi :=  fi3;
            end
             else
              fi := -Azimuth;

            cx := TrackRecord[SizeTrackRecord -1].x ;
            cy := TrackRecord[SizeTrackRecord -1].y ;

            Center.x := Cx ;
            Center.y := Cy ;
            if not HideTrack then
            for i := SizeTrackRecord -1 downto 0 do
            begin
               if i < SizeTrackRecord - MaxDotsVisible then
                   break;

               if i < SizeTrackRecord -1 then
                   NeedCrack := TrackRecord[i+1].Crack;

               if not ShowCracks then
                   NeedCrack := false;

               _x := x;
               _y := y;

               dx := (Cx - TrackRecord [i].x) ;
               dy := (Cy - TrackRecord [i].y) ;

               dx2 := dx * Cos (fi) + dy * sin (fi);
               dy2 :=-dx * Sin (fi) + Dy * Cos (fi);

               dx2 := dx2 / Mas ;
               dy2 := dy2 / Mas ;

               x := round (w div 2 - dx2 );
               y := h -  round (h div 2 - dy2 ) + VYShift;

               if OldFlag <> TrackRecord[i].Flag then
               begin
                 // PaintBox1 . Canvas . MoveTo ( x, y );
               end
                  else
                   if NeedCrack = false then
                    FatLine(_x, _y, x, y, 0 + DopFat, false, TrackColor)
                      else
                      begin
                        CrackDot( x, y, TrackColor);
                        CrackDot( _x, _y, TrackColor);
                        FatLine(_x, _y, x, y, 0, true, TrackColor)
                      end;

               OldFlag := TrackRecord[i].Flag;
            end;

            ReDrawRoutes;
            RedrawBase;
            RedrawMarkers;
            ReDrawTurnPoints;
            DrawArrowToNearest;

            csize := 32;
            if BigCur then
            begin
              csize := 64;
              AsphCanvas.UseImagePx(AsphImages.Image['arrow1_big.image'], pxBounds4(0, 0, 64, 64));
            end
              else
                AsphCanvas.UseImagePx(AsphImages.Image['arrow1.image'], pxBounds4(0, 0, 32, 32));

            if MapMode= 5 then
               fi := -fi3 - Azimuth
                 else
                  fi := 0;
                 

            AsphCanvas.TexMap(pRotate4c(
                      Point2(px, py),
                      Point2(CSize, CSize),
                      -fi),
                      cColor4(CurColor));

        End;

   if Follow and (CurrentRoute <> -1) then
      FollowCurrentRoute(CurrentRoute,TrackRecord [SizeTrackRecord -1].Time,
                          TrackRecord [SizeTrackRecord -1].x, TrackRecord [SizeTrackRecord -1].y);
  End;

end;

procedure TMainForm.RefreshMarkerList;
var i:integer;
    tmpI :real;
begin
 Settings.MarkerBox.Clear;
 for I := 0 to MarkerCount - 1 do
   begin
     if Markers[I].Caption ='' then
       Markers[I].Caption := '*';

     if UTM then
        GeoToUTM(WGS,Markers[i].B, Markers[i].L,South,Markers[i].x, Markers[i].y,MyZone,False)
       else
         WGSToSK(Markers[i].B, Markers[i].L,0,Markers[i].x, Markers[i].y, MyZone, False);

     Settings.MarkerBox.Items.Add(Markers[I].Caption);

   end;

   Settings.DelMarker.Enabled :=  Settings.markerBox.Items.Count > 0;
   Settings.EditMarker.Enabled := Settings.markerBox.Items.Count > 0;
end;

procedure TMainForm.ReLoadRoutes(FileName: String);
 var
     F : TStringList;
     I, J, I1, I2 : Integer;
     s1, s2 : String ;
     found, isBegin : Boolean;
     _X,_Y,_Z : double;
begin
   F := TStringList.Create;
   RouteCount := 0;

   CurrentRoute :=-1;
   NextRoute := -1;
   DistToNext:=0;
   WorstDist := false;
   FrameCount := 0;
   Frame := false;
   FrameGeo := false;
   BackStep := false;
   BadDist := false;
   ReFlyCurrent := false;
   WorstDist := False;
   LocalR1 := -1;
   LocalR2 := -1;
   TPCount := 0;

   if filename<>'' then
   try
     F.LoadFromFile(FileName);

     J :=0;
     for I := RoutesTabStart-1 to F.Count - 1 do
     if F[i]<>'' then
     begin

        if Settings.ReverseRoutes.Checked then
           i2 := (F.Count - 1) - (i - (RoutesTabStart-1))
          else
             i2 := i;

        isBegin := false;
        case LoadRData.RoutesBE.ItemIndex of
           0: begin
                s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                J := I;
                RouteCount := J+1;
              end;
           1: begin
                 s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                 J := Trunc(I/2);
                 RouteCount := J+1;
                 if I mod 2 = 0 then
                   isBegin := true;
              end;
           2: BEGIN
                s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                isBegin := (Copy(s1,length(s1),1)='a') or (Copy(s1,length(s1),1)='A');
                s1 := Copy(s1,1,length(s1)-1);

                if RouteCount=0 then
                begin
                  J :=0;
                  RouteCount:=1;

                end else
                  begin    /// ИЩУ ПО ИМЕНИ
                    found := false;
                    for J := 0 to RouteCount-1 do
                      if Route[J].Name = s1 then
                      begin
                        found := true;
                        break;
                      end;
                     if not found then
                     begin
                       J := RouteCount;
                       inc(RouteCount);
                     end;
                   end;
              END;
        end;

        Route[J].Name := s1;
        Route[J].Status := 0;

        Route[J].StartTime :='';
        Route[J].EndTime :='';
        Route[J].Rlabel :='';

        Route[J].Geo := (RoutesDatum = WGS) and (isRoutesDatum) and (RoutesCS = 0); //Settings.SK.ItemIndex=0;

        if LoadRData.RoutesBE.ItemIndex = 0 then
        begin

            // начало и конец
            if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

            Route[J].Gx1 := _X;
            Route[J].Gy1 := _Y;
            if RoutesZTab<>-1 then
               Route[J].Gz1 := StrToFloat(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                  else
                    Route[J].Gz1 := 0;

            if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesX2Tab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesY2Tab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesX2Tab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesY2Tab,1, LoadRData.RSpacer.itemIndex));
                end;

            Route[J].Gx1 := _X;
            Route[J].Gy1 := _Y;
            if RoutesZTab<>-1 then
              Route[J].Gz2 := StrToFloat2(GetCols(F[I2],RoutesZ2Tab,1, LoadRData.RSpacer.itemIndex))
                 else
                    Route[J].Gz2 := 0;

        end
          else
            if isBegin then
            begin
                // начало

               if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

                Route[J].Gx1 := _X;
                Route[J].Gy1 := _Y;
                if RoutesZTab<>-1 then
                   Route[J].Gz1 := StrToFloat2(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                     else
                       Route[J].Gz1 := 0;
            end
              else
              begin
                // конец
                if ((isRoutesDatum)and(RoutesCS=0))
                or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
                begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
                end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

                Route[J].Gx2 := _X;
                Route[J].Gy2 := _Y;
                if RoutesZTab<>-1 then
                  Route[J].Gz2 := StrToFloat2(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                    else
                      Route[J].Gz2 := 0;

              end;

     end;

     for J := 0 to RouteCount-1 do
      if not Route[J].Geo then
      Begin
         Route[J].Geo := True;
         // ПЕРЕВОД В WGS

          if isRoutesDatum = false then
          begin
            /// RouteCS - CК

            if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                CoordinateSystemToDatum(RoutesCS,
                                    Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                                    Route[J].Gx1, Route[J].Gy1, Route[J].Gz1)
                else
                   CoordinateSystemToDatum(RoutesCS,
                                      Route[J].Gy1, Route[J].Gx1, Route[J].Gz1,
                                      Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);


            Geo1ForceToGeo2(Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);




            if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                CoordinateSystemToDatum(RoutesCS,
                                    Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                                    Route[J].Gx2, Route[J].Gy2, Route[J].Gz2)
                else
                   CoordinateSystemToDatum(RoutesCS,
                                      Route[J].Gy2, Route[J].Gx2, Route[J].Gz2,
                                      Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);

            Geo1ForceToGeo2(Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);


          end
            else
            begin
              /// RouteCS - тип проекции
              case RoutesCS of
                 0: begin
                   // B L
                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;
                 end;

                 1:   begin
                   // XYZ
                   ECEFToGeo(RoutesDatum,  Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                             Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                   ECEFToGeo(RoutesDatum,  Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                             Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
                 2:  begin
                   // GK
                   GaussKrugerToGeo(Route[J].Gy1, Route[J].Gx1,
                                    Route[J].Gx1, Route[J].Gy1 );
                   GaussKrugerToGeo(Route[J].Gy2, Route[J].Gx2,
                                    Route[J].Gx2, Route[J].Gy2 );

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
                 3,4:  begin
                   // UTM
                   UTMToGeo(RoutesDatum, Route[J].Gy1, Route[J].Gx1, RoutesCS = 4,
                                    Route[J].Gx1, Route[J].Gy1 );
                   UTMToGeo(RoutesDatum, Route[J].Gy2, Route[J].Gy2, RoutesCS = 4,
                                    Route[J].Gx2, Route[J].Gy2 );

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
              end;
            end;
      End;
    // FrameFile :='';

     Insert ('_f', Filename, Length(filename)-3);
     if Fileexists(Filename) then
     begin
         Frame := true;
         FrameFile := Filename;
         F.LoadFromFile(FileName);
         Frame := True;
         FrameGeo := (RoutesDatum = WGS) and (isRoutesDatum) and (RoutesCS = 0);


         j := 2;

         for I := 0 to F.Count - 1 do
         Begin
              if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex));
                end;


             FramePoints[I, j].x := _X;// StrToFloat(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex));
             FramePoints[I, j].y := _Y;//StrToFloat(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex));
             if RoutesZTab<>-1 then
                FramePoints[I, j].z := StrToFloat2(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex))
                  else
                    FramePoints[I, j].z := 0;

             inc(FrameCount);
         End;

         if FrameCount>1  then
         begin
            inc(FrameCount);
            FramePoints[FrameCount-1, j].x := FramePoints[0, j].x;
            FramePoints[FrameCount-1, j].y := FramePoints[0, j].y;
         end;


         if not FrameGeo then
            for J := 0 to FrameCount - 1 do
            Begin
               if isRoutesDatum = false then
               begin

                 if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                      CoordinateSystemToDatum(RoutesCS,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z)
                      else
                         CoordinateSystemToDatum(RoutesCS,
                                      FramePoints[J, 2].y, FramePoints[J, 2].x, FramePoints[J, 2].z,
                                      FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                 Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                //  ShowMessage(FloaTToStr(FramePoints[J, 2].x)+'  '+ FloaTToStr(FramePoints[J, 2].y))
               end
                else
                BEGIN
                   case RoutesCS of
                   0: begin
                   // B L
                     if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);


                   end;

                   1: begin
                   // XYZ
                     ECEFToGeo(RoutesDatum,  FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                               FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                    if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);


                   end;
                   2:  begin
                   // GK
                     GaussKrugerToGeo(FramePoints[J, 2].y, FramePoints[J, 2].x,
                                      FramePoints[J, 2].x, FramePoints[J, 2].y);

                     if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                     // ShowMessage(FloaTToStr(FramePoints[J, 2].x)+'  '+ FloaTToStr(FramePoints[J, 2].y))
                   end;
                   3,4:  begin
                   // UTM
                   UTMToGeo(RoutesDatum, FramePoints[J, 2].y, FramePoints[J, 2].x, RoutesCS = 4,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y );


                    if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);



                   end;
                   end;
                END;
            End;
         FrameGeo := True;
     end;

     ///---
   {

            else
            begin
              /// RouteCS - тип проекции

            end;
                  }
     ///---

     ReComputeRoutes(false);
     SetCurrentRoute(0);
 except
   MessageDlg(inf[15],mtError, [mbOk],0);
 end;  
 F.Destroy;

end;

procedure TMainForm.RenderEvent(Sender: TObject);
begin

  if not SmoothScale then
  Begin
     Scale  := TMashtab[Mashtab]/100;
     _Scale := Scale;
  End
     else
        AxelScale;

  ReDrawTrack;

  DrawScaleAndNord(Scale);

  ///if SmoothAzimuth then
     AxelHgts;

  RenderMenus;
end;


procedure TMainForm.RenderMenus;

  procedure DrawMenuButton(n:integer; btnchoosed, btncompound:boolean; btnDopColor: ShortInt);
  var A:Integer;
      Col4: TColor4;
  begin
     A:=190;
     if btnchoosed then
     begin
        A:=255;
        Col4 := cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
              GetRValue(Dop1Color),A);

        AsphCanvas.FillRect(RECT(MenuX+ 0, n*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll),
              AsphDevice.Size.x, (n+1)*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll)),
              Col4);
     end;

     case btnDopColor of
         0 : Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
         1 : Col4 := cRGB4(60,165,40,205);
         2 : Col4 := cRGB4(80,185,50,225);
         3 : Col4 := cRGB4(230+trunc(15*Sin(AsphTicks*0.1)),180,0,255);
         4 : Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
         5 : Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
         6 : Col4 := cRGB4(GetBValue(ChoosedColor),GetGValue(ChoosedColor),GetRValue(ChoosedColor),A);
         7 : Col4 := cRGB4(80,185,50,225);
         8 : Col4 := cRGB4(185,105,50,225);
         9 : Col4 := cRGB4(230,50,50,190);
     end;

     if btnCompound then
     begin
          AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    MenuX + 58, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);

          AsphCanvas.FillRect(RECT( MenuX+ 60, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);
     end
        else
          AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);
  end;

  procedure DrawHgtButton(n:integer; btnchoosed: Boolean; HgtCombination: ShortInt);
  var A:Integer;
      Col1, Col2, Col3, Col4: TColor4;
  begin

     A:=190;
     if btnchoosed then
     begin
        A:=255;
        Col4 := cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
              GetRValue(Dop1Color),A);

        AsphCanvas.FillRect(RECT(MenuX+ 0, n*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll),
              AsphDevice.Size.x, (n+1)*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll)),
              Col4);
     end;

     Col1 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);

     case HgtCombination of
         0 : begin //// NO AUX

             end;

         1 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col2 := Col4;
               Col3 := Col4;
             end;

         2 : begin  //// BAD R HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col2 := Col4;
               Col3 := cRGB4(80,185,50,225);
             end;

         3 : begin  //// BAD L HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := cRGB4(80,185,50,225);
             end;
         4 : begin  //// BAD ALL
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := Col4;
               Col1 := Col4;
             end;


       //// IF NO R-Altimeter DATA

         10 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
               Col3 := Col4;
             end;

         11 : begin  //// BAD L HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
             end;

        //// IF NO L-Altimeter DATA

         20 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
               Col2 := Col4;
             end;

         21 : begin  //// BAD R HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col2 := Col4;
               Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
             end;

     end;


     AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    MenuX + 58, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);

     AsphCanvas.FillRect(RECT( MenuX+ 60, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*1/3) - 1 + trunc(_MenuScroll)),
                    Col1);

     AsphCanvas.FillRect(RECT( MenuX+ 60, trunc(n*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]/3) + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*2/3) - 1 + trunc(_MenuScroll)),
                    Col2);

     AsphCanvas.FillRect(RECT( MenuX+ 60, trunc(n*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*2/3) + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]) - 1 + trunc(_MenuScroll)),
                    Col3);

  end;

var I, J :Integer;
    B    :Byte;
    Str, Str2  :String;
    Max  : Integer;
    Col : TColor2;
begin

 if ShowMaps then
   AsphCanvas.FillRect(RECT( MenuX, 0,
                    AsphDevice.Size.x, AsphDevice.Size.Y),
                     crgb4(GetBValue(BackGroundColor),GetGValue(BackGroundColor),GetRValue(BackGroundColor),190));
 case SmartMenu of
   true:
    if ChoosedMenu < -1 then
      ChoosedMenu := 0;
   false:
    if ChoosedMenu < 0 then
      ChoosedMenu := 0;
 end;
 

 Max :=  MenuCount[MenuN];
 if (MenuN=5) or (MenuN=6) then
    Max :=  RouteCount-1;

 if ChoosedMenu > Max then
    ChoosedMenu := Max;

 case MenuN of
    1: ////  Основное меню
    Begin
      for I := 0 to MenuCount[MenuN] do
      begin
          if not((AllowAuto=false)and(i = MenuCount[MenuN])) then  /// КНОПКИ "АВТО" МОЖЕТ НЕ БЫТЬ
             DrawMenuButton(i, i=ChoosedMenu , i<3 , 0)
             else
                if ChoosedMenu = MenuCount[MenuN] then
                   ChoosedMenu := MenuCount[MenuN]-1;

      //    if not((HgtID = 3)and(i = 1)) then   //// СПЕЦИАЛЬНЫЙ ДАТЧИК ВСЕХ ВЫСОТ
     //       DrawMenuButton(i, i=ChoosedMenu , i<3 , 0)      ;
             { else
                if ChoosedMenu = MenuCount[MenuN] then
                   ChoosedMenu := MenuCount[MenuN]-1;  }
                       // zxzx

          case I of
             0:  /// SPEED
             Begin

               if Speed> 1000 then
                  Speed :=-1;

               B:=1;
               J := -45;
               if Speed >= MaxSpd then
               begin
                  J := 50 +trunc(10*Sin(AsphTicks*0.1));
                  B := 4;
               end
                 else
                  if Speed >= MaxSpd-10 then
                  begin
                     J := 20;
                     B := 3;
                  end
                    else
                      if Speed >= MaxSpd-30 then
                      begin
                        J := 0;
                        B := 2;
                      end
                        else
                         if Speed >= 30 then
                         begin
                           J := -20;
                           B := 2;
                         end;

               DrawMenuButton(i, i=ChoosedMenu , i<3 , B);

               AsphCanvas.UseImagePx(AsphImages.Image['spd.image'], pxBounds4(0, 0, 64, 32));

               AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN]
                                  + 25 + trunc(_MenuScroll)), Point2(50, 25),
                                  0), clWhite4);

               AsphCanvas.UseImagePx(AsphImages.Image['spd2.image'], pxBounds4(0, 0, 16, 32));

               AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN]
                                  + 45 + trunc(_MenuScroll)), Point2(16, 32),
                                  j*pi/180), clWhite4);

               if BigText then
               Begin
                   AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    'V: ',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    if speed>=0 then
                      Str :=  IntToStr(trunc(Speed))
                       else
                        Str := '-';

                  J:= MenuX+60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               end
                else
                Begin
                  AsphFonts[Font2].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    inf[16],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if speed>=0 then
                    Str :=  IntToStr(trunc(Speed))+ inf[17]
                      else
                        Str := '-'+inf[17];

                  J:= MenuX+60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;


             End;
             2:  /// Azimuth
             Begin

               if BigText then
               Begin
                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    'Az: ', cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (Speed<0) then
                      Azimuth :=0;
                                 // zxzx
                  if Azimuth < 0 then
                      Azimuth := Azimuth + 2*pi;

                  Str :=  IntToStr(trunc(Azimuth*180/pi))+#176;

                  if (Speed<0) then
                      Str := '-';

                  J:= MenuX+60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);     // xzc
               End
                 else
                 Begin
                    AsphFonts[Font2].TextOut(
                      Point2(MenuX+60 + 5.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                      inf[18],                               // IntToStr(Timer.FrameRate);
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    if (Speed<0) then
                      Azimuth :=0;
                                 // zxzx
                    if Azimuth < 0 then
                      Azimuth := Azimuth + 2*pi;

                    Str :=  IntToStr(trunc(Azimuth*180/pi));

                    if (Speed<0) then
                      Str := '-';
                      J:= MenuX+60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                    AsphFonts[Font1].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      J:= MenuX + 32 + MenuW div 2  + Trunc((AsphFonts[Font1].TextWidth(Str)/2));

                    if str<>'-' then
                    AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        'o',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                 End;

                    AsphCanvas.UseImagePx(AsphImages.Image['az.image'], pxBounds4(0, 0, 64, 64));

                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                   azimuth), clWhite4);

             End;
             1:  ///// Altitude
             Begin

               

               if HgtID<>3 then
               BEGIN

                B := 0;
                case HGTID of
                  0: begin
                     Str := CurHgt;
                  end;

                  1: begin
                     Str := CurHgt2;
                     B := 2;
                     if _HAGR > 1.1* MaxHGTR then   //// 10% запас
                        B := 4
                          else
                            if (_HAGR > MaxHgtR) then
                               B := 3;

                     if _HAGR < 0.9* MinHGTR then   //// 10% запас
                        B := 4
                          else
                            if (_HAGR < MinHgtR) then
                               B := 3;
                  end;

                  2: begin
                     Str := CurHgt3;
                     B := 2;
                     if _HAGL > 1.1* MaxHGTL then  //// 10% запас
                        B := 4
                          else
                            if (_HAGL > MaxHgtL) then
                               B := 3;
                     if _HAGL < 0.9* MinHGTL  then   //// 10% запас
                        B := 4
                          else
                            if (_HAGL < MinHgtL) then
                               B := 3;
                  end;

                end;

                if Str='-' then
                  B :=0;

                if B>0 then
                  DrawMenuButton(i, i=ChoosedMenu , i<3 , B);

                if BigText then
                Begin
                  case HGTID of
                        0: Str2 := 'H(A): ';
                        1: Str2 := 'H(R): ';
                        2: Str2 := 'H(L): ';
                      end;

                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    Str2, cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  J:= MenuX + 60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End
                  else
                    Begin

                      case HGTID of
                        0: Str2 := inf[19];
                        1: Str2 := inf[63];
                        2: Str2 := inf[64];
                      end;

                      AsphFonts[Font2].TextOut(
                        Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                        Str2,                               // IntToStr(Timer.FrameRate);
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                       J:= MenuX + 60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                       AsphFonts[Font1].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    End;



                case HGTID of
                  0: AsphCanvas.UseImagePx(AsphImages.Image['h.image'], pxBounds4(0, 0, 64, 64));
                  1: AsphCanvas.UseImagePx(AsphImages.Image['rh.image'], pxBounds4(0, 0, 64, 64));
                  2: AsphCanvas.UseImagePx(AsphImages.Image['lh.image'], pxBounds4(0, 0, 64, 64));
                end;

                AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                  0), clWhite4);

             END
               Else
               BEGIN

                  if CurHgt2='-' then
                  begin
                     if CurHgt3='-' then
                       B := 0
                     else
                       if (HAGL < MaxHgtL) and (HAGL > MinHgtL)  then
                         B := 10
                         else
                            B := 11
                  end
                    else
                  if CurHgt3='-' then
                  begin
                      if (HAGR < MaxHgtR) and (HAGR > MinHgtR)  then
                        B :=  20
                        else
                          B :=  21
                  end
                    else
                     Begin
                        if ((HAGR < MaxHgtR) and (HAGR > MinHgtR))  and ((HAGL < MaxHgtL) and (HAGL > MinHgtL))  then
                          B := 1
                          else
                            if ((HAGR >= MaxHgtR) and (HAGR <= MinHgtR)) and ((HAGL < MaxHgtL) and (HAGL > MinHgtL)) then
                               B := 2
                               else
                               if ((HAGR < MaxHgtR)and (HAGR > MinHgtR)) and ((HAGL >= MaxHgtL)or(HAGL <= MinHgtL)) then
                                  B := 3
                                  else
                                    B := 4
                     End;

                  DrawHgtButton(i, i=ChoosedMenu, B);

                  if BigText then
                  begin
                      j := MenuX +65;
                      AsphFonts[Font5].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 1.0 + trunc(_MenuScroll)),
                        'HA:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font5].TextOut(
                         Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                        'HR:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font5].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 49.0 + trunc(_MenuScroll)),
                        'HL:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                      j := MenuX + 110;

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + -3.0 + trunc(_MenuScroll)),
                        CurHgt,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 20.0 + trunc(_MenuScroll)),
                        CurHgt2,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 44.0 + trunc(_MenuScroll)),
                        CurHgt3,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                  end
                   else
                   begin
                      j := MenuX +62;
                      AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 1.0 + trunc(_MenuScroll)),
                        inf[65],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font3].TextOut(
                         Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                        inf[66],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 49.0 + trunc(_MenuScroll)),
                        inf[67],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      j := MenuX + 120;
                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                        CurHgt,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 23.0 + trunc(_MenuScroll)),
                        CurHgt2,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 47.0 + trunc(_MenuScroll)),
                        CurHgt3,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   end;

                  AsphCanvas.UseImagePx(AsphImages.Image['h.image'], pxBounds4(0, 0, 64, 64));
                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                  0), clWhite4);
               END;

             End;

             3:  ///// MODE
             Begin



               if BigText then
               Begin
                  Str := inf[21];
                  if length(Str)>=6 then
                     Str := Copy(inf[21],1,3)+'.:';

                  AsphFonts[Font3].TextOut(
                    Point2(MenuX + 10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeShortNames[MapMode];
                  J:= MenuX + Trunc((-AsphFonts[Font1].TextWidth(Str)
                            - AsphFonts[Font4].TextWidth(MapModeShortSubNames[MapMode])
                            + MenuW) / 2);

                  AsphFonts[Font1].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  J:= J + trunc(AsphFonts[Font1].TextWidth(Str));
                  Str :=  MapModeShortSubNames[MapMode];

                  AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 32.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                else
                Begin
                  AsphFonts[Font2].TextOut(
                    Point2(MenuX + 10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                    inf[21],
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeNames[MapMode];
                  J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);

                  AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 28.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeSubNames[MapMode];
                  J:= MenuX+Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

                  AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 48.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End;

               j :=0;
                 if BigText then
                      j := 15;

               if not AutoOn then
               Begin
                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 + j div 2,
                  i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  3.14), clWhite4);

                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 180 + j div 2,
                  i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  0), clWhite4);
               End
                Else
                 Begin                                                                    // xz
                   AsphCanvas.UseImagePx(AsphImages.Image['lock.image'], pxBounds4(0, 0, 32, 32));

                   AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 +j,
                   i*MenuButtonSize[MenuN] + 17.0 - j div 3 + trunc(_MenuScroll)), Point2(25, 25),
                                  0), clWhite4);
                 End;

             End;
             4:   //// SCALE
             Begin
               if BigText then
               Begin
                  AsphFonts[Font3].TextOut(
                      Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                      inf[22],
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str := MashtabNames[Mashtab];
                  J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);
                  AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                 else
                 Begin
                    AsphFonts[Font2].TextOut(
                      Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                      inf[22],
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    Str := MashtabNames[Mashtab];
                    J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);
                    AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 28.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                 End;

                 j :=0;
                   if BigText then
                      j := 15;

               if not AutoOn then
               Begin
                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  if Mashtab > 0 then
                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 +j div 2,
                    i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  3.14), clWhite4);

                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));
                  if Mashtab < MaxMashtab-1 then
                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 180 +j div 2,
                    i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  0), clWhite4);
               End
                else
                Begin

                  if AutoOn and ChangeAutoM then
                    AsphCanvas.UseImagePx(AsphImages.Image['unlock.image'], pxBounds4(0, 0, 32, 32))
                      else
                         AsphCanvas.UseImagePx(AsphImages.Image['lock.image'], pxBounds4(0, 0, 32, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170+j,
                      i*MenuButtonSize[MenuN] + 17.0 - (j div 3) + trunc(_MenuScroll)),
                      Point2(25, 25), 0), clWhite4);
                End;

             End;

             5:  /// CURRENT
             Begin
               if BigText then
               Begin
                  J := MenuX+trunc(AsphFonts[Font3].TextWidth('M0:'));
                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    'M0:',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+40.0, i*MenuButtonSize[MenuN] + 36.0 + trunc(_MenuScroll)),
                    'D: ',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[CurrentRoute].Name;

                  AsphFonts[Font1].TextOut(
                      Point2( 10 + j, i*MenuButtonSize[MenuN] - 2.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                      if DistToCurrent> 1000 then
                        Str := IntToStr(Round(DistToCurrent/1000)) + ' '+inf[25]
                          else
                            Str := IntToStr(Trunc(DistToCurrent)) + ' '+ inf[20];


                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+65, i*MenuButtonSize[MenuN] + 29.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               End
                Else
                Begin
                  J := MenuX + trunc(AsphFonts[Font4].TextWidth(inf[23]));

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    inf[23],
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font2].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 36.0 + trunc(_MenuScroll)),
                    'D: ',
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[CurrentRoute].Name;

                  AsphFonts[Font1].TextOut(
                    Point2( 10 + j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                      if DistToCurrent> 1000 then
                        Str := IntToStr(Round(DistToCurrent/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToCurrent)) + inf[20];


                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+40, i*MenuButtonSize[MenuN] + 30.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;

             End;
             6:
             Begin
                if BigText then
               Begin
                   J := MenuX+trunc(AsphFonts[Font3].TextWidth('M1:'));
                   AsphFonts[Font3].TextOut(
                     Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                     'M1:',
                     cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   AsphFonts[Font4].TextOut(
                     Point2(MenuX+50.0, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll)),
                     'MD: ',
                     cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  if (NextRoute=-1)or(NextRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[NextRoute].Name;

                  AsphFonts[Font1].TextOut(
                      Point2( 14 + j, i*MenuButtonSize[MenuN] - 2.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                    else
                      if DistToNext> 1000 then
                        Str := IntToStr(Round(DistToNext/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToNext)) + inf[20];

                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+90, i*MenuButtonSize[MenuN] + 29.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                Else
                Begin

                  J := MenuX+trunc(AsphFonts[Font4].TextWidth(inf[24]));
                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    inf[24],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll)),
                    inf[26],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                       Str := Route[NextRoute].Name;

                  AsphFonts[Font1].TextOut(
                    Point2( 10 + j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                    else
                      if DistToNext> 1000 then
                        Str := IntToStr(Round(DistToNext/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToNext)) + inf[20];

                  AsphFonts[Font4].TextOut(
                    Point2( MenuX+135, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;

             End;

             7:  /// Авто
             if AllowAuto then
             Begin
               if AutoOn = false then 
                   DrawMenuButton(i, i=ChoosedMenu , false , 9);
                   
               AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    inf[27],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               if AutoOn then
                 Str := inf[28]
                  else
                   Str := inf[29];

                J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);

                AsphFonts[Font1].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);     // xzc

             End;
          end;


      end;  

    End;
    2: ////  Меню выбора режима
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
         DrawMenuButton(i, i=ChoosedMenu , false , 0);


               Str :=  MapModeNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               Str :=  MapModeSubNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 26.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    3: ////  Меню выбора масштаба
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

               Str :=  MashtabNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    4: ////  Меню действия при превышении дистанции
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
            0: Str := inf[30];
            1: Str := inf[31];
            2: Str := inf[32];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

          case i of
            0: Str := inf[33];
            1: Str := inf[34];
            2: Str := inf[35];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
      end;
    End;

    5, 6: ////  Меню выбора маршрута
    Begin

      for I := 0 to RouteCount-1 do
      begin
          if (i*MenuButtonSize[MenuN] + trunc(_MenuScroll) < DisplaySize.Y)
             and ((i+1)*MenuButtonSize[MenuN] > 0) then
          begin
            DrawMenuButton(i, i=ChoosedMenu , false , 5 + Route[i].Status);
               if BigText then
                   Str :=  inf[36][1] + ' ' +Route[i].Name
                  else
                    Str :=  inf[36] + Route[i].Name;

            //   J:= Trunc((-AsphFonts[Font2].TextWidth(Str)+AsphDevice.Size.x) / 2);
              if BigText then
                AsphFonts[Font2].TextOut(
                    Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0)
                else
                  AsphFonts[Font4].TextOut(
                      Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               if BigText then
                 Str :=''
                 else
                   Str := inf[37];

               if BigText then
               begin
                 case Route[i].Status of
                    0 : Str := Str + inf[53];
                    1 : Str := Str + inf[39];
                    2 : Str := Str + inf[54];
                    3 : Str := Str + inf[55];
                 end;
               end else
               case Route[i].Status of
                 0 : Str := Str + inf[38];
                 1 : Str := Str + inf[39];
                 2 : Str := Str + inf[40];
                 3 : Str := Str + inf[41];
               end;

               if BigText then
               Begin
                   J := MenuW - trunc( AsphFonts[Font4].TextWidth(Str) );

                   AsphFonts[Font4].TextOut(
                       Point2( MenuX + J -5 , i*MenuButtonSize[MenuN] + 18.0 + trunc(_MenuScroll)),
                       Str,
                       cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                   if (Route[i].Status >=2) and (Route[i].badHgts>25) then
                   Begin
                        /// БРАК ВЫСОТ
                        AsphCanvas.UseImagePx(AsphImages.Image['hgta.image'], pxBounds4(0, 0, 32, 32));

                        AsphCanvas.TexMap(pRotate4c(Point2(MenuX+158, i*MenuButtonSize[MenuN] + 11.0 + trunc(_MenuScroll)), Point2(24, 24),
                                  0), clWhite4);

                        Col := cColor2( $9FFFFFFF, $FFFFFFFF);
                           if Route[i].badHgts>50 then
                              Col := clRed2;

                        AsphFonts[Font3].TextOut(
                          Point2( MenuX + 170.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                          IntToStr(Route[i].badHgts),
                          Col, 1.0);
                   End;                                  // cx
               End
                 else
                 Begin
                   AsphFonts[Font3].TextOut(
                       Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 18.0 + trunc(_MenuScroll)),
                       Str,
                       cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                        if (Route[i].Status >=2) and (Route[i].badHgts>25) then
                        Begin
                           /// БРАК ВЫСОТ
                           AsphCanvas.UseImagePx(AsphImages.Image['hgta.image'], pxBounds4(0, 0, 32, 32));

                           AsphCanvas.TexMap(pRotate4c(Point2(MenuX+152, i*MenuButtonSize[MenuN] + 11.0 + trunc(_MenuScroll)), Point2(24, 24),
                                  0), clWhite4);

                           Col := cColor2( $9FFFFFFF, $FFFFFFFF);
                           if Route[i].badHgts>50 then
                              Col := clRed2;

                           AsphFonts[Font3].TextOut(
                             Point2( MenuX + 162.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                             IntToStr(Route[i].badHgts)+'%',
                             Col, 1.0);
                        End;
                 End;
          end;

      end;
    End;

    7: ////  Лететь заново?
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[42];
             1 : Str := inf[43];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    8: //// Улет
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[44];
             1 : Str := inf[45];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    9: //// Достиг базу
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[46];
             1 : Str := inf[47];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
          AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

          case i of
             0 : Str := inf[48];
             1 : Str := inf[49];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);
          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
      end;
    End;

    10: //// Маршруты кончились
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[50];
             1 : Str := inf[51];
             2 : Str := inf[52];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 14.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;



 end;


end;

procedure TMainForm.ResetMaps;
begin
   ShowMaps := False;
   AsphMapImages.RemoveAll();
   SetLength(MapList,0);
end;

procedure TMainForm.ReDrawBase;
var dx, dy, dx2, dy2, x, y, fi : Double;
    csize: integer;
begin
//// Base
///
     if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     dx := (Center.x - Base[1].x)/ Scale ;
     dy := (Center.y - Base[1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     csize := 32;
     if BigCur then
        csize := 64;

     if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
         begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['flag_big.image'], pxBounds4(0, 0, 64, 64))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['flag.image'], pxBounds4(0, 0, 32, 32));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

         end;
end;

procedure TMainForm.ReDrawLines(dash:Boolean);
var  i, j, lcount, lstep : Integer;
     x1, y1, x2, y2, dx, dy, dx2, dy2 : Double ;
     Mas, fi    : double ;
begin
    Mas := Scale; //TMashtab[Mashtab]/100 ;

    if MapModeDoRotate[MapMode] then
    begin
        fi := -Azimuth;

        if MapMode= 5 then
           fi := - CurrentRouteAngle;

    end
        else
          fi := 0;

    if Mashtab<MaxMashtab-2 then
      lstep := TMashtab[Mashtab+1]
        else
          lstep := TMashtab[Mashtab];

      if (DisplaySize.X - MenuW) > DisplaySize.y then
          lcount := trunc((DisplaySize.X - MenuW) /2 * mas / lstep)+1
            else
              lcount := trunc(DisplaySize.y /2 * mas / lstep)+1;

    for J := -lcount to lcount do
    Begin

         x1 :=Trunc(Center.x /lstep)*lstep;// + I*lstep;
         y1 :=Trunc(Center.y /lstep)*lstep + J*lstep;

         x2 := x1 + (DisplaySize.X - MenuW) * mas;
         y2 := y1;// + (DisplaySize.X - MenuW) * mas;
         x1 := x1 - (DisplaySize.X - MenuW) * mas;
         y1 := y1;// - (DisplaySize.X - MenuW) * mas;

         dx := (Center.x - x1)/ Mas ;
         dy := (Center.y - y1)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 := -dx * Sin (Fi) + dy * Cos(Fi);

         x1 := round ((DisplaySize.X - MenuW) div 2 - dx2);
         y1 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2) + VYShift;

         dx := (Center.x - x2)/ Mas ;
         dy := (Center.y - y2)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

         x2 := round((DisplaySize.X - MenuW) div 2 - dx2);
         y2 := DisplaySize.y - round(DisplaySize.y div 2 - dy2) + VYShift;

         MyLine(x1, y1, x2, y2, dash, LinesColor);
    end;

    for I := -lcount to lcount do
    begin
         x1 :=Trunc(Center.x /lstep)*lstep + I*lstep;
         y1 :=Trunc(Center.y /lstep)*lstep; //+ J*lstep;

         x2 := x1;// + (DisplaySize.X - MenuW) * mas;
         y2 := y1 + (DisplaySize.X - MenuW) * mas;
         x1 := x1;// - (DisplaySize.X - MenuW) * mas;
         y1 := y1 - (DisplaySize.X - MenuW) * mas;

         dx := (Center.x - x1)/ Mas ;
         dy := (Center.y - y1)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 := -dx * Sin (Fi) + dy * Cos(Fi);

         x1 := round ((DisplaySize.X - MenuW) div 2 - dx2);
         y1 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2) + VYShift;

         dx := (Center.x - x2)/ Mas ;
         dy := (Center.y - y2)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

         x2 := round((DisplaySize.X - MenuW) div 2 - dx2);
         y2 := DisplaySize.y - round(DisplaySize.y div 2 - dy2) + VYShift;

         MyLine(x1, y1, x2, y2, dash, LinesColor);
    End;

end;

procedure TMainForm.ReDrawMaps;
var  i, j, ImgN : Integer;
     _x, _y : array [1..4] of Double;
     Mas, fi, dx, dy, dx2, dy2, L, xmin, ymin, xmax, ymax : double ;
     Col : TColor4;
begin

 if MapModeDoRotate[MapMode] then
    begin
        fi := -Azimuth;

        if MapMode= 5 then
           fi := - CurrentRouteAngle;

    end
        else
          fi := 0;                


    for I := 0 to Length(MapList) - 1 do
    Begin
       for j := 1 to 4 do
       Begin
          dx := (Center.x - MapList[i].x[j])/ Scale ;
          dy := (Center.y - MapList[i].y[j])/ Scale ;

          dx2 := dx * Cos (Fi) + dy * Sin(Fi);
          dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

          _x[j] := round ((DisplaySize.X - MenuW) div 2 - dx2 );
          _y[j] := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;
       End;

       try
          L := sqrt(sqr(_x[4]-_x[1])+sqr(_y[4]-_y[1]));
       except
         continue;
       end;

       if (L < 5 * MinMap) then
         continue;

       if (L > 5 * MaxMap) then
         continue;


       xmin := _x[1];
       ymin := _y[1];
       xmax := _y[1];
       ymax := _y[1];
       for j := 2 to 4 do
       begin
         if _x[j] < xmin then
           xmin := _x[j];
         if _y[j] < ymin then
           ymin := _y[j];

         if _x[j] > xmax then
           xmax := _x[j];
         if _y[j] > ymax then
           ymax := _y[j];
       end;

       if (xmax<0)and(xmin<0) or (xmax > DisplaySize.X)and(xmin > DisplaySize.X) then
           continue;
           
       if (ymax<0)and(ymin<0) or (ymax > DisplaySize.Y)and(ymin > DisplaySize.Y) then
           continue;


       if L<45 then
           ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName+'_t'] )
          //AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName+'_t'], pxBounds4(0, 0, 32, 32))
           else
           if l<220 then
              ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName+'_s'] )
             //AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName+'_s'], pxBounds4(0, 0, 128, 128))
               else
                 ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName] );
                 // AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName], pxBounds4(0, 0, 512, 512));

       if ImgN=-1 then
          ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName] );
       AsphCanvas.UseImagePx(AsphMapImages.Items[ImgN], pxBounds4(0, 0,
                  AsphMapImages.Items[ImgN].PatternSize.x, AsphMapImages.Items[ImgN].PatternSize.y ));

       if MapAlpha=255 then
         Col := ClWhite4
          else
           Col := cRGB4(255,255,255,MapAlpha);

        AsphCanvas.TexMap(Point4( _x[1], _y[1],  _x[2], _y[2],
                          _x[3], _y[3],  _x[4], _y[4]), Col)

                                 
       {AsphCanvas.TexMap(PBounds4( i*300, 0, 300, 300),
              clWhite4)}
   End;


end;

procedure TMainForm.ReDrawMarkers;
var dx, dy, dx2, dy2, x, y, fi: Double;
    csize, i, j, Fnt, w : integer;
    canLabel :boolean;
begin
//// Base
///
     if MarkerCount<1 then
       exit;
       
     if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     for I := 0 to MarkerCount - 1 do
     Begin
       dx := (Center.x - Markers[I].x)/ Scale ;
       dy := (Center.y - Markers[I].y)/ Scale ;

       dx2 := dx * Cos (Fi) + dy * Sin(Fi);
       dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

       x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
       y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

       Markers[i].iX := trunc(x);
       Markers[i].iY := trunc(y);
       
       csize := 16;
       if BigCur then
         csize := 32;

       if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
          begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['marker1_big.image'], pxBounds4(0, 0, csize , csize ))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['marker1.image'], pxBounds4(0, 0, csize , csize ));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

            canLabel := true;
            
            Markers[i].OnScreen := true;

            if Markers[i].Caption<>'*' then
            try

              if BigCur then
                Fnt := Font4
                  else Fnt := Font5;

              w := round(AsphFonts[Fnt].TextWidth(Markers[i].Caption)/2);
              Markers[i].iW := w;

              for J := 0 to MarkerCount - 1 do
                if I<>j then
                 if Markers[j].OnScreen then
                  if (y > Markers[j].iY-csize*2)and(y < Markers[j].iY+csize*2) then
                   if (x+w > Markers[j].iX-Markers[j].iw)and(x-w < Markers[j].iX+Markers[j].iw) then
                     begin
                        canlabel := false;
                        break;
                     end;

              if BigCur then
                dy := 0
                else
                  dy := cSize;

              if CanLabel then
                 AsphFonts[Fnt].TextOut(Point2(trunc(x)-w,trunc(y)-cSize-trunc(dy)),
                                         Markers[i].Caption,clWhite2);
            except
            end;
         end
           else
            Markers[i].OnScreen := false;


     End;
end;


procedure TMainForm.ReDrawRoutes;
       var i  : Integer;
           L      : Double;
           x, y   : integer;
           x2, y2 : Integer;
           _x, _y   : integer;
           _x2, _y2 : Integer;
           cur1, cur2: TMyPoint;
           Mas    : double;
           w, h   : Integer;
           fi, fi2: double;
           dx, dy : double;
           dx2,dy2 : double;
           s      : string;
begin

    if RouteCount = 0  then
      exit ;

      w := (DisplaySize.X - MenuW);
      h := DisplaySize.y;

      Mas := Scale; //TMashtab[Mashtab]/100 ;

      for i := 0 to RouteCount  -1 do
      begin

             if MapModeDoRotate[MapMode] then
             begin
                fi := -Azimuth;
             end
                  else
                    fi := 0;

             if MapMode = 5 then
                fi := - CurrentRouteAngle;

             dx := (Center.x - Route[i].x1)/ Mas ;
             dy := (Center.y - Route[i].y1)/ Mas ;

             dx2 := dx * Cos (Fi) + dy * Sin(Fi);
             dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

             x := round (w div 2 - dx2 );
             y := h -  round (h div 2 - dy2 ) + VYShift;

             dx := (Center.x - Route[i].x2)/ Mas ;
             dy := (Center.y - Route[i].y2)/ Mas ;

             dx2 := dx * Cos (Fi) + dy * Sin(Fi);
             dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

             x2 := round(w div 2 - dx2);
             y2 := h - round(h div 2 - dy2) + VYShift;

             if i = RouteAsk then
                FatLine(x, y, x2, y2, 2+DopFat, false, MenuChoosedColor);

             if i = CurrentRoute then
             Begin

               if (MapMode > 2) and (MapMode < 6) then
               begin
                Cur1.X := x;
                Cur2.X := x2;
                Cur1.y := y;
                Cur2.y := y2
               end
                else
                  FatLine(x, y, x2, y2, 1+DopFat, false, ChoosedColor);

             End
             else
               if i = NextRoute then
               begin
                 FatLine(x, y, x2, y2, 1+DopFat, false, RoutesColor);

                 FatLine(x, y, x2, y2, 0+DopFat, false,
                         cRGB1(GetBValue(ChoosedColor),GetGValue(ChoosedColor),GetRValue(ChoosedColor),50));
               end
                  else
                    if Route[i].Status = 0 then
                      FatLine(x, y, x2, y2, 0+DopFat, false, RoutesColor)
                       else
                       if Route[i].Status >= 2 then
                          FatLine(x, y, x2, y2, 0+DopFat, false, DoneColor);

      end ;

  //////////// FRAME
      
      if Frame and ShowFrame then
         if FrameCount  >1 then
         Begin
            for i := 0 to FrameCount  -2 do
            begin

               dx := (Center.x - FramePoints[i,1].x)/ Mas ;
               dy := (Center.y - FramePoints[i,1].y)/ Mas ;

               dx2 := dx * Cos (Fi) + dy * Sin(Fi);
               dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

               x := round (w div 2 - dx2 );
               y := h -  round (h div 2 - dy2 ) + VYShift;

               dx := (Center.x - FramePoints[i+1,1].x)/ Mas ;
               dy := (Center.y - FramePoints[i+1,1].y)/ Mas ;

               dx2 := dx * Cos (Fi) + dy * Sin(Fi);
               dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

               x2 := round(w div 2 - dx2);
               y2 := h - round(h div 2 - dy2) + VYShift;

               FatLine(x, y, x2, y2, 1+DopFat, false,
                        cRGB1(GetBValue(MenuChoosedColor),
                        GetGValue(MenuChoosedColor),
                        GetRValue(MenuChoosedColor),75));
            end;
       End;

   ///////////// CURRENT ПОВЕРХ ВСЕГО

     if (MapMode > 2) and (MapMode < 6) then
         if (CurrentRoute > -1)and( CurrentRoute < RouteCount) then
         try

                 if ShowActiveZone then
                  Begin

                    _x := round(Cur1.x); _y := round(Cur1.y); _x2 :=  round(Cur2.x); _y2 :=  round(Cur2.y);

                    fi2 := arctan2(Cur2.x-Cur1.x,Cur2.y-Cur1.y);
                     //zxczxczx
                    dx2 :=  RouteMaxDist /Mas * sin(fi2+pi/2) ;
                    dy2 :=  RouteMaxDist /Mas * cos(fi2+pi/2) ;

                    x :=  round( Cur1.x + dx2  );
                    y :=  round( Cur1.y + dy2 );
                    x2 := round( Cur2.x + dx2 );
                    y2 := round( Cur2.y + dy2 );

                    DrawZone(x, y, x2, y2,_x2,_y2, _x, _y);

                    x :=  round( x - 2* dx2  );
                    y :=  round( y - 2*  dy2 );
                    x2 := round( x2 - 2* dx2 );
                    y2 := round( y2 - 2* dy2 );

                    DrawZone(x, y, x2, y2,_x2,_y2, _x, _y);
                 End;


                 if (ReflyCurrent)and(Sin(AsphTicks*0.1)>0) then
                    FatLine(Cur1.x, Cur1.y, Cur2.x, Cur2.y, 1+DopFat, false, MenuChoosedColor)
                      else
                        FatLine(Cur1.x, Cur1.y, Cur2.x, Cur2.y, 1+DopFat, false, ChoosedColor);


                  L := SQRT(SQR(Cur2.x - Cur1.x)+SQR(Cur2.y - Cur1.y));
                  if L > 0 then
                  begin
                    dx := ( Cur2.x-Cur1.x)/L;
                    dy := ( Cur2.y-Cur1.y)/L;

                    x :=  round( Cur1.x - 4*L*dx );
                    y :=  round( Cur1.y - 4*L*dy );
                    x2 := round( Cur2.x + 4*L*dx );
                    y2 := round( Cur2.y + 4*L*dy );

                    FatLine(x, y, x2, y2, 0+DopFat, true, ChoosedColor);

                    fi2 := arctan2(x2-x,y2-y);
                     //zxczxczx
                    dx2 :=  RouteMaxDist /Mas * {Cos (pi/2-Fi )} sin(fi2+pi/2) ;
                    dy2 :=  RouteMaxDist /Mas * {Sin (pi/2-Fi )} cos(fi2+pi/2) ;

                    x :=  round( x +  dx2  );
                    y :=  round( y +  dy2 );
                    x2 := round( x2 + dx2 );
                    y2 := round( y2 + dy2 );

                    _x := x; _y := y;  _x2 := x2; _y2 := y2;

                    FatLine(x, y, x2, y2, 0+DopFat, true, RouteOkColor);

                    x :=  round( x - 2* dx2  );
                    y :=  round( y - 2*  dy2 );
                    x2 := round( x2 - 2* dx2 );
                    y2 := round( y2 - 2* dy2 );

                    FatLine(x, y, x2, y2, 0+DopFat, true, RouteOkColor);


                  end;
       except           
       End;

end;

procedure TMainForm.RxMemoKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_F1 then
  begin
    Timer.Enabled:= False;
    Settings.ShowModal;
  end;

  if Key = VK_F5 then
      Panel5.Visible := not Panel5.Visible;
end;

procedure TMainForm.SaveLogFile;
var s :String;
    i :integer;
    RoutesRemain : TSTringList;
begin

  if RealTime then
  Begin
    if GPSLog.Count> MaxLogSize then
    begin
      for I := 1 to LogsMax do
      begin
        s := _GPSLogFileName+'_'+ IntTostr(i) +'.GPS';
        if not Fileexists(s) then
        begin
           GPSLogFileName  := s;
           GPSLog.SaveToFile(GPSLogFileName);
           GPSLog.Clear;
           break;
        end;
      end;
    end
      else
       GPSLog.SaveToFile(GPSLogFileName);

    Odo.Clear;
    Odo.Add(FloatToStr(Odometr));
    Odo.SaveToFile(LogDir+'Odo.log');         
  End;

  if Report.Count >4  then
  Begin
    if RealTime then
       Report.SaveToFile(ReportFileName+'_routes.txt')
       else
         Report.SaveToFile(ReportFileName+'_emulroutes.txt');
  End;


  RoutesRemain := TSTringList.Create;
  for I := 0 to RouteCount - 1 do
  Begin    
    if Route[i].Status < 2 then
    Begin
      RoutesRemain.Add(Route[i].Name+'a' + #$9 + FloatToStr(Route[i].Gx1) 
                         + #$9 + FloatToStr(Route[i].Gy1));
                         
      RoutesRemain.Add(Route[i].Name+'b' + #$9 + FloatToStr(Route[i].Gx2) 
                         + #$9 + FloatToStr(Route[i].Gy2));
      
    End;
    
  End;

  if RoutesRemain.Count > 0 then
  Begin

    if RealTime then
    Begin
     RoutesRemain.SaveToFile(Report2FileName+'_remain(WGS).txt');
     if Frame then
       CopyFile(PChar(FrameFile), PChar(Report2FileName+'_remain(WGS)_f.txt'),true);
    End
      else
      Begin
        RoutesRemain.SaveToFile(Report2FileName+'_emulremain(WGS).txt');
        if Frame then
          CopyFile(PChar(FrameFile), PChar(Report2FileName+'_emulremain(WGS)_f.txt'),true)
      End;
      
  End;

  RoutesRemain.Destroy;
end;


function SecToHMS(Sec : double) :string ;
var H,M: Integer;
    s, Hh :Double;
    sH, sM, sS, SMm : String;
begin

  Hh := Sec/3600;

  H := trunc(Hh);
  M := trunc(frac(Hh)*60);
  s := (frac(Hh)*60-M)*60;

  if round(s*1000) >= 60000 then
  begin
     s := s - 60;
     if s < 0 then
       s := 0;
     inc(M);
  end;
  if M >=60 then
  begin
     M := M - 60;
     if M < 0 then
       M := 0;
     inc(H);
  end;

  sH  := inttostr(H);
  sM  := inttostr(M);
  sS  := format('%.2f',[s]);

  if M < 10 then
  begin
    sM := '0' + sM;
  end;

  if s < 10 then
    sS := '0' + sS;

  Result:= sH + ':'+ sM + ':' + Ss ;
end;

procedure TMainForm.SaveTrack;
var I :integer;
    s : String;
    TrackS : TStringList;
begin
   if SizeTrackRecord = 0 then
      exit;

      for I := 1 to LogsMax do
      begin
        s := TrackFileName+'_track_'+ IntTostr(i) +'.txt';
        if not Fileexists(s) then
           break;
      end;

     TrackS := TStringList.Create;
                                              
     for I := 0 to SizeTrackRecord - 1 do
       with TrackRecord[i] do
           TrackS.Add(SectoHMS(Time) + #$9 +  DegToDMS(Lat,0) + #$9 +
                    DegToDMS(Long,0) + #$9 + format('%n',[h]) + #$9 +
                    format('%n',[OdoMr]) + #$9 + RouteNm + #$9 +
                    format('%.1f',[RDist/10]) + #$9 +
                    format('%n',[x]) +#$9 + format('%n',[y]) + #$9 +
                    format('%n',[hg])+#$9 + IntToStr(hr) + #$9 + IntToStr(hl)+ #$9 +
                    IntToStr(RPRogress));

     TrackS.SaveToFile(s);


     TrackS.Clear;
     TrackS.Add(s);
     TrackS.Add(IntToStr(MinHGTR));
     TrackS.Add(IntToStr(MaxHGTR));
     TrackS.Add(IntToStr(MinHGTL));
     TrackS.Add(IntToStr(MaxHGTL));
     TrackS.Add(IntToStr(RouteMaxDist));
     TrackS.Add(Settings.Languages.Items[Settings.Languages.ItemIndex]);
     TrackS.SaveToFile(DataDir+'LastTrack.log');
     TrackS.Destroy;

end;

procedure TMainForm.SetCurrentRoute(RouteN: integer);
var i: Integer;
    OldRoute : integer;
begin
  OldRoute := CurrentRoute;

 if RouteN<>-1 then
  if RouteN < RouteCount then
  Begin
       if Route[RouteN].Status = 0 then
       begin
          if (CurrentRoute<>-1) then
          if Route[CurrentRoute].Status = 1 then
             Route[CurrentRoute].Status := 0;

          CurrentRoute := RouteN;
          Route[RouteN].Status := 1;

          CurrentRouteAngle := GetRouteAngle(RouteN);
          GetNextRoute;

          ReFlyCurrent := False;
          NumDist := 0;
          SumDist := 0;
          NumBadHgt := 0;

          CurToNextDist;

          WorstDist:= false;
          BadDist := False;
          SumDist := 0;
          NumDist := 0;
          NumBadHgt := 0;
       end;
  End;
  if OldRoute <> CurrentRoute then
     PrevRoute := OldRoute;
end;

procedure TMainForm.SetCurrentRouteByName(RouteName: string);
var i, RouteN: Integer;
begin
 RouteN :=-1;

 for I := 0 to RouteCount - 1 do
   if RouteName = Route[i].Name then
   begin
      RouteN := I;
      break;
   end;

 SetCurrentRoute(RouteN);


end;

procedure TMainForm.SetNewRouteStatus(N, Stat: Integer);
var RF : boolean;
begin
  try
    if Route[N].Status<>1 then
       Route[N].Status := Stat
        else
         begin
           RF := ReFlyCurrent;
           ReFlyCurrent := true;
           Route[N].Status := Stat;
           GoToNextRoute;
           ReFlyCurrent := RF;
         end;
     ReComputeRoutes(false);
  except
  end;
end;

procedure TMainForm.ShiftMap(Key: Byte);
var Mas, mShiftX, mShiftY :real;
begin
  Mas := Scale;
  mShiftX := 0;
  mShiftY := 0;
  case Key of
   0: if Mashtab < MaxMashtab-1 then
          Inc(Mashtab);
   1: if Mashtab > 0 then
          Dec(Mashtab);

   2:  mShiftY := DisplaySize.y *0.15;
   3:  mShiftY := -DisplaySize.y *0.15;
   4:  mShiftX := (DisplaySize.X - MenuW) *0.25;
   5:  mShiftX := -(DisplaySize.X - MenuW) *0.25;

 end;

 if AutoOn then
  begin
    if ChangeAutoM then
    begin
       case MapMode of
         1,2,6,7 : if Speed < 10 then
                    AutoM[1] :=  Mashtab
                      else
                        AutoM[3] :=  Mashtab;
         3,4,5 : if not (BeforeBegin or AfterEnd or ReflyCurrent) then
                     AutoM[5] :=  Mashtab
                           else
                             AutoM[7] :=  Mashtab;
       end;
    end;
  end;

 Center.x := Center.x - MShiftX*Mas ;
 Center.y := Center.y + MShiftY*Mas ;
end;

procedure TMainForm.SKToWGS(x, y, h: Double; var B, L: Double);
var B2, L2, H2, h1 : Double;
begin

  GaussKrugerToGeo(x, y, B2, L2);
  Geo1ToGeo2(B2, L2, 0, SK, WGS, B, L, H1);

end;

procedure TMainForm.SmartMenuKeyCommand(Key: Byte);
begin
 ///
 case Key of
    1: Begin  /// UP
       if SmartN > 4 then
         SmartN := SmartN-4;
       if SmartN < 0 then
         SmartN := SmartN+4;
    End;

    2: Begin   /// DOWN
      if SmartN<= SmartCount then
         SmartN := SmartN+4;
      if SmartN > SmartCount then
         SmartN := SmartN-4;    
    End;

    3: Begin   /// LEFT
      if SmartN<=0 then
         SmartN := SmartCount
           else
          dec(SmartN);
         
       if SmartN < 0 then
         SmartN := SmartCount;
    End;

    4: Begin
     // if SmartN = 0 then
     //  SmartN := 5
     //  else
        //if (SmartN <> 4) then
         inc(SmartN)  ;
        //  else SmartN := 0; 

      if SmartN > SmartCount then
         SmartN := 0;
    End;

    5: Begin   ///  ENTER
        case SmartN of
          -1, 0: inSmart := false;
	        1: begin
            ShowInfo := not (ShowInfo);

          end;
          2: begin
             if MaxDotsVisible = 0 then
               MaxDotsVisible := MaxDotsCount
             else
             if MaxDotsVisible = MaxDotsCount then
              MaxDotsVisible := 1000
              else
                if MaxDotsVisible = 1000 then
                   MaxDotsVisible := 0
          end;
          3: begin 
            if Length(MapList)<>0 then
                ShowMaps := not ShowMaps;
            if ShowMaps then
                RecomputeMaps(False);
          end;
          4: begin
             Timer.Enabled:= False;
             Settings.ShowModal;
            
          end;
          5: begin
             ConnectCOM(ComPort1);
          end;
          6: begin
             ConnectCOM(ComPort2);
          end;

          7: begin
            HgtLine := not (HgtLine);
          end;

          8: Begin

          End;
        end;

    End;

    6: Begin   ///  ESC
       
       inSmart := false;

    End;

  end;
end;

procedure TMainForm.SpeedButton1Click(Sender: TObject);
begin
  EmulSpeed := 0;
end;

procedure TMainForm.SpeedButton2Click(Sender: TObject);
begin
  EmulSpeed := 1;
end;

procedure TMainForm.SpeedButton3Click(Sender: TObject);
begin
  EmulSpeed := EmulSpeed div 2;
end;

procedure TMainForm.SpeedButton4Click(Sender: TObject);
begin
  if Emulspeed = 0 then
     Emulspeed := 2;

  if EmulSpeed< 1024 then
    EmulSpeed := EmulSpeed *2;
end;

//---------------------------------------------------------------------------
procedure TMainForm.WGSToSK(B, L, H: Double; var x, y: Double; Zone: Integer;
  autozone: boolean);
var Bsk, Lsk, Hsk : Double;
begin

  Geo1ToGeo2(B, L, H, WGS, SK, Bsk, Lsk, Hsk);
  GeoToGaussKruger(Bsk, Lsk, y, x, Zone, AutoZone);

  if AutoZone then
  begin
     MyZone := Zone;
  end;
end;

procedure TMainForm.WMDisplayChange(var message: TMessage);
begin
 // This event happens when user changes screen resolution.
 //
 // We also detect if the screen resolution has changed because of our
 // full screen mode, in which case we simply exit.
 if (Tag = 1) then Exit;

 if (AsphDevice <> nil)and(AsphDevice.Active)and(AsphDevice.Windowed) then
  AsphDevice.Reset();
end;

//---------------------------------------------------------------------------
end.
