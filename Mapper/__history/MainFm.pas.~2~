unit MainFm;

//---------------------------------------------------------------------------
interface

//---------------------------------------------------------------------------
uses
  Messages, SysUtils, Classes, Controls, Forms, Dialogs, ExtCtrls, Windows,
  ComCtrls, Buttons, XPMan, StdCtrls, GeoFunctions, GeoClasses, Math,
  MMSystem, GeoString, GeoFiles, Menus, ShellAPI;

//---------------------------------------------------------------------------
type

  TMainForm = class(TForm)
    Panel1: TPanel;
    Panel5: TPanel;
    PopupMenu1: TPopupMenu;
    N1: TMenuItem;
    N2: TMenuItem;
    N3: TMenuItem;

    procedure N3Click(Sender: TObject);

    type TLatLong = record
      lat, long :Double
    end;

     Type TMyPoint = Record
       x, y : Double;
     end;

    function GetWGSCursor : TLatLong;

    procedure SaveTrack;

    procedure CutLineByBufferedFrame(var x,y,x2,y2: Double);
    procedure CutLineByFrame(var x,y,x2,y2: Double);

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormActivate(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure RxMemoKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure Panel2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure Panel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure MenuUnscroll;
    procedure Panel1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure SpeedButton2Click(Sender: TObject);
    procedure SpeedButton3Click(Sender: TObject);
    procedure SpeedButton4Click(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure Panel1Resize(Sender: TObject);
    procedure Panel1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckNearestMarkers(X, Y : Integer);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure N1Click(Sender: TObject);
    procedure N2Click(Sender: TObject);
  private
    { Private declarations }
    AsphTicks: Integer;

    procedure OnDeviceCreate(Sender: TObject; Param: Pointer;
     var Handled: Boolean);

    procedure Autorun;
    procedure InitAutoMode;
    procedure SaveLogFile;
    procedure InitData;

    procedure ShiftMap(Key : Byte);

    procedure TimerEvent(Sender: TObject);
    procedure ProcessEvent(Sender: TObject);
    procedure RenderEvent(Sender: TObject);
    procedure RenderMenus;
    procedure AxelScale;

    procedure DrawScaleAndNord (Mas: Double);

    procedure DrawArrowToNearest;
    function  DrawArrowToCurrentRoute: boolean;
    procedure DrawArrowToNextRoute;
    procedure DrawArrowToBase;

    procedure SmartMenuKeyCommand(Key : Byte);
    procedure MenuKeyCommand(Key : Byte);

    procedure DrawZone(x1,y1,x2,y2,x3,y3,x4,y4:Double);
    procedure MyLine(x,y,x2,y2:Double; Dash:Boolean; Col: Cardinal);
    procedure CrackDot(x,y: Double; Col:Cardinal);
    procedure FatLine(x,y,x2,y2:Double; Thin:integer; Dash:Boolean; Col: Cardinal);

    procedure WMDisplayChange(var message:TMessage); message WM_DISPLAYCHANGE;

    procedure SetCurrentRouteByName(RouteName:string);
    procedure GoToNextRoute;
    procedure CurToNextDist;

    procedure PutBaseHere( B,L :double);

    procedure FollowCurrentRoute(RouteN: integer; _CurTime: real; cx,cy :Double);

    function GetRouteAngle(RouteN:integer): Double;
    function GetDistToRoute(RouteN : integer; x, y: double): Double;

    procedure GetDistToBase(cx,cy : double);
    procedure GetNearestRoute(cx,cy : double);

    procedure SKToWGS(x, y, h: Double; var B, L: Double);
    procedure WGSToSK(B, L, H: Double; var x, y: Double; Zone:Integer; autozone : boolean);

    procedure AnalyseStr(s:String);
    procedure AnalyseAUXStr(s:String; AddToLog: boolean);
    procedure GPSTimerEvent;
    procedure AppendPoint (T :Real; x,y,Sh,Dol, h1,h2:double ; fl:Boolean);  ///// ИННОКЕНТИЙ
    procedure ReDrawLines(dash:Boolean);
    procedure ReDrawMaps;
    procedure ReDrawTrack;
    procedure ReDrawRoutes;
    procedure ReDrawBase;
    procedure ReDrawMarkers;
    procedure ReDrawTurnPoints;

    procedure AxelAzimuth(az2: double);
    procedure AxelHgts;

    function GetNormalPt(xb, yb, xe,ye, x, y: double; isRight: boolean; Dist: double): TMyPoint;
  public
   procedure AddMarker(Mname:string; mB, mL :Double);
   procedure DelMarker(DelI:integer);
   procedure EditMarker(I:integer; Mname:string; mB, mL :Double);
   procedure RefreshMarkerList;

   procedure SetCurrentRoute(RouteN:integer);
   procedure GetNextRoute;

   function GetTurnPoints(xp, yp, azmt, x1, y1, x2 ,y2, MinR, MaxR : double):boolean;

   procedure ReLoadRoutes(FileName:String);
   procedure SetNewRouteStatus(N, Stat :Integer);
   procedure ReComputeRoutes(WFZ:Boolean);
   procedure ReComputeTracks(WFZ:Boolean);
   procedure ReComputeMaps(WFZ:Boolean);
   procedure ClearGPS;
   procedure OpenEmulFile(FileName:String);
   function AskJoysticKey: integer;
   function AskJoystic: integer;

   procedure LoadMaps(Filename:String);
   procedure ResetMaps;

   procedure LoadAUXProt(FName:string);
    {
  Type TMyPoint = Record
      x, y : Double;
  end;}

  Type TMyPoint3D = Record
      x, y, z : Double;
  end;

  Type TMarker = Record
     B, L : Double;
     iX, iY, iW : Integer;
     x, y : Double;
     Caption : String;
     OnScreen, Show : boolean;
  End;

  const
   MenuNMax = 10;
   MapModesCount = 9;
   FrameMax = 100;
   MaxMashtab = 12 ;
   TMashtab : Array [0.. MaxMashtab-1 ] of Integer =
                    (10, 20, 50,
                     100, 200, 500,
                     1000, 2000, 5000,
                     10000, 20000, 50000);
   MenuCount: array [0..MenuNMax] of Integer = (0, 7, MapModesCount, MaxMashtab-1,
                                              2, 1, 1, 1, 1, 1, 2);

   MenuButtonSize: array [0..MenuNMax] of Integer = (0, 70, 50, 40, 50,
                                                      40, 40, 50, 50, 50, 50);

   MapModeDoRotate: array [0..MapModesCount] of Boolean = (false, false, true,
                                             false, true, true,false,true,false,true);
  var
    SID, AID : string;

    MashtabNames : Array [0.. MaxMashtab-1 ] of String;
    MapModeNames: array [0..MapModesCount] of String;
    MapModeShortNames: array [0..MapModesCount] of String;
    MapModeSubNames: array [0..MapModesCount] of String;
    MapModeShortSubNames: array [0..MapModesCount] of String;
    Inf: array [1..100] of String;

    ReCalcWay, SpecialTP: boolean;

    Markers : array [0..1000] of TMarker;
    MarkerCount: Integer;

    RoutesDatum, RoutesCS : integer;
    isRoutesDatum : boolean;
    RoutesXTab, RoutesYTab, RoutesZTab, RoutesNameTab, RoutesTabStart,
    RoutesX2Tab, RoutesY2Tab, RoutesZ2Tab : Integer;

    Center : TMyPoint ;
    Base : array [1..2] of TMyPoint;
    FramePoints : array [0..FrameMax,1..2] of TMyPoint3D;

    EnableCom2 : boolean;
    LocalTP : boolean;
    ShowActiveZone : boolean;
    SmartMenu : boolean;
    AskReturn: boolean; AskR: integer;
//    SmartCount :integer;

    MyDir, LogDir, DataDir, GPSDataDir, LogDataDir, RepDataDir, Rep2DataDir : String;
    LangExe : String;
    GPSBuffer, EmulBuffer, AUXBuffer, GPSLog, Odo, Report :TStringList;

    WaitForZone, ShowFrame : boolean;
    DrawScale, ShowInfo, HgtLine, DrawLines, DashLines, ShowCracks, ShowMaps, ShowCur : boolean;
    MinMap, MaxMap : integer;
    MapAlpha : integer;
    RealTime : boolean;
    AllowMouse : boolean;
    AllowJoyStick : boolean;

    StartFrom1st : boolean;
    RoundFly : boolean;
    HideNext : boolean;

    ShowTP : boolean;

    South, UTM: Boolean;

    HgtID : integer;

    SmoothAzimuth: Boolean;

    /// COLORS
    RoutesColor, BackGroundColor, LinesColor,
    ChoosedColor, TrackColor, MenuChoosedColor, Dop1Color, RouteOKColor,
    IntColor, DoneColor, CurColor : Cardinal;

    DopFat: byte;
    MaxDotsVisible : Integer;

    MaxHgtL, MaxHgtR,  MinHgtL, MinHgtR, MaxSpd : Integer;

    EmulSpeed: Integer;

    BigCur, BigText, CountAz: Boolean;

    RecieveList, RecieveList2 :TStringList;

    AutoOn : boolean;
    AutoM : array [1..9] of Integer;

    TurnPoints:array [0..64] of TMyPoint;
    TPCount : Integer;

    MinR, MaxR : Integer;

    MapMode : Integer;

    MyZone : Integer;
    Azimuth, Az : Double;

    GeoidR, GeoidH, H : real;

    ComSpd1, ComSpd2 : Integer;

    
    ShowFPS : boolean;

    Smooth, CropRoutes, Optimized : Boolean;

    RouteStep : integer;
    RouteMaxDist,  MinDistToCurrent : integer;

    GPSProt, COMProt: integer;

    HideTrack : boolean;

    OpenGL : boolean;

    MinDistToFix :integer;

    const DJ: array[1..12] of Integer = (1, 2, 4, 8, 16, 32, 64,
                                          128, 256, 512, 1024, 2048);

    var JoyKeyPress : array [1..12] of Boolean;
        JoyResetN : integer;

    JCom : Array [1..9] of Integer;
    { Public declarations }
  end;

const
  SmoothScale = true;
  SmartCount = 7;
var /// Info

  SatCount, CurTime, CurX, CurY, CurB, CurL, CurOdo, CurTrip,
  CurHgt, CurHgt2, CurHgt3, CurDOP, CurGeoHGT, CurDGeo :String;
  Panel1CursorX, Panel1CursorY : Integer;

  ChangeAutoM: boolean;

  FromBegin: boolean;

  AskMark : integer;

  GpsLogFileName, _GPSLogFileName, ReportFileName,
  Report2FileName, TrackFileName :String;

  CurrentRoute : Integer =-1;
  PrevRoute    : Integer =-1;
  NextRoute    : Integer =-1;

  WGS: Integer;
  SK:  Integer;

  AfterEnd, BeforeBegin : Boolean;

  LocalR1 : integer = -1;
  LocalR2 : integer = -1;
  
  HideArrow : Boolean;

  ReflyCurrent : Boolean = false;
  RouteAsk : integer;
  AskForNext : Boolean;

  NearestDist, NearestRoute : Integer;
  AzimuthToRoute : Double;

  RouteProgress: Integer;

  WorstDist : Boolean;

  AllowAuto: Boolean;

  DistToCurrent, DistToNext, DistToBase :Integer;
  CurrentTime, LastFollowedTime : Real;

  ShowNext : boolean;
  ShowNextTime : real;

  Follow : boolean;

  AzimuthToNearest, AzimuthToCurrent, AzimuthToBase, CurrentRouteAngle : Double;

  VYShift : Integer;

  ShowCurXY : boolean = false;

  SumDist : Double = 0;
  NumDist : Integer = 0;
  NumBadHgt : Integer = 0;
  BadDist : Boolean = false;

  BackStep : Boolean = false;

  LagCount: Single;

//------------ИННОКЕНТИЙ

  var

  MShiftX, MShiftY, MShiftY0 : Integer;
  ScrollMenu, TapOnMenu : Boolean;

  const

  MinDist: integer = 50;
  MinDotDist: integer = 10;

  MenuW = 200;
  LogsMax = 100;
  MaxLogSize = 50000;

  Type TAUXProt = Record
    RName, LName : String;
    RSepN, LSepN : Integer;
    RSep, LSep : string;
    RDataType, LDataType : integer;
    RParN, LParN : Integer;
    LCoef, RCoef : Single;
  End;  

  Type TTrackRecord =  Record
    Flag    : Boolean ;
    Crack   : Boolean;
    Time    : Real;
    TimeString : String;
    Lat     : Double ;
    Long    : Double ;
    mZone   : Integer;
    mUTM    : Boolean;
    x, y    : Double ;
    h, hg   : Double ;
    hl, hr  : Integer;
    Lx, Ly  : Double ;
    OdoMr   : Double;
    RouteNm : String;
    RDist    : Integer;
    RProgress : Integer;
  end ;


  Type TRoute = record
    Name : String; // Array [0..20] of Char ;
    Status : byte; /// 0 -undone, 1- Current, 2 - Done good, 3 - Done bad.
    AverageDist : double;
    badHgts : integer;
    StartTime, EndTime, RLabel :string;
    //Flag : Boolean;
    Geo : Boolean;
    x1, x2 : double;
    y1, y2 : double;
    Gx1, Gx2 : double;
    Gy1, Gy2 : double;
    Gz1, Gz2 : double;
  end ;

  TMap = Record
      imgN : integer;
      imgName : String;
      x,y : array [1..4] of Double;
      Gx,Gy : array [1..4] of Double;
  end ;

  Var Route : Array [0..2000] of TRoute ;
      RouteCount : Integer ;

 const
     MaxDotsCount = 1000000;

 {var SizePVPP : Integer ;
     Pv_PP : Array [0..MaxDotsCount] of TPV_PP ;   }

 Var
    SizeTrackRecord : Integer ;
    TrackRecord : Array [0..MaxDotsCount] of TTrackRecord ;
    StepTrackRecord : Double = 0.1;

    OpenPort1 : Boolean = false;
    OpenPort2 : Boolean = false;

 var CurrentS : String;
    Gx : double;
    Gy : double;
    OldGx : double;
    OldGY : Double;

    Speed : Double;

    Odometr   : Double;
    Trip   : Double;

    Mashtab : Integer;

    EmulProgress : Double;
    OldEmulProgress : Integer;

//---------------------------------------------------------------------------

var
  MainForm: TMainForm;

  ChoosedMenu :integer;

  SmartN, SmartY, SmartKeyY :integer;
  SmartX : real;
  inSmart : Boolean;

  AUXProt : TAUXProt;

  HAGR, HAGL, _HAGL, _HAGR : Real;

  MenuN, MenuScroll, MenuScroll0 : integer;
  _MenuScroll : Double;

  JustStarted : boolean;

  Scale  :Double =1;
  _Scale  :Double =1;



  Frame, FrameGeo : boolean;
  FrameCount : Integer;
  FrameFile : String;

  MapList : Array of TMap;
  
//---------------------------------------------------------------------------
implementation
uses
 Vectors2, Vectors2px, AsphyreTimer, AsphyreFactory, AsphyreTypes, AsphyreDb,
 AbstractDevices, AsphyreImages, AsphyreFonts, DX9Providers, RTypes,
 AbstractCanvas, Unit1, Unit3, Unit2, OGLProviders, LoadData, LRList, NewMark,
  RUnit;
{$R *.dfm}

//---------------------------------------------------------------------------

  type TPosAndDist = record
      Pos, Dist, DistTo0, x, y :Double;
  end;

function GetPosAndDist(xb, yb, xe, ye, x, y: double): TPosAndDist;
var x1, y1, x2, y2, _x, _y, t, c, _y0: Double;
begin
  Result.Dist := 0;
  Result.Pos := 0;
  try
     x1 := xb;
     x2 := xe;
     y1 := yb;
     y2 := ye;

     if x1=x2 then
     begin
       _y := y;
       _x := x1;
        c := (_y - y1) / (y2 - y1);
     end
        else
     if y1=y2 then
     begin
       _y := y1;
       _x := x;
        c := (_x - x1) / (x2 - x1);
     end
        else
     if abs(x2-x1)>abs(y2-y1) then
     Begin
       t :=  (y2-y1)/(x2-x1);
       c := 1/t;

       _y0 := c*(x-x1) + (y-y1);

       _x := x1 + (  _y0/(t+c) );
       _y := y1 + ( t*(_x-x1) );

      

        c := (_x - x1) / (x2 - x1);
     End
        else
          Begin
            t := (x2-x1)/(y2-y1);
            c := 1/t;

            _y0 := (x-x1) + c*(y-y1);

            _y := y1 + (  _y0/(t+c) );
            _x := x1 + ( t*(_y-y1) );

            c := (_y - y1) / (y2 - y1);
          End;

     Result.x := _x;
     Result.y := _y;
     Result.Pos  := c;
     Result.Dist := SQRT(SQR(x-_x)+SQR(y-_y));
     Result.DistTo0 := c*SQRT(SQR(x2-x1)+SQR(y2-y1));
  except
    Result.Dist := 0;
  end;


end;

{Type TMyPoint = Record
       x, y : Double;
     end; }

function TMainForm.GetNormalPt(xb, yb, xe,ye, x, y: double; isRight: boolean; Dist: double): TMyPoint;
var
  a : double;
  PD :TPosandDist;
begin

   try
    PD := GetPosAndDist(xb, yb, xe, ye, x, y);
    a := arctan2(xe-xb,ye-yb);

    if isRight then
      a := a + pi/2
      else
        a:= a - pi/2;

     Result.x := PD.x + sin(a)*Dist;
     Result.y := PD.y + cos(a)*Dist;

   except
   end;

end;


function GetCols(str: string; ColN, ColCount:integer; Spc:byte): string;
var j,stl,b :integer;
    sep :String;
begin
   result:='';
   stl:=0;
   b:=1;
   sep:=' ';

   Case Spc of
     0: sep:=' ';
     1: sep:=#$9;
     2: sep:= LoadRData.Spacer.Text[1];
     3: sep:=';';
     4: sep:=',';
   end;

   for j:=1 to length(Str)+1 do
   Begin

     if ((copy(Str,j,1)=sep)or(j=length(Str)+1))and(copy(Str,j-1,1)<>sep) then
     begin

       if (stl>=ColN) and (Stl<ColN+ColCount) then
       Begin
        if result='' then
          Result:=(Copy(Str,b,j-b))
            else
              Result:=Result+' '+(Copy(Str,b,j-b));
       End;

       inc(stl);
       b:=j+1;

       if stl>ColN+ColCount then
          break;
     end;

  End;

  if result <> '' then
    for j:= 1 to length(Result)+1 do
        if ((result[j] = '.') or (result[j] = ','))and(result[j]<>sep) then
           result[j] := DecimalSeparator;
end;


function CopToStr ( var cc ): String ;      {ИННОКЕНТИЙ}
var c : Array [0..1000] of char absolute cc ;
    i : Integer ;
    s : string ;
begin
       i := 0;
       s := '' ;
       while c[i] <> #0 do
          begin
             s := s + c[i];
             i := i +1;
          end ;
       CopToStr := s;
end;

procedure StrLong ( Data : int64; var str : String );   {ИННОКЕНТИЙ}
var s, s1 : string ;
       fl : boolean;
begin
    s := '';
    fl := FALSE ;
    repeat
      system.Str ( Data mod 1000, s1 );
      while Length ( s1 ) <3 do s1 := '0'+s1;
      IF FL THEN
            s := s1 + '.'+s
        ELSE s := s1 ;
      Data := Data div 1000;
      FL := TRUE ;
    until Data <1000;
      system.str ( data, s1 );
      while Length ( s1 ) <3 do s1 := '0'+s1;
      s := s1 + '.'+s;
     str := s ;
 end;

function DecChar(c :Char) :Integer;  {ИННОКЕНТИЙ}
begin
  DecChar := Ord (c) - Ord ('0');
end;

function HexToInt(Value: String): LongInt;
var
  L : Longint;
  B : Byte;
begin
  Result := 0;
  if Length(Value) <> 0 then
  begin
    L := 1;
    B := Length(Value) + 1;
    repeat
      dec(B);
      if Value[B] <= '9' then
        Result := Result + StrToInt(Value[B]) * L
      else
        Result := Result + (Ord(Value[B]) - 65) * L;
      L := L * 16;
    until B = 1;
  end;
end;

function ExecuteFile(const FileName, Params, DefaultDir: string; ShowCmd: Integer): THandle;
begin
  if fileexists(FileName) then
    Result := ShellExecute(Application.MainForm.Handle, nil, PChar(FileName), PChar(Params),
      PChar(DefaultDir), ShowCmd);
end;

procedure TMainForm.CheckNearestMarkers(X, Y: Integer);
var I :Integer;
begin
  PopupMenu1.Items[2].Visible := false;
  for i := 0 to MarkerCount - 1 do
   if (X > Markers[i].iX-20) and (X < Markers[i].iX+20) then
    if (Y > Markers[i].iY-20) and (Y < Markers[i].iY+20) then
    begin
      AskMark := i;
      PopupMenu1.Items[2].Visible := true;
      PopupMenu1.Items[2].Caption := Inf[57]+'"'+Markers[I].Caption+'"';
      break;
    end;
end;

procedure TMainForm.ClearGPS;
begin
   SaveTrack;
   SizeTrackRecord := 0;

   SatCount := ''; CurB:= ''; CurL:= ''; CurOdo:= '';
   CurTime:= '';   CurX:= ''; CurY:= ''; CurTrip:= '';
   CurGeoHgt:= ''; CurHgt:= '-';  CurDGeo:= ''; 
   CurDOP:= '';  CurHgt2:= '-'; CurHgt3:= '-';

   HAGL := 0;
   HAGR := 0;
   _HAGR := 0;
   _HAGL := 0;

   Center.x := 0;
   Center.y := 0;
end;

procedure TMainForm.CommPort2DriverReceiveData(Sender: TObject;
  DataPtr: Pointer; DataSize: Integer);
var p: pchar;
    s: string;
    i: integer;
begin

  // Get current line
  if RecieveList2.Count <> 0 then
    s := RecieveList2[RecieveList2.Count-1]
  else
    s := '';
  // Parse incoming text
  p := DataPtr;
  while DataSize > 0 do
  begin
    case p^ of
      #10:; // LF
      #13: // CR - cursor to next line
        begin
          if RecieveList2.Count <> 0 then
             RecieveList2[RecieveList2.Count-1] := s
          else
          begin
            RecieveList2.Add( s );
          end;
          RecieveList2.Add( '' );

            if RecieveList2.Count > 1 then
              AUXBuffer.Add(RecieveList2[RecieveList2.Count-2]);

            if RecieveList2.Count>10 then RecieveList2.Clear;

          s := '';
        end;
      #8: // Backspace - delete last char
        delete( s, length(s), 1 );
      else // Any other char - add it to the current line
        s := s + p^;
    end;
    dec( DataSize );
    inc( p );
  end;
  // If current line isn't empty
  if (s<>'') then
    if RecieveList2.Count <> 0 then
      // Update current line
      RecieveList2[RecieveList2.Count-1] := s
    else
    begin
      // New line - add it
      RecieveList2.Add( s );
    end;

  if (RxMemo2.Visible)or(ConTestForm.Visible) then
  Begin
    RxMemo2.Clear;
    for i := 0 to RecieveList2.Count - 1 do
      RxMemo2.Lines.Add(RecieveList2[i]);
      RxMemo2.Update;
  End;
end;

procedure TMainForm.CommPortDriverReceiveData(Sender: TObject;
  DataPtr: Pointer; DataSize: Integer);
var p: pchar;
    s: string;
    i: integer;
begin
  // Get current line
  if RecieveList.Count <> 0 then
    s := RecieveList[RecieveList.Count-1]
  else
    s := '';
  // Parse incoming text
  p := DataPtr;
  while DataSize > 0 do
  begin
    case p^ of
      #10:; // LF
      #13: // CR - cursor to next line
        begin
          if RecieveList.Count <> 0 then
            RecieveList[RecieveList.Count-1] := s
          else
          begin
            RecieveList.Add( s );

          end;
          RecieveList.Add( '' );

            if RecieveList.Count > 1 then
              GPSBuffer.Add(RecieveList[RecieveList.Count-2]);

            if RecieveList.Count>10 then RecieveList.Clear;

          s := '';
        end;
      #8: // Backspace - delete last char
        delete( s, length(s), 1 );
      else // Any other char - add it to the current line
        s := s + p^;
    end;
    dec( DataSize );
    inc( p );
  end;
  // If current line isn't empty
  if (s<>'') then
    if RecieveList.Count <> 0 then
      // Update current line
      RecieveList[RecieveList.Count-1] := s
    else
    begin
      // New line - add it
      RecieveList.Add( s );
    end;

  if (RxMemo.Visible)or(ConTestForm.Visible) then
  Begin
    RxMemo.Clear;
    for i := 0 to RecieveList.Count - 1 do
      RxMemo.Lines.Add(RecieveList[i]);
      RxMemo.Update;
  End;

end;

procedure TMainForm.ConnectCOM(ComPortDriver : TCommPortDriver);
begin
 // Apply settings
  if ComPortDriver = ComPort1 then
     OpenPort1 := false
       else
         OpenPort2 := false;

  if ComPortDriver = ComPort2  then
    if (EnableCom2 = false) and not (ConTestForm.Visible) then
       exit;
  

  ApplyCommSettings(ComPortDriver);
  // Connect
  if ComPortDriver.Connect then
  begin
   // OpenPort := true;

   if ComPortDriver = ComPort1 then
     OpenPort1 := true
       else
         OpenPort2 := true;

   try
    Odometr := StrToFloat(Odo[0]);
   except
     Odometr := 0;
   end;

  end
  else
    begin
       // Error !
    end;
end;

procedure TMainForm.CrackDot(x, y: Double; Col: Cardinal);
begin
  if (x > 0) and (y > 0) and (X <(DisplaySize.X - MenuW)) and (y < DisplaySize.y) then
  Begin
       AsphCanvas.UseImagePx(AsphImages.Image['dot.image'], pxBounds4(0, 0, 8, 8));
       AsphCanvas.TexMap(pRotate4c(Point2(x,y),Point2(8, 8), 0),cColor4(Col));

  End;
end;

procedure TMainForm.CurToNextDist;
var PD : TPosAndDist;
begin
  DistToNext := 0;

  if (CurrentRoute>-1)and(CurrentRoute < RouteCount) then
    if (NextRoute>-1)and(NextRoute < RouteCount) then
    begin
       PD := GetPosAndDist(Route[CurrentRoute].x1,Route[CurrentRoute].y1,
                      Route[CurrentRoute].x2,Route[CurrentRoute].y2,
                     (Route[NextRoute].x1+Route[NextRoute].x2)/2,
                     (Route[NextRoute].y1+Route[NextRoute].y2)/2);

      {DistToNext := Round( Sqrt ( Sqr( (Route[CurrentRoute].x1+Route[CurrentRoute].x2)/2
                     - (Route[NextRoute].x1+Route[NextRoute].x2)/2) +
                     Sqr( (Route[CurrentRoute].y1+Route[CurrentRoute].y2)/2
                     - (Route[NextRoute].y1+Route[NextRoute].y2)/2)));}


      DistToNext := round(PD.Dist);
    end;

                     

end;


procedure TMainForm.CutLineByBufferedFrame(var x, y, x2, y2: Double);
const
 bx = 1024;
 by = 1024;
begin
  if not( (x < 0 - bx) and (x2 < 0 - bx)) then
  if not( (x > (DisplaySize.X + bx)) and (x2 > (DisplaySize.X + bx))) then
  if not( (y < 0 - by) and (y2 < 0 - by)) then
  if not( (y > DisplaySize.y + by) and (y2 > DisplaySize.y + by)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
    if x < 0 - bx then
    begin
      if abs(x2-x) > 0 then
        y := round( ((-bx-x)/(x2-x))*(y2-y)+y)
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0 - bx;
    end
      else
       if x > (DisplaySize.X) + bx then
       begin
          if abs(x2-x) > 0 then
              y := round((((DisplaySize.X)+bx-x)/(x2-x))*(y2-y)+y)
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X) + bx;
       end;

    if x2 < 0 - bx then
    begin
      if abs(x2-x) > 0 - bx then
        y2 := round(((-bx-x)/(x2-x))*(y2-y)+y)
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0 - bx;
    end
      else
       if x2 > (DisplaySize.X)+bx then
       begin
          if abs(x2-x) > 0 then
              y2 := round((((DisplaySize.X)+bx-x)/(x2-x))*(y2-y)+y)
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X) + bx;
       end;

    if y < 0 - by then
    begin
      if abs(y2-y)>0 then
          x := round(((-by-y)/(y2-y))*(x2-x)+x)
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0 - by;
    end
      else
       if y > DisplaySize.y + by then
       begin
          if abs(y2-y) > 0 then
               x := round(((DisplaySize.y+by-y)/(y2-y))*(x2-x)+x)
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y + by;
       end;

   if y2 < 0 - by then
    begin
      if abs(y2-y) > 0 then
          x2 := round(((-by-y)/(y2-y))*(x2-x)+x)
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0 - by;
    end
      else
       if y2 > DisplaySize.y + by then
       begin
          if abs(y2-y) > 0 then
               x2 := round(((DisplaySize.y+by-y)/(y2-y))*(x2-x)+x)
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y + by;
       end;
  End;
end;

procedure TMainForm.CutLineByFrame(var x, y, x2, y2 : Double);
begin
  if not( (x < 0) and (x2 < 0)) then
  if not( (x > (DisplaySize.X - MenuW)) and (x2 > (DisplaySize.X - MenuW))) then
  if not( (y < 0) and (y2 < 0)) then
  if not( (y > DisplaySize.y) and (y2 > DisplaySize.y)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
    if x < 0 then
    begin
      if abs(x2-x) > 0 then
        y := round( ((-x)/(x2-x))*(y2-y)+y)
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0;
    end
      else
       if x > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y := round((((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y)
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X - MenuW);
       end;

    if x2 < 0 then
    begin
      if abs(x2-x) >0 then
        y2 := round(((-x)/(x2-x))*(y2-y)+y)
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0;
    end
      else
       if x2 > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y2 := round((((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y)
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X - MenuW);
       end;

    if y < 0 then
    begin
      if abs(y2-y)>0 then
          x := round(((-y)/(y2-y))*(x2-x)+x)
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0;
    end
      else
       if y > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x := round(((DisplaySize.y-y)/(y2-y))*(x2-x)+x)
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y;
       end;

   if y2 < 0 then
    begin
      if abs(y2-y) > 0 then
          x2 := round(((-y)/(y2-y))*(x2-x)+x)
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0;
    end
      else
       if y2 > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x2 := round(((DisplaySize.y-y)/(y2-y))*(x2-x)+x)
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y;
       end;
  End;

end;

procedure TMainForm.AddMarker(Mname: string; mB, mL: Double);
begin
///
  if MarkerCount<1000 then
     Inc(MarkerCount);

  Markers[MarkerCount-1].B := mB;
  Markers[MarkerCount-1].L := mL;

  Markers[MarkerCount-1].Caption := mName;

  RefreshMarkerList;
end;


procedure TMainForm.AnalyseAUXStr(s: String; AddToLog: boolean);
var
   s1 : String ;
   i, j  : integer;
begin

   //// 1. Radio
   if (Settings.isRadio.Checked)or((RealTime=false)and(Settings.ContainAUX.Checked)) then
     if Pos( AUXProt.RName, s ) > 0 then
     begin
             s1 := s ;
             i := Pos (AUXProt.RName, s1 );
             delete (s1, 1, i+length(AUXProt.RName)-1 );

             for j := 1 to AUXProt.RParN-1 do
             begin
               i := Pos (AUXProt.RSep, s1);
               delete (s1, 1, i );
             end;
             i := Pos (AUXProt.RSep, s1);

             if i<>0 then
                s1 := copy(s1, 1, i-1);

             try
               case AUXProt.RDataType of
                 0: HAGR := StrToFloat2(s1);
                 1: HAGR := HexToInt(s1);
               end;

               HAGR := HAGR * AUXProt.RCoef;

               CurHgt2 := IntToStr(round(HAGR));
               if not(BigText) then
                  CurHgt2 := CurHgt2 + inf[20];
             except
               CurHgt2 := '-';
             end;

             if AddToLog then
               GPSLog.Add(s);
         end;

   if (Settings.isLaser.Checked)or((RealTime=false)and(Settings.ContainAUX.Checked)) then
     if Pos( AUXProt.LName, s ) > 0 then
     begin
             s1 := s ;
             i := Pos (AUXProt.LName, s1 );
             delete (s1, 1, i+length(AUXProt.RName)-1);

             for j := 1 to AUXProt.RParN-1 do
             begin
               i := Pos (AUXProt.LSep, s1);
               delete (s1, 1, i );
             end;
             i := Pos (AUXProt.LSep, s1);

             if i<>0 then
                s1 := copy(s1, 1, i-1);

             try  
               i := round(Hagl);
               
               case AUXProt.LDataType of
                 0: HAGL := StrToFloat2(s1);
                 1: HAGL := HexToInt(s1);
               end;

               HAGL := HAGL * AUXProt.LCoef;

               if Hagl>2.5 then
               Begin
                  CurHgt3 := IntToStr(round(HAGL));
                  if not(BigText) then
                    CurHgt3 := CurHgt3 + inf[20];
               End
                 else HagL := i;
                 
             except
               CurHgt3 := '-';
             end;

             if AddToLog then
               GPSLog.Add(s);
         end;

end;

procedure TMainForm.AnalyseStr(s: String);
var
   s1, s2, s3, s4, s5 : String ;
   i :Integer ;
   T : real;
   Buf1, Buf2 :Double ;
   x, y :Double ;
   DL :Double ;
   STime, St :String ;
   _w, _s :boolean;
   Prot :integer;
begin
  if RealTime then
     Prot := COMProt
      else
         Prot := GPSProt;
  try

     case Prot  of
        0:   ///////////////////// NMEA183
        BEGIN
        
            if (Pos ( 'RMC',S ) > 0) then
            begin
                 s1 := s ;
                 i := Pos ( ',',s1 );
                 delete ( s1,1, i );
                 i := Pos ( 'E', s1 );
                 if i=0 then
                    i := Pos ( 'W', s1 );
                 delete ( s1,1, i+1 );
                 i := Pos ( ',', s1 );

                 if not CountAz then
                 begin
                    s2 := copy(s1,i+1,length(s1)-i);
                    i := Pos ( ',', s2 );
                    SetLength ( s2, i-1 );
                    Az := StrToFloat2(s2)*pi/180;
                    i := Pos ( ',', s1 );
                 end;

                 SetLength ( s1, i-1 );

                 Val ( s1, Speed , i );
                 Speed := Speed *1.852;

                 if Speed  > 1 then
                 begin
                      if (Abs ( Gx - OldGx ) < 1000) and
                         (Abs ( Gy - OldGy ) < 1000) then
                        begin
                                dl :=  sqrt ( (OldGx - gx)*(OldGx - gx) +
                                              (OldGy - Gy)*(OldGy- Gy));
                               if dl < 1 then Dl := 0;
                               OldGx := Gx ;
                               OldGy := Gy ;
                        end
                          else
                           begin
                             DL := 0;
                             OldGx := Gx ;
                             OldGy := Gy ;
                            end ;


                          Odometr := Odometr +dl ;
                          Trip := Trip + Dl ;

                          Str ( Odometr/1000 : 10:1, s1 );
                          CurOdo := s1 + inf[25];

                          Str ( Trip/1000 : 10:1, s1 );
                          CurTrip := s1 + inf[25];

                        end ;
                 end
                   else
                     begin
                        Str ( Odometr/1000 : 10:1, s1 );
                        CurOdo := s1 + inf[25];
                        Str ( Trip/1000 : 10:1, s1 );
                        CurTrip := s1 + inf[25];
                     end ;
       
            {if not CountAz then
              if (Pos ( 'VTG',s ) > 0) then
              begin
                 s1 := s ;
                 i := Pos ( ',',s1 );
                 delete ( s1,1, i );
                 i := Pos ( ',',s1 );
                 s2 := Copy(s1,1,i-1);
                 Az := StrToFloat2(s2)*pi/180;
              end;   }

            if Pos( 'GGA', s ) > 0 then
            begin
                s1 := s ;
                i := Pos (',', s1 );
                delete (s1, 1, i );

                T := DecChar(S1[1]);
                T := T*10 + DecChar(S1[2]);
                T := T*60 + DecChar(S1[3])*10;
                T := T  + DecChar(S1[4]);
                T := T*60 + DecChar(S1[5])*10;
                T := T + DecChar(S1[6]);
                T := T + DecChar(S1[8])*0.1;
                T := T + DecChar(S1[9])*0.01;
                s2 := s1 ;
                SetLength(s2, 9);
                STime := s2;

                CurTime := Copy(s2,1,2)+':'+Copy(s2,3,2)+':'+Copy(s2,5,length(s2)-5);
                i := Pos (',', s1 );
                delete (s1, 1, i );
                i := Pos (',', s1 );
                s2 := s1;
                setlength ( s2, i-1 );
                Val ( s2, Buf1, i );

                if Length ( s2 ) < 9 then
                  exit ;
                if i <> 0 then
                  exit;

                S3  := s2;

                i := Pos (',', s1 );
                delete (s1, 1, i );


                if (S1 [1] <> 'N') and (S1 [1] <> 'S') then
                   exit ;

                _s := (S1 [1] = 'S');
                i := Pos (',', s1 );
                delete (s1, 1, i );

                i := Pos (',', s1 );
                s2 := s1;
                setlength ( s2, i-1 );
                Val ( s2, Buf2, i );

                if i <> 0 then
                  exit ;

                i := Pos (',', s1 );
                delete (s1, 1, i );

                if Length ( s2 ) < 10 then
                   exit ;
                if (S1 [1] <> 'E') and (S1 [1] <> 'W') then
                   exit ;

                _w := (S1 [1] = 'W');
                delete ( s1, 1,pos (',', s1)) ;
                delete ( s1, 1, pos (',', s1)) ;
                s4 := s1 ;
                setlength ( s4, Pos ( ',',s4 )-1);

                SatCount := s4;
                if Satcount[1]='0' then
                begin
                   Satcount[1] := ' ';
                   Satcount := ' ' + Satcount;
                end;

                delete ( s1, 1, pos (',', s1)) ;
                s4 := s1 ;
                setlength ( s4, Pos ( ',',s4 )-1);
                CurDOP := Copy(s4,1,3);

                if Pos('.',CurDop)=3 then
                begin
                  if StrToFloat2(s4)>=10 then
                    CurDOP := Copy(s4,1,2)
                      else
                      CurDOP := Copy(s4,2,3)
                end;

                delete ( s1, 1, pos (',', s1)) ;
                s4 := s1 ;
                setlength ( s4, Pos ( ',',s4 )-1);
                CurHgt := s4;

                delete ( s1, 1, pos (',', s1)) ;
                s4 := s1 ;
                setlength ( s4, Pos ( ',',s4 )-1);
                s5:= s4;

                delete ( s1, 1, pos (',', s1)) ;
                s4 := s1 ;
                setlength ( s4, Pos ( ',',s4 )-1);
                GeoidR := StrToFloat2(s4);
                H :=  StrToFloat2(CurHgt);
                GeoidH := GeoidR + H;
                CurDGeo := s4;
                CurGeoHgt :=  format('%n',[GeoidH]);

                if s5='M' then
                begin
                  if not(BigText) then
                    CurHgt := CurHgt + inf[20]
                     else
                       CurHgt := IntToStr(round(H));

                  CurGeoHgt := CurGeoHgt +inf[20];
                  CurDGeo := ' ('+CurDGeo+inf[20]+')';
                end;

                S4 := s2 ;

                Buf1 := Buf1 / 100 ;
                Buf2 := Buf2 / 100 ;
                Buf1 := Trunc ( Buf1 ) + (Buf1 - Trunc( Buf1) )/0.6 ;
                Buf2 := Trunc ( Buf2 ) + (Buf2 - Trunc( Buf2) )/0.6 ;

                if _s then
                    Buf1 := -Buf1;
                if _w then
                    Buf2 := -Buf2;

                CurB := DegToDMS(Buf1,4);
                CurL := DegToDMS(Buf2,4);

                if (Buf1 > 180) or ( Buf2 > 180) then
                    exit ;

                if T > 24910 then
                    Gx  := 20;

                if UTM then
                     GeoToUTM(WGS,Buf1,Buf2,South,y,x, Myzone, WaitForZone)
                        else
                           WGSToSK (Buf1, Buf2, 0, x, y, MyZone, WaitForZone);

                Gx := x ;
                Gy := y ;

                CurX := format('%n',[x]);
                CurY := format('%n',[y]);
                
                if (x<>0)and(y<>0) then
                begin
                   AppendPoint (T , x, y, Buf1, Buf2, H, GeoidH, true);
                        if WaitForZone then
                        begin
                           ReComputeRoutes(False);
                           ReComputeTracks(False);
                           ReComputeMaps(False);
                           WaitForZone := false ;
                        end;
                end;

            end;   ////////////

        END;   /////////////// ----------------------- NMEA 183 END


        1: BEGIN
        END;

      end;

      
      if Settings.ContainAUX.Checked then
        AnalyseAUXStr(CurrentS, false);

  except
  end;
end;

procedure TMainForm.AppendPoint(T: real; x, y, Sh, Dol, h1, h2: double; fl: Boolean);
var I, Rd, Rp :Integer;
    StepT: double;
    CurRoute : string;
begin
  CurrentTime :=-1;

  if Optimized then
  if SizeTrackRecord > 2 then
  Begin
      if ((MapMode<3)or(MapMode>5)) then
       // or ((MapMode>=2)and(MapMode<=5)and((BeforeBegin)or(AfterEnd))) then
       if (abs(TrackRecord[SizeTrackRecord -1].x-x) < MinDotDist)and
          (abs(TrackRecord[SizeTrackRecord -1].y-y) < MinDotDist) then
          exit;

          
  End;

  CurRoute := '---';
  Rd := 0;
  Rp := 0;
  if not Realtime then
  Begin
    if Follow then
     if CurrentRoute>=0 then
     try
       Rd := round(GetDistToRoute(CurrentRoute,x,y)*10);
                   
       if not (BeforeBegin or AfterEnd) then
       begin
         if not ReFlyCurrent then
         Begin
           CurRoute := Route[CurrentRoute].Name;
           RP := RouteProgress;
         End;
       end
        else
          Rd := 0;
     except
        Rd := 0;
     end;
  End;

  if SizeTrackRecord = 0 then
                 begin
                      TrackRecord [0].Flag := fl ;
                      TrackRecord [0].Time  := t ;

                      TrackRecord [0].RouteNm := CurRoute;
                      TrackRecord [0].RProgress := RP;
                      TrackRecord [0].RDist := Rd;
                      TrackRecord [0].Lat := Sh ;
                      TrackRecord [0].Long := Dol ;
                      TrackRecord [0].OdoMr := Trip ;
                      TrackRecord [0].mZone := MyZone;
                      TrackRecord [0].x := x;
                      TrackRecord [0].y := y ;
                      TrackRecord [0].h := h1 ;
                      TrackRecord [0].hg := h2 ;
                      TrackRecord [0].hl := round(hagl);
                      TrackRecord [0].hr := round(hagr);
                      TrackRecord [0].mUTM := UTM ;
                      TrackRecord [0].Crack := false;
                      SizeTrackRecord := 1;
                      if Settings.BaseEnter.ItemIndex = 0 then
                         PutBaseHere(Sh, Dol);
                      Trip := 0;
                  end
                 else
                   if SizeTrackRecord < MaxDotsCount-1 then
                    begin
                       if Abs ( t - TrackRecord[SizeTrackRecord -1].Time) < StepTrackRecord
                                then exit ;

                        StepT := 10;
                        if SizeTrackRecord > 1 then
                           StepT := Abs(TrackRecord[SizeTrackRecord -2].Time
                                    - TrackRecord[SizeTrackRecord -1].Time)*2;

                        TrackRecord [SizeTrackRecord].RouteNm := CurRoute;
                        TrackRecord [SizeTrackRecord].RDist := Rd;
                        TrackRecord [SizeTrackRecord].RProgress := RP;
                        TrackRecord [SizeTrackRecord].Flag := Fl ;
                        TrackRecord [SizeTrackRecord].Time  := t ;
                        TrackRecord [SizeTrackRecord].Lat := Sh ;
                        TrackRecord [SizeTrackRecord].Long := Dol ;
                        TrackRecord [SizeTrackRecord].OdoMr := Trip ;
                        TrackRecord [SizeTrackRecord].mZone := MyZone;
                        TrackRecord [SizeTrackRecord].x := x;
                        TrackRecord [SizeTrackRecord].y := y ;
                        TrackRecord [SizeTrackRecord].h := h1;
                        TrackRecord [SizeTrackRecord].hg := h2;
                        TrackRecord [SizeTrackRecord].hl := round(hagl);
                        TrackRecord [SizeTrackRecord].hr := round(hagr);
                        TrackRecord [SizeTrackRecord]. mUTM := UTM ;
                        TrackRecord [SizeTrackRecord].Crack := Abs(t-
                                 TrackRecord[SizeTrackRecord -1].Time) > StepT;

                        if SizeTrackRecord > 1 then
                          if not TrackRecord [SizeTrackRecord].Crack then
                            TrackRecord [SizeTrackRecord].Crack :=
                                    Sqrt(sqr(TrackRecord[SizeTrackRecord-1].y-y)
                                    + sqr(TrackRecord[SizeTrackRecord-1].x-x)) > 1000;

                        SizeTrackRecord := SizeTrackRecord + 1;
                     end
                      else
                        begin
                          SizeTrackRecord := MaxDotsCount;
                          for I := 0 to MaxDotsCount-1 do
                             TrackRecord[i]:= TrackRecord[i+1];

                         StepT := 10;
                         if SizeTrackRecord > 1 then
                           StepT := Abs(TrackRecord[SizeTrackRecord -2].Time
                                    - TrackRecord[SizeTrackRecord -1].Time)*2;

                          TrackRecord [SizeTrackRecord].RouteNm := CurRoute;
                          TrackRecord [SizeTrackRecord].RDist := Rd;
                          TrackRecord [SizeTrackRecord].RProgress := RP;
                          TrackRecord [SizeTrackRecord].Flag := Fl ;
                          TrackRecord [SizeTrackRecord].Time  := t ;
                          TrackRecord [SizeTrackRecord].Lat := Sh ;
                          TrackRecord [SizeTrackRecord].Long := Dol ;
                          TrackRecord [SizeTrackRecord].OdoMr := Trip ;
                          TrackRecord [SizeTrackRecord].mZone := MyZone;
                          TrackRecord [SizeTrackRecord].x := x;
                          TrackRecord [SizeTrackRecord].y := y ;
                          TrackRecord [SizeTrackRecord].h := h1;
                          TrackRecord [SizeTrackRecord].hg := h2;
                          TrackRecord [SizeTrackRecord].hl := round(hagl);
                          TrackRecord [SizeTrackRecord].hr := round(hagr);
                          TrackRecord [SizeTrackRecord]. mUTM := UTM ;
                          TrackRecord [SizeTrackRecord].Crack := Abs(t-
                                 TrackRecord[SizeTrackRecord -1].Time) > StepT;
                                 
                          if not TrackRecord [SizeTrackRecord].Crack then
                            TrackRecord [SizeTrackRecord].Crack :=
                                    Sqrt(sqr(TrackRecord[SizeTrackRecord-1].y-y)
                                    + sqr(TrackRecord[SizeTrackRecord-1].x-x)) > 1000;
                        end;
   CurrentTime := T;
   ReCalcWay := true;
end;


function TMainForm.AskJoystic:integer;
var myjoy: tjoyinfo;
begin
   Result := joygetpos(joystickid1,@myjoy);
end;

var OldXPos, OldYPos :Integer;
    Xrepeat, Yrepeat : Integer;
    OldJoyKeyPress : array [1..12] of Boolean = (false, false, false, false, false, false,
                                                 false,false, false, false, false,false);
function TMainForm.AskJoysticKey: integer;
var myjoy : TJoyInfo;
    Bts, I, Status : Integer;
const Rept = 15;
begin
   Status := joygetpos(joystickid1,@myjoy);

   if Status <> JOYERR_NOERROR  then
     exit;
//   if myjoy.wzpos <> 32511 then
//      exit ;

///// ----------------------------- Нажатые кнопки
   for I := 1 to 12 do
     OldJoyKeyPress[i] := JoyKeyPress[i];

   for I := 1 to 12 do
     JoyKeyPress[i] := false;

   Bts := myjoy.wButtons;

   if Bts > 0 then
   for I := 12 Downto 1 do
       if Bts - DJ[i] >= 0 then
       Begin
          Bts := Bts - DJ[i];
          JoyKeyPress[i] := True;
          if Bts = 0 then
            break;
       end;

///// ----------------------------- Нажатые кнопки
   case JoyResetN of
      0: if ( (JoyKeyPress[9])and(JoyKeyPress[10])and
              (JoyKeyPress[7])and(JoyKeyPress[8]) ) and
         not ( (OldJoyKeyPress[9])and(OldJoyKeyPress[10]) and
               (OldJoyKeyPress[7]) and (OldJoyKeyPress[8]) )then
               begin
                 ConnectCOM(ComPort1);
                 ConnectCOM(ComPort2);
               end;
      1:  if ( (JoyKeyPress[1])and(JoyKeyPress[3])and
              (JoyKeyPress[5])) and
         not ( (OldJoyKeyPress[1])and(OldJoyKeyPress[3]) and
               (OldJoyKeyPress[5]))then
               begin
                 ConnectCOM(ComPort1);
                 ConnectCOM(ComPort2);
               end;
      2: if ( (JoyKeyPress[3])and(JoyKeyPress[4])and
              (JoyKeyPress[1])and(JoyKeyPress[2]) ) and
         not ( (OldJoyKeyPress[3])and(OldJoyKeyPress[4]) and
               (OldJoyKeyPress[1]) and (OldJoyKeyPress[2]) )then
               begin
                 ConnectCOM(ComPort1);
                 ConnectCOM(ComPort2);
               end;
   end;

   if (JoyKeyPress[JCom[1]])and not (OldJoyKeyPress[JCom[1]]) then
      MenuKeyCommand(5);

   if (JoyKeyPress[JCom[2]])and not (OldJoyKeyPress[JCom[2]]) then
      MenuKeyCommand(6);

   if (JoyKeyPress[JCom[3]])and not (OldJoyKeyPress[JCom[3]]) then
      if AllowAuto then
         AutoOn := not AutoOn;

   if (JoyKeyPress[JCom[4]])and not (OldJoyKeyPress[JCom[4]]) and
      (JoyKeyPress[JCom[9]])and not (OldJoyKeyPress[JCom[9]]) then
   BEGIN
       ShowInfo := not (ShowInfo);
   END
    Else
    BEGIN
     if (JoyKeyPress[JCom[4]])and not (OldJoyKeyPress[JCom[4]]) then
       Begin
          ShowNext := true;
          ShowNextTime := 100;
       End;

     if (JoyKeyPress[JCom[9]])and not (OldJoyKeyPress[JCom[9]]) then
       Begin
          ShowMaps := not ShowMaps;
          if ShowMaps then
            RecomputeMaps(False);
       End;
    END;

   if (JoyKeyPress[JCom[7]])and not (OldJoyKeyPress[JCom[7]]) then
      Begin
        if MaxDotsVisible = 0 then
        MaxDotsVisible := MaxDotsCount
        else
          if MaxDotsVisible = MaxDotsCount then
            MaxDotsVisible := 1000
              else
                if MaxDotsVisible = 1000 then
                   MaxDotsVisible := 0
      End;
//////

   if JoyKeyPress[JCom[5]] then
   begin
      if OldXPos <> myjoy.wXpos  then
      Begin
        if (myjoy.wXpos < 10000) then
           ShiftMap(4);
        if (myjoy.wXpos>40000 ) then
           ShiftMap(5);
        XRepeat := RepT;
      End;
      if OldYPos <> myjoy.wYpos  then
      Begin
        if (myjoy.wypos<10000) then
           ShiftMap(2);
        if (myjoy.wypos>40000 ) then
           ShiftMap(3);
        YRepeat := RepT;
      End;
   end
    else
     if JoyKeyPress[JCom[6]] then
    begin
       if OldYPos <> myjoy.wYpos  then
       Begin
          if (myjoy.wypos<10000) then
             ShiftMap(1);
          if (myjoy.wypos>40000 ) then
             ShiftMap(0);
          YRepeat := RepT;
       End;
    end
      else
       BEGIN
             if OldXPos <> myjoy.wXpos  then
             Begin
               if (myjoy.wXpos < 10000) then
                   MenuKeyCommand(3);
               if (myjoy.wXpos>40000 ) then
                   MenuKeyCommand(4);
                XRepeat := RepT;
             End;
             if OldYPos <> myjoy.wYpos  then
             Begin
                if (myjoy.wypos<10000) then
                  MenuKeyCommand(1);
                if (myjoy.wypos>40000 ) then
                  MenuKeyCommand(2);
                YRepeat := RepT;
              End;
       END;

   OldXPos := myjoy.wXpos;
   OldYPos := myjoy.wYpos;

   if XRepeat>0 then
      Dec(XRepeat)
       else
        OldXPos := -1;

   if YRepeat>0 then
      Dec(YRepeat)
       else
        OldYPos := -1;

end;

Function GetHDSerNo: shortstring; export;
var VolumeName, FileSystemName : array [0..MAX_PATH-1] of Char; VolumeSerialNo : Cardinal; MaxComponentLength, FileSystemFlags : DWORD;
Begin
  Try
   GetVolumeInformation('C:\',VolumeName,MAX_PATH,@VolumeSerialNo, MaxComponentLength,FileSystemFlags, FileSystemName,MAX_PATH);
   Result:=IntToHex(HiWord(VolumeSerialNo),4)+ '-'+IntToHex(LoWord(VolumeSerialNo),4);
  Except
     result := '745C-F877';
  End;
  result := result+'-3216';
End;

function Generate(ac:string):string;
var i,j:integer;
begin
   result :='';
   for i:= length(ac) Downto 1 do
   begin
     j := i - trunc(i/3)*3;

     if (ord(ac[i])<255-j)and (ac[i]<>'-') then
       result := result + chr(ord(ac[i])+j)
        else
         result := result + ac[i];
   end;
end;

procedure TMainForm.Autorun;
var S, RS:TStringList;
    ShowSets: boolean;
begin

  SmartMenu := true;
//  SmartCount := 6;
  SmartN := 1;
  SmartX := 0;
  
  ShowSets := false;
  Optimized :=true;
  ShowCracks := true;

  InitData;
  InitAutoMode;
  S := TStringList.Create;
  Settings.AcceptButton.OnClick(nil);
  if Fileexists(MainForm.DataDir+'Load.config') then
  try
    {if ParamStr(1)<>'' then
      S.LoadFromFile(ParamStr(1))
      else }

      S.LoadFromFile(MainForm.DataDir+'Load.config');
      if S.Count>2 then
        if s[2]='1' then
          Begin
            BorderStyle := bsNone;
            WindowState := wsMaximized;
            Settings.FScreen.Checked := true;
          End;

      if S.Count>3 then
      if S[3]='1' then
      begin
        ShowFPS := True;
        Settings.FPS.Checked := true;
      end
       else
        begin
            ShowFPS := false;
            Settings.FPS.Checked := false;
        end;

    if S.Count>4 then
      if S[3]='1' then
      begin
        Settings.ShowReport.Checked := true;
      end
       else
           Settings.ShowReport.Checked := false;

     if S.Count>5 then
      if S[4]='1' then
      begin
        Settings.AReport.Checked := true;
      end
       else
           Settings.AReport.Checked := false;

    if S.Count>1 then
      if S[0]='1' then
      begin
        Settings.CFile.Text := S[1];
        Settings.ARun.Checked := true;
        Settings.LoadSettings(S[1]);
        Settings.AcceptButton.OnClick(nil);
      end
      else
      begin
        Timer.Enabled:= False;
        ShowSets := true;
       // Settings.ShowModal;
      end;

  except

  end
   else
      ShowSets := true;

  S.Destroy;


  if Fileexists(MainForm.DataDir+'Reg.config') then
  Begin
    try
      AID := GetHDSerNo;
      SID := Generate(AID);

      RS := TStringList.Create;
      RS.LoadFromFile(MainForm.DataDir+'Reg.config');
        if SID<>RS[0] then
          RegForm.ShowModal;

      RS.Destroy;
    except
       AID := GetHDSerNo; SID := Generate(AID);
       RegForm.ShowModal;
    end
  End
    else
    Begin
       AID := GetHDSerNo; SID := Generate(AID);
       RegForm.ShowModal;
    End;

  if ShowSets then
     Settings.ShowModal;
end;

procedure TMainForm.AxelAzimuth(az2: double);
var step, minstep: double;
begin
  step := 0.05 *Timer.Delta/2;

  if Panel3.Visible then
    step := step * EmulSpeed;


  if Speed < 5 then
     exit;

  if Azimuth > 2*pi then
    Azimuth := Azimuth - 2*pi;
  if Azimuth < 0 then
    Azimuth := Azimuth + 2*pi;

  if Abs(Azimuth-Az2) > pi then
  Begin
    if Az2 > Azimuth then
       Az2 := Az2 - 2*pi
       else
          Az2 := Az2 + 2*pi;
  End;

  minstep := 0.1;   /// ~4 deg

  case trunc(Speed) of
    30..60 :  minstep := 0.05; /// ~2 deg
    61..100:  minstep := 0.01;
    101..255:  minstep := 0;
  end;

  if Abs(Azimuth-Az2) < minstep then
      exit;

  if Abs(Azimuth-Az2) > 4*pi then
    Az2 := Azimuth ;


 { if Abs(Azimuth-Az2) > 5*Step then
  Begin
    if Azimuth > Az2 then
       Azimuth := Azimuth - 5*step
       else
          Azimuth := Azimuth + 5*step;
  End
    else }
    {if Abs(Azimuth-Az2) > 2*Step then
    Begin
      if Azimuth > Az2 then
        Azimuth := Azimuth - 2*step
       else
          Azimuth := Azimuth + 2*step;
    End
     else  }
    if Abs(Azimuth-Az2) > Step then
    Begin
      if Azimuth > Az2 then
        Azimuth := Azimuth - step
          else
            Azimuth := Azimuth + step;
    End
      else
        Azimuth := Az2;

end;

procedure TMainForm.AxelHgts;
var step: Double;
begin
///

  if not SmoothAzimuth then
  Begin
    _HAGR := HAGR;
    _HAGL := HAGL;
    exit;
  End;

  step := Timer.Delta;

  if CurHgt2<>'-' then
  BEGIN
   if round(_HAGR)<> round(HAGR) then
   if Abs(HAGR-_HAGR) > Step then
    Begin
      if _HAGR > HAGR then
        _HAGR := _HAGR - step
          else
            _HAGR := _HAGR + step
    End
      else
         _HAGR := _HAGR;

    if Step>100 then
       _HAGR := HAGR;

    CurHgt2 := IntToStr(round(_HAGR));
    if not(BigText) then
      CurHgt2 := CurHgt2 + inf[20];
  END;

  if CurHgt3<>'-' then
  BEGIN
    if round(_HAGL)<> round(HAGL) then
    if Abs(HAGL - _HAGL) > Step then
    Begin
      if _HAGL > HAGL then
         _HAGL := _HAGL - step
          else
            _HAGL := _HAGL + step
    End
      else
         _HAGL := _HAGL;

    if Step>100 then
       _HAGL := HAGL;

    CurHgt3 := IntToStr(round(_HAGL));
    if not(BigText) then
      CurHgt3 := CurHgt3 + inf[20];
  END;

end;

procedure TMainForm.AxelScale;
const k = 1.5;
var Stp : double;
begin
////
  _Scale  := TMashtab[Mashtab]/100;

  Stp := Timer.Delta;
 /// Caption := FloatTostr(stp);
  if Stp > 5 then
     Stp := 5;
  if Stp < 0.25 then
     Stp := 0.25;

     Stp := 5*k/Stp;

  if Abs((Scale - _Scale)) > _Scale/100 then
  Begin
     if True then
     
     Scale := Scale - (Scale - _Scale)/Stp
  End
     else
        Scale := _Scale;

end;

procedure TMainForm.DelMarker(DelI: integer);
var I:Integer;
begin
  Dec(MarkerCount);
  if MarkerCount>0 then
     for I := DelI to MarkerCount - 1 do
       Markers[I] := Markers[I+1];

  RefreshMarkerList;
end;

procedure TMainForm.DisconnectCOM(ComPortDriver : TCommPortDriver);
begin
  ComPortDriver.Disconnect;
   if ComPortDriver = ComPort1 then
     OpenPort1 := false
       else
         OpenPort2 := false;
 // OpenPort := false;
 // RxMemo.Lines.Add('Disconnected');
end;

procedure TMainForm.DrawArrowToBase;
var xm, ym, fi, dx, dy, w : Double;
    S :String;
    Fnt : Integer;
begin
    if DistToBase =-1 then
      exit;

    if (MapMode > 5)and(MapMode < 8)and(SizeTrackRecord>1) then
       Begin
          xm := TrackRecord [SizeTrackRecord -1].x ;
          ym := TrackRecord [SizeTrackRecord -1].y ;


          fi := -pi + AzimuthToBase;
             if MapModeDoRotate[MapMode] then
             begin
                fi := -pi + AzimuthToBase - Azimuth;
                 if MapMode = 5 then
                    fi := -pi + AzimuthToBase - CurrentRouteAngle;

             end;



          xm := (Center.x - xm)/ Scale ;
          ym := (Center.y - ym)/ Scale ;

          dx := xm * Cos (Fi) + ym * Sin(Fi);
          dy :=-xm * Sin (Fi) + ym * Cos(Fi);

          xm := round ((DisplaySize.X - MenuW) div 2 - dx );
          ym := DisplaySize.y -  round (DisplaySize.y div 2 - dy ) + VYShift;

          if DistToBase > Scale*256 then
             begin
                AsphCanvas.UseImagePx(AsphImages.Image['arrow3.image'], pxBounds4(0, 0, 32, 256));

                AsphCanvas.TexMap(pRotate4c(Point2(xm,
                    ym),
                    Point2(32, 256), fi),
                    cColor4(MenuChoosedColor));//,ChoosedColor,ChoosedColor,ChoosedColor);  }

                S := IntToStr(trunc(DistToBase));
                if  DistToBase>1000 then
                  S := IntToStr(trunc( DistToBase/1000))+inf[25]
                  else
                    S := IntToStr(trunc( DistToBase))+inf[20];

                if BigText then
                begin
                  Fi := Fi + pi/4;
                  Fnt := Font1
                end
                   else
                     Fnt := Font5;

                w := round(AsphFonts[Fnt].TextWidth(s)/2);
                AsphFonts[Fnt].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);
             end;

       End;
end;

function TMainForm.DrawArrowToCurrentRoute: boolean;
var xm, ym, fi, dx, dy, w : Double;
    S :String;
    Fnt :integer;
begin
    Result := false;

    if ShowTP then
      if HideArrow then
      begin
        if not(BeforeBegin or AfterEnd) then
        
        HideArrow := false;
        exit;
      end;

    if (MapMode > 2)and(MapMode < 6)and(SizeTrackRecord>1) then
       Begin
          xm := TrackRecord [SizeTrackRecord -1].x ;
          ym := TrackRecord [SizeTrackRecord -1].y ;

          fi := -pi + AzimuthToCurrent;
          if MapModeDoRotate[MapMode] then
          begin
             fi := -pi + AzimuthToCurrent - Azimuth;
               if MapMode = 5 then
                 fi := -pi + AzimuthToCurrent - CurrentRouteAngle;
          end;

          xm := (Center.x - xm)/ Scale ;
          ym := (Center.y - ym)/ Scale ;

          dx := xm * Cos (Fi) + ym * Sin(Fi);
          dy :=-xm * Sin (Fi) + ym * Cos(Fi);

          xm := round ((DisplaySize.X - MenuW) div 2 - dx );
          ym := DisplaySize.y -  round (DisplaySize.y div 2 - dy ) + VYShift;
          if DistToCurrent > Scale*256 then
          begin
                Result := true;

                AsphCanvas.UseImagePx(AsphImages.Image['arrow3.image'], pxBounds4(0, 0, 32, 256));

                AsphCanvas.TexMap(pRotate4c(Point2(xm,
                    ym),
                    Point2(32, 256), fi),
                    cColor4(ChoosedColor));//,ChoosedColor,ChoosedColor,ChoosedColor);  }

                S := IntToStr(trunc(DistToCurrent));
                if  DistToCurrent>1000 then
                  S := IntToStr(trunc( DistToCurrent/1000))+inf[25]
                  else
                    S := IntToStr(trunc( DistToCurrent))+inf[20];

                if BigText then
                begin
                  Fi := Fi + pi/4;
                  Fnt := Font1
                end
                   else
                     Fnt := Font5;

                w := round(AsphFonts[Fnt].TextWidth(s)/2);
                AsphFonts[Fnt].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);

               { w := round(AsphFonts[Font5].TextWidth(s)/2);
                AsphFonts[Font5].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);//cColor2(ChoosedColor,ChoosedColor));}
          end;

       End;

end;

procedure TMainForm.DrawArrowToNearest;
var fi, xm, ym, dx, dy : Double;
    S : String;
    w, Fnt :integer;
begin
  if AutoOn then
  BEGIN
   if ((MapMode=1) or(MapMode=2)) then
      if Speed < 10 then
      begin
         Mashtab := AutoM[1];
         MapMode := 1 + AutoM[2];
      end
       else
       begin
          Mashtab := AutoM[3];
          MapMode := 1 + AutoM[4];
       end;

     if ((MapMode=6) or(MapMode=7)) then
     if DistToBase<>-1 then
     Begin
      if (Speed < 10)and(DistToBase < 200) then
      begin
         MenuScroll := 0;
         MenuN := 9;
      end
       else
       begin
          if DistToBase < 500 then
            Mashtab := 2;
       end;
     End;
  END;


   if ((MapMode=1) or(MapMode=2))and(SizeTrackRecord>1) then
       Begin
          xm := TrackRecord [SizeTrackRecord -1].x ;
          ym := TrackRecord [SizeTrackRecord -1].y ;
          GetNearestRoute(xm,ym);

          if NearestRoute<>-1 then
          begin
             if StartFrom1st = false then
               if Settings.StartFrom.ItemIndex < 2 then
                  SetCurrentRoute(NearestRoute)
                    else
                       SetCurrentRouteByName(Settings.ChoosedStartRoute.Text);

             if NearestDist<>-1 then
              if NearestDist < MinDistToFix then
              Begin
                 MapMode := MapMode + 2;
                 Follow := True;
              End;


             fi := -pi + AzimuthToNearest;
             if MapModeDoRotate[MapMode] then
             begin
                fi := -pi + AzimuthToNearest - Azimuth;
                 if MapMode = 5 then
                    fi := -pi + AzimuthToNearest - CurrentRouteAngle;

             end;

             xm := (Center.x - xm)/ Scale ;
             ym := (Center.y - ym)/ Scale ;

             dx := xm * Cos (Fi) + ym * Sin(Fi);
             dy :=-xm * Sin (Fi) + ym * Cos(Fi);

             xm := round ((DisplaySize.X - MenuW) div 2 - dx );
             ym := DisplaySize.y -  round (DisplaySize.y div 2 - dy ) + VYShift;
             if NearestDist> Scale*256 then
             begin
                AsphCanvas.UseImagePx(AsphImages.Image['arrow3.image'], pxBounds4(0, 0, 32, 256));

                AsphCanvas.TexMap(pRotate4c(Point2(xm,
                    ym),
                    Point2(32, 256), fi),
                    cColor4(ChoosedColor));//,ChoosedColor,ChoosedColor,ChoosedColor);  }

                S := IntToStr(trunc(NearestDist));
                if NearestDist>1000 then
                  S := IntToStr(trunc(NearestDist/1000))+inf[25]
                  else
                    S := IntToStr(trunc(NearestDist))+inf[20];

                if BigText then
                begin
                  Fi := Fi + pi/4;
                  Fnt := Font1
                end
                   else
                     Fnt := Font5;

                w := round(AsphFonts[Fnt].TextWidth(s)/2);
                AsphFonts[Fnt].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);

               { w := round(AsphFonts[Font5].TextWidth(s)/2);
                AsphFonts[Font5].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);}
             end;

          end;
       End;

  if ((MapMode=6) or(MapMode=7))and(SizeTrackRecord>1) then
  Begin
     xm := TrackRecord [SizeTrackRecord -1].x ;
     ym := TrackRecord [SizeTrackRecord -1].y ;
     GetDistToBase(xm, ym);
     DrawArrowToBase;
  End;

end;

procedure TMainForm.DrawArrowToNextRoute;
var xm, ym, fi, dx, dy, w, DistToRoute : Double;
    S :String;
    Fnt: Integer;
begin
    if (SizeTrackRecord<1) then
      exit;

    if (NextRoute < 0)or (NextRoute > RouteCount-1) then
      exit;

    if ShowNextTime>0 then
      ShowNextTime := ShowNextTime - LagCount
      else
         ShowNext := false;

    if (MapMode > 2)and(MapMode < 6)and(SizeTrackRecord>1) then
       Begin
          xm := TrackRecord [SizeTrackRecord -1].x ;
          ym := TrackRecord [SizeTrackRecord -1].y ;

          DistToRoute := GetDistToRoute(NextRoute, xm, ym);

          fi := -pi + AzimuthToRoute;
          if MapModeDoRotate[MapMode] then
          begin
              fi := -pi + AzimuthToRoute - Azimuth;
              if MapMode = 5 then
                 fi := -pi + AzimuthToRoute - CurrentRouteAngle;
          end;

          xm := (Center.x - xm)/ Scale ;
          ym := (Center.y - ym)/ Scale ;

          dx := xm * Cos (Fi) + ym * Sin(Fi);
          dy :=-xm * Sin (Fi) + ym * Cos(Fi);

          xm := round ((DisplaySize.X - MenuW) div 2 - dx );
          ym := DisplaySize.y -  round (DisplaySize.y div 2 - dy ) + VYShift;
          if DistToRoute > Scale*256 then
             begin
                AsphCanvas.UseImagePx(AsphImages.Image['arrow3.image'], pxBounds4(0, 0, 32, 256));

                AsphCanvas.TexMap(pRotate4c(Point2(xm,
                    ym),
                    Point2(32, 256), fi),
                    cColor4(RoutesColor));//,ChoosedColor,ChoosedColor,ChoosedColor);  }

                S := inf[56] + IntToStr(trunc(DistToRoute));
                if  DistToRoute>1000 then
                  S := inf[56] + IntToStr(trunc( DistToRoute/1000))+inf[25]
                  else
                    S := inf[56] + IntToStr(trunc( DistToRoute))+inf[20];

                if BigText then
                begin
                  Fi := Fi + pi/4;
                  Fnt := Font1
                end
                   else
                     Fnt := Font5;

                w := round(AsphFonts[Fnt].TextWidth(s)/2);
                AsphFonts[Fnt].TextOut(Point2(trunc(xm+Sin(fi)*64-w),trunc(ym-Cos(fi)*64-10)),
                                         S,clWhite2);

             end;

       End;
end;

procedure TMainForm.DrawScaleandNord (Mas: Double);
var s, s2 : String;
    w, j, i, k, _HgtId : integer;
    xm, ym, x2 : real;
    InfMd : boolean;
begin

  if DrawScale then
//  if Scale = _scale then
  Begin
    w := trunc(TMashtab[Mashtab]/Mas);

    AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-20 - w, DisplaySize.Y - 50,
                    (DisplaySize.X - MenuW), DisplaySize.Y),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

        FatLine((DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 10,
                (DisplaySize.X - MenuW) - 10, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

        FatLine((DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 20,
                (DisplaySize.X - MenuW) - 10 - w, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

        FatLine((DisplaySize.X - MenuW) - 10, DisplaySize.Y - 20,
                (DisplaySize.X - MenuW) - 10, DisplaySize.Y - 10 , 1, false, $FFFFFFFF);

    w := trunc(w/2 + AsphFonts[Font4].TextWidth(MashtabNames[Mashtab])/2) ;

    AsphFonts[Font4].TextOut( Point2((DisplaySize.X - MenuW) - w -10, DisplaySize.Y - 45), MashtabNames[Mashtab],
                              clWhite2, 1.0);

  End;



  if ShowCur then
   if (MapMode>=3)and(Mapmode<=5) then
    if not (BeforeBegin or AfterEnd) then
    if not ReFlyCurrent then
    Begin
       InfMd := true;

       AsphCanvas.FillRect(RECT( (DisplaySize.X- MenuW)div 2 - 110, 0,
                    (DisplaySize.X- MenuW)div 2 + 110, 82),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

       S := Route[CurrentRoute].Name;

       I := trunc(AsphFonts[Font1].TextWidth(S));

       J := trunc(AsphFonts[Font3].TextWidth(Inf[62])) ;

       AsphFonts[Font3].TextOut( Point2((DisplaySize.X- MenuW)div 2 - (J+I) div 2,  5.0),
                    inf[62], cColor2( $FFFFFFFF, $FFFFFFFF), 1.0);

       AsphFonts[Font1].TextOut(
         Point2((DisplaySize.X- MenuW) div 2 - (j+i) div 2 + j, -5.0 ),
         S,
         cColor2( $FFFFFFFF, $FFFFFFFF), 1.0);


       if DistToCurrent> 1000 then
            S := IntToStr(Round(DistToCurrent/1000)) + ' '+inf[25]
            else
              S := IntToStr(Trunc(DistToCurrent)) + ' '+ inf[20];


        J := trunc(AsphFonts[Font6].TextWidth(S));

        AsphFonts[Font6].TextOut(
                    Point2((DisplaySize.X- MenuW) div 2 - J div 2, 35),
                    S,
                    cColor2( $FFFFFFFF, $FFFFFFFF), 1.0);

        AsphCanvas.UseImagePx(AsphImages.Image['arrow4.image'], pxBounds4(0, 0, 32, 32));

        if Trunc(DistToCurrent)>0 then
        try

           x2 := (-AzimuthToCurrent+Azimuth);
           if x2 < 0 then
               x2 := x2 + 2*pi;
           if x2 > 2*pi then
               x2 := x2 - 2*pi;




           if x2 > pi then
                  AsphCanvas.TexMap(pRotate4c(Point2((DisplaySize.X- MenuW) div 2 - J div 2 -26, 55),
                  Point2(32, 32) , 3.14), clWhite4)
           else
                  AsphCanvas.TexMap(pRotate4c(Point2((DisplaySize.X- MenuW) div 2 + J div 2 +26, 55),
                  Point2(32, 32), 0), clWhite4);

        except
        End;
    End else
       InfMd := false;

  if HgtLine then
  Begin
    if Settings.HgtLineData.ItemIndex = 0 then
       _HgtId := HgtId
         else
           _HgtId := Settings.HgtLineData.ItemIndex;

    if ShowInfo then
    BEGIN
     if DrawScale = false then
       j := 2
       else
         j:=52;


      AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-100, DisplaySize.Y - 200 -j,
                    (DisplaySize.X - MenuW), DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

      AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-40, DisplaySize.Y -200-j,
                    (DisplaySize.X - MenuW), DisplaySize.Y-150-j),
                     cRGB4(185,10,10,200));

      AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-40, DisplaySize.Y -50-j,
                    (DisplaySize.X - MenuW), DisplaySize.Y-j),
                     cRGB4(185,10,10,200));

      AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-40, DisplaySize.Y -150-j,
                    (DisplaySize.X - MenuW), DisplaySize.Y-50-j),
                     cRGB4(80,185,50,200));

      FatLine((DisplaySize.X - MenuW) - 10 , DisplaySize.Y - 190-j,
                (DisplaySize.X - MenuW) - 20, DisplaySize.Y - 190-j , 1, false, $FFFFFFFF);

      FatLine((DisplaySize.X - MenuW) - 10 , DisplaySize.Y - 10-j,
                (DisplaySize.X - MenuW) - 20, DisplaySize.Y - 10-j , 1, false, $FFFFFFFF);

      FatLine((DisplaySize.X - MenuW) - 10 , DisplaySize.Y - 100-j,
                (DisplaySize.X - MenuW) - 20, DisplaySize.Y - 100-j , 1, false, $FFFFFFFF);

      FatLine((DisplaySize.X - MenuW) - 10 , DisplaySize.Y - 150-j,
                (DisplaySize.X - MenuW) - 20, DisplaySize.Y - 150-j , 1, false, $FFFFFFFF);

      FatLine((DisplaySize.X - MenuW) - 10 , DisplaySize.Y - 50-j,
                (DisplaySize.X - MenuW) - 20, DisplaySize.Y - 50-j, 1, false, $FFFFFFFF);

      FatLine((DisplaySize.X - MenuW) - 10, DisplaySize.Y - 190-j,
                (DisplaySize.X - MenuW) - 10, DisplaySize.Y - 10-j , 1, false, $FFFFFFFF);



      if not BigText then
      Begin
        AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-100, DisplaySize.Y - 230 -j,
                    (DisplaySize.X - MenuW), DisplaySize.Y-j-200),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
        if _hgtID = 2 then
         s := inf[64]
         else
          s := inf[63];

        i := trunc(AsphFonts[Font3].TextWidth(s));
        AsphFonts[Font3].TextOut( Point2(DisplaySize.X - MenuW-50-i/2 , DisplaySize.Y - 225-j), s,
                              clWhite2, 1.0);
     End;

     if _hgtID = 2 then
     Begin
       w := Trunc(50 + 100*(_HAGL-MinHGTL)/(MaxHGTL-MinHGTL));
       s := IntToStr(round(_HAGL));
       s2:= 'L'
     End
         else
         Begin
            w := Trunc(50 + 100*(_HAGR-MinHGTR)/(MaxHGTR-MinHGTR));
            s := IntToStr(round(_HAGR));
            s2:='R'
         End;

     i := trunc(AsphFonts[Font4].TextWidth(s));

     if w > 190  then
       w := 190;

     if w < 10  then
       w := 10;


     if i>40 then
      case BigText of

          true:  AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-100-(i-40), DisplaySize.Y - 200 -j,
                    (DisplaySize.X - MenuW)-100, DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

          false: AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-100-(i-40), DisplaySize.Y - 230 -j,
                    (DisplaySize.X - MenuW)-100, DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
      end;
       

     AsphCanvas.UseImagePx(AsphImages.Image['hgtm.image'], pxBounds4(0, 0, 64, 32));

     AsphCanvas.TexMap(pRotate4c(Point2((DisplaySize.X - MenuW) - 25,
                    DisplaySize.Y - w -j),Point2(64, 32), 0),
                    clWhite4);

     if s<>'-' then
       AsphFonts[Font4].TextOut( Point2(DisplaySize.X - MenuW-60-i , DisplaySize.Y - w - j - 10), s,
                              clWhite2, 1.0);

     if BigText then
     Begin
          
       if (W<175) then
          AsphFonts[Font5].TextOut( Point2(DisplaySize.X - MenuW-92 , DisplaySize.Y - j - 195), s2,
                              clWhite2, 1.0)

     End;

     if (W<30)or(w>70) then
     begin
       if _hgtID = 2 then
         s:= IntToStr(MinHGTL)
         else
          s:= IntToStr(MinHGTR);

       if BigText = false then
         s := s + inf[20];

       i := trunc(AsphFonts[Font3].TextWidth(s));

       AsphFonts[Font3].TextOut( Point2(DisplaySize.X - MenuW-45-i , DisplaySize.Y - j - 60), s,
                              clWhite2, 1.0);
     end;

     if (W<130)or(w>170) then
     begin
       if _hgtID = 2 then
         s:= IntToStr(MaxHGTL)
         else
           s:= IntToStr(MaxHGTR);

       if BigText = false then
         s := s + inf[20];

       i := trunc(AsphFonts[Font3].TextWidth(s));

       AsphFonts[Font3].TextOut( Point2(DisplaySize.X - MenuW-45-i , DisplaySize.Y - j - 160), s,
                              clWhite2, 1.0);
     end;
  END

   ELSE

  BEGIN
      j := 2 ;

      AsphCanvas.FillRect(RECT( 40, DisplaySize.Y - 200 -j,
                    100, DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y -200-j,
                    40, DisplaySize.Y-150-j),
                     cRGB4(185,10,10,200));

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y -50-j,
                    40, DisplaySize.Y-j),
                     cRGB4(185,10,10,200));

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y -150-j,
                    40, DisplaySize.Y-50-j),
                     cRGB4(80,185,50,200));

      FatLine(10 , DisplaySize.Y - 190-j,
              20, DisplaySize.Y - 190-j , 1, false, $FFFFFFFF);

      FatLine(10 , DisplaySize.Y - 10-j,
              20, DisplaySize.Y - 10-j , 1, false, $FFFFFFFF);

      FatLine(10 , DisplaySize.Y - 100-j,
              20, DisplaySize.Y - 100-j , 1, false, $FFFFFFFF);

      FatLine(10 , DisplaySize.Y - 150-j,
              20, DisplaySize.Y - 150-j , 1, false, $FFFFFFFF);

      FatLine(10 , DisplaySize.Y - 50-j,
              20, DisplaySize.Y - 50-j, 1, false, $FFFFFFFF);

      FatLine( 10, DisplaySize.Y - 190-j,
               10, DisplaySize.Y - 10-j , 1, false, $FFFFFFFF);



      if not BigText then
      Begin
        AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 230 -j,
                    100, DisplaySize.Y-j-200),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

        if _hgtID = 2 then
         s := inf[64]
         else
          s := inf[63];

        i := trunc(AsphFonts[Font3].TextWidth(s));

        AsphFonts[Font3].TextOut( Point2(50-i/2 , DisplaySize.Y - 225-j), s,
                              clWhite2, 1.0);
     End;

     if _hgtID = 2 then
     Begin
       w := Trunc(50 + 100*(_HAGL-MinHGTL)/(MaxHGTL-MinHGTL));
       s := IntToStr(round(_HAGL));
       s2:= 'L'
     End
         else
         Begin
            w := Trunc(50 + 100*(_HAGR-MinHGTR)/(MaxHGTR-MinHGTR));
            s := IntToStr(round(_HAGR));
            s2:= 'R'
         End;

     i := trunc(AsphFonts[Font4].TextWidth(s));

     if w > 190  then
       w := 190;

     if w < 10  then
       w := 10;

     if i>40 then
      case BigText of

          true:  AsphCanvas.FillRect(RECT( 100, DisplaySize.Y - 200 -j,
                    100+(i-40), DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

          false: AsphCanvas.FillRect(RECT( 100, DisplaySize.Y - 230 -j,
                    100+(i-40), DisplaySize.Y-j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
      end;
       

     AsphCanvas.UseImagePx(AsphImages.Image['hgtm.image'], pxBounds4(0, 0, 64, 32));

     AsphCanvas.TexMap(pRotate4c(Point2(25,
                    DisplaySize.Y - w -j),Point2(64, 32), 3.14),
                    clWhite4);

     if s<>'-' then
       AsphFonts[Font4].TextOut( Point2(60, DisplaySize.Y - w - j - 10), s,
                              clWhite2, 1.0);

     if BigText then
     Begin

          
       if (W<175) then
          AsphFonts[Font5].TextOut( Point2(80 , DisplaySize.Y - j - 195), s2,
                              clWhite2, 1.0)

     End;

     if (W<30)or(w>70) then
     begin
       if _hgtID = 2 then
         s:= IntToStr(MinHGTL)
         else
          s:= IntToStr(MinHGTR);

       if BigText = false then
         s := s + inf[20];

       AsphFonts[Font3].TextOut( Point2(45 , DisplaySize.Y - j - 60), s,
                              clWhite2, 1.0);
     end;

     if (W<130)or(w>170) then
     begin
       if _hgtID = 2 then
         s:= IntToStr(MaxHGTL)
         else
           s:= IntToStr(MaxHGTR);

       if BigText = false then
         s := s + inf[20];

       AsphFonts[Font3].TextOut( Point2(45 , DisplaySize.Y - j - 160), s,
                              clWhite2, 1.0);
     end;




  END;


  End;

  if ShowInfo then
  Begin

    s := 'H(WGS84): ' + CurGeoHgt;
    s2:= 'H(GEO): ' + CurHgt +CurDGeo;
    w := trunc(AsphFonts[Font0].TextWidth(s2))+15;

    AsphCanvas.FillRect(RECT( (DisplaySize.X - MenuW)-w, 0, (DisplaySize.X - MenuW), 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[Font0].TextOut( Point2((DisplaySize.X - MenuW)-w+8.0 , 2.0), s,
                              clWhite2, 1.0);

    AsphFonts[Font0].TextOut( Point2((DisplaySize.X - MenuW)-w+8.0 , 14.0), s2,
                              clWhite2, 1.0);


    case InfMd of
       true: begin
         i := 0;
         j := 30;
       end;
       false: begin
          i := 120;
          j := 0;
       end;
    end;

    AsphCanvas.FillRect(RECT( 0, 0,
                    120 + i, 30 + j),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[Font0].TextOut( Point2(4.0 , 2.0), 'B: ' + CurB,
                              clWhite2, 1.0);

    AsphFonts[Font0].TextOut( Point2(4.0 , 14.0), 'L: ' + CurL,
                              clWhite2, 1.0);
    if not South then
    Begin
      AsphFonts[Font0].TextOut( Point2(4.0 +i , 2.0 +j), 'E: ' + CurX,
                              clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(4.0 +i , 14.0 +j), 'N: ' + CurY,
                              clWhite2, 1.0);
    End
     else
      Begin
         AsphFonts[Font0].TextOut( Point2(4.0 +i , 2.0 +j), 'W: ' + CurX,
                              clWhite2, 1.0);

         AsphFonts[Font0].TextOut( Point2(4.0 +i , 14.0 +j), 'S: ' + CurY,
                              clWhite2, 1.0);

      End;

    if BigText then
    Begin
      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 120,
                    135, DisplaySize.Y-62),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 60,
                    135, DisplaySize.Y),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
      xm := 0;
      ym := 0;
      try
         if SatCount<>'' then
           xm := StrToFloat2(SatCount);
         if CurDop<>'' then
           ym := StrToFloat2(CurDOP);
      except
      end;

      AsphCanvas.UseImagePx(AsphImages.Image['sat.image'], pxBounds4(0, 0, 32, 32));

      AsphCanvas.TexMap(pRotate4c(Point2(28,
                    DisplaySize.Y-90),
                    Point2(40, 40), 0),
                    clWhite4);

      AsphCanvas.UseImagePx(AsphImages.Image['dop.image'], pxBounds4(0, 0, 32, 32));

      AsphCanvas.TexMap(pRotate4c(Point2(28,
                    DisplaySize.Y-30),
                    Point2(40, 40), 0),
                    clWhite4);

      if xm<5 then
         AsphFonts[Font6].TextOut( Point2(60.0 , DisplaySize.Y - 112),  SatCount, clRed2, 1.0)
        else
          AsphFonts[Font6].TextOut( Point2(60.0 , DisplaySize.Y - 112),  SatCount, clWhite2, 1.0);

      if ym >= 4 then
          AsphFonts[Font6].TextOut( Point2(60.0 , DisplaySize.Y - 52),  CurDop, clRed2, 1.0)
          else
            AsphFonts[Font6].TextOut( Point2(60.0 , DisplaySize.Y - 52),  CurDop, clWhite2, 1.0);

    End
    else
    Begin
      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 140,
                    110, DisplaySize.Y-102),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 100,
                    110, DisplaySize.Y-62),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
      xm := 0;
      ym := 0;
      try
         if SatCount<>'' then
           xm := StrToFloat2(SatCount);
         if CurDop<>'' then
           ym := StrToFloat2(CurDOP);
      except
      end;

      AsphCanvas.UseImagePx(AsphImages.Image['sat.image'], pxBounds4(0, 0, 32, 32));

      AsphCanvas.TexMap(pRotate4c(Point2(21,
                    DisplaySize.Y-120),
                    Point2(32, 32), 0),
                    clWhite4);

      AsphCanvas.UseImagePx(AsphImages.Image['dop.image'], pxBounds4(0, 0, 32, 32));

      AsphCanvas.TexMap(pRotate4c(Point2(21,
                    DisplaySize.Y-80),
                    Point2(32, 32), 0),
                    clWhite4);

      if xm<5 then
         AsphFonts[Font2].TextOut( Point2(60.0 , DisplaySize.Y - 129),  SatCount, clRed2, 1.0)
        else
          AsphFonts[Font2].TextOut( Point2(60.0 , DisplaySize.Y - 129),  SatCount, clWhite2, 1.0);

      if ym >= 4 then
          AsphFonts[Font2].TextOut( Point2(60.0 , DisplaySize.Y - 89),  CurDop, clRed2, 1.0)
          else
            AsphFonts[Font2].TextOut( Point2(60.0 , DisplaySize.Y - 89),  CurDop, clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(45.0 , DisplaySize.Y - 139), Inf[2],
                              clWhite2, 1.0);
      AsphFonts[Font0].TextOut( Point2(45.0 , DisplaySize.Y - 99), 'Horz.DOP:',
                              clWhite2, 1.0);

      AsphCanvas.FillRect(RECT( 0, DisplaySize.Y - 60,
                    180, DisplaySize.Y),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
      if UTM then
        s2 := 'UTM '
          else
            s2 := 'GK ';
      
      AsphFonts[Font0].TextOut( Point2(4.0 , DisplaySize.Y - 55), Inf[1] + ' ' +s2 + IntToStr(MyZone),
                              clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(4.0 , DisplaySize.Y - 41), Inf[3] +  ' ' + CurTime,
                              clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(4.0 , DisplaySize.Y - 28), Inf[4] +  CurTrip,
                              clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(4.0 , DisplaySize.Y - 15), Inf[5] +  CurOdo,
                              clWhite2, 1.0);
    End;

    if AllowMouse and ShowCurXY then
    try

      xm := Panel1CursorX - (DisplaySize.X - MenuW)/2;
      ym := -Panel1CursorY + DisplaySize.Y/2 + VYShift;
      x2 := xm;
      if MapModeDoRotate[MapMode] then
      begin
        if MapMode=5 then
        begin
           xm := xm * Cos (CurrentRouteAngle) + ym * sin(CurrentRouteAngle);
           ym := ym * Cos (CurrentRouteAngle) - x2* sin(CurrentRouteAngle);
        end
          else
          begin
            xm := xm * Cos (azimuth) + ym * sin (azimuth);
            ym := ym * Cos (azimuth) - x2* sin (azimuth);
          end;
      end;

      xm := xm * Mas + Center.X;
      ym := ym * Mas + Center.Y;

      s :=  'x: ' +format('%n',[xm]);
      s2 := 'y: ' +format('%n',[ym]);

      w:= trunc(AsphFonts[Font0].textwidth(s));
      if w < (AsphFonts[Font0].textwidth(s2)) then
        w:= trunc(AsphFonts[Font0].textwidth(s2));

      AsphCanvas.FillRect(RECT( Panel1CursorX, Panel1CursorY,
                    Panel1CursorX+w+8, Panel1CursorY+26),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

      AsphFonts[Font0].TextOut( Point2(Panel1CursorX+4.0 , Panel1CursorY),
                                s, clWhite2, 1.0);

      AsphFonts[Font0].TextOut( Point2(Panel1CursorX+4.0 , Panel1CursorY+12.0),
                                s2, clWhite2, 1.0);

    except
    end;

  End;

  w:=0;
  if showInfo then
   case InfMd of
     true: w:= 62;
     false: w:= 32;
   end;

  if ShowFPS then
     AsphFonts[Font4].TextOut( Point2(4.0 , 4.0 + w), 'FPS: ' + IntToStr(Timer.FrameRate),
                              clWhite2, 1.0);

  if Panel3.Visible then     ///Режим воспроизведения
  Begin
    if EmulSpeed=0 then
       s := 'СТОП'
         else
           s := 'x'+ IntToStr(EmulSpeed);
       AsphFonts[Font2].TextOut( Point2((DisplaySize.X - MenuW) - 80 , 4.0 + w), S,
                              clWhite2, 1.0);
     w := w + 35;
  End;

  if MapMode=0 then
  Begin
    s  := Inf[6];
    s2 := Inf[7];
    xm := (DisplaySize.X - MenuW) - AsphFonts[Font0].TextWidth(s2)-10;
    ym := w;

    AsphCanvas.FillRect(RECT( trunc(xm) , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[Font0].TextOut( Point2(xm + 5 , 2.0 + ym), S,
                              clWhite2, 1.0);
    AsphFonts[Font0].TextOut( Point2(xm + 5 , 16.0 + ym), S2,
                              clWhite2, 1.0);

    w := w + 35;
  End;

  if (MenuN = 4) or((MapMode>2)and(MapMode < 6)and(ReFlyCurrent)) then
  Begin
    if MenuN=4 then
    s  := inf[8]
      else
        s  := inf[9];
    ym := w;

    xm := trunc(((DisplaySize.X - MenuW) - AsphFonts[font4].TextWidth(s))/2);

    AsphCanvas.FillRect(RECT( 0 , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[font4].TextOut( Point2(xm , 2.0 + ym), S,
                              clWhite2, 1.0);


    w := w + 35;
  End;

  if (MenuN = 7) then
  Begin

    s  := inf[10];

    xm := trunc(((DisplaySize.X - MenuW) - AsphFonts[font4].TextWidth(s))/2);

    AsphCanvas.FillRect(RECT( 0 , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[font4].TextOut( Point2(xm , 2.0 + ym), S,
                              clWhite2, 1.0);

  End;

  if (MenuN = 8) then
  Begin

    s  := ' '+ inf[11];

    ym := w;

    xm := trunc(((DisplaySize.X - MenuW) - AsphFonts[font4].TextWidth(s))/2);

    AsphCanvas.FillRect(RECT( 0 , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[font4].TextOut( Point2(xm , 2.0 + ym), S,
                              clWhite2, 1.0);

    w:= w + 30;
  End;

  if (MenuN = 9) then
  Begin

    s  := inf[12];

    ym := w;

    xm := trunc(((DisplaySize.X - MenuW) - AsphFonts[font4].TextWidth(s))/2);

    AsphCanvas.FillRect(RECT( 0 , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[font4].TextOut( Point2(xm , 2.0 + ym), S,
                              clWhite2, 1.0);

    w:= w + 30;
  End;

  if (MenuN = 10) then
  Begin

    s  := inf[13];

    ym := w;

    xm := trunc(((DisplaySize.X - MenuW) - AsphFonts[font4].TextWidth(s))/2);

    AsphCanvas.FillRect(RECT( 0 , trunc(ym), (DisplaySize.X - MenuW), trunc(ym)+ 30),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphFonts[font4].TextOut( Point2(xm , 2.0 + ym), S,
                              clWhite2, 1.0);

    w:= w + 30;
  End;

  if SmartMenu then
  Begin
    if not ShowFPS then
       ym := w
     else
        ym := w+30;

    if ym <= 0 then
        ym := 30;

    SmartY := trunc(ym);

    xm := SmartX;

    if SmartCount > 8 then
       x2 := 50
        else
         x2 :=0;

    SmartKeyY := SmartY + trunc(x2/2);

    k := trunc(x2/50);

    if (ChoosedMenu = -1)and(not inSmart)
       or (inSmart)and(SmartN = 0)  then
    Begin
      AsphCanvas.FillRect(RECT( trunc(xm) , trunc(ym)-2+30+trunc(x2/2), trunc(xm)+22, trunc(ym)+ 72 +trunc(x2/2)),
                    cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
                     GetRValue(Dop1Color),250));

      AsphCanvas.FillRect(RECT( trunc(xm+2) , trunc(ym)+30+trunc(x2/2), trunc(xm)+20, trunc(ym)+ 70 +trunc(x2/2)),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),250));
    End
      ELSE
       AsphCanvas.FillRect(RECT( trunc(xm) , trunc(ym)+30+trunc(x2/2), trunc(xm)+20, trunc(ym)+ 70 +trunc(x2/2)),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

    AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));


    if SmartX<=0 then
    Begin
        AsphCanvas.TexMap(pRotate4c(Point2(xm+10, ym+50+trunc(x2/2)),
                  Point2(8, 16) , 0), clWhite4);

    End
     else
     BEGIN
        AsphCanvas.TexMap(pRotate4c(Point2(xm+10, ym+50+trunc(x2/2)),
                  Point2(8, 16) , 3.14), clWhite4);

        AsphCanvas.FillRect(RECT( 0 , trunc(ym), trunc(xm), trunc(ym+x2)+ 100) ,
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));
           
        if (inSmart)and(SmartN>0)and(SmartN<=SmartCount) then
        BEGIN

          s := inf[70+SmartN];
          
          xm := trunc(AsphFonts[font0].TextWidth(s));

          AsphCanvas.FillRect(RECT( 0 , trunc(ym+x2)+102, trunc(xm)+10, trunc(ym+x2)+ 120) ,
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190));

          xm := SmartX; 
          
          AsphFonts[font0].TextOut( Point2(4 , 105 + ym+ x2), S, clWhite2, 1.0);
   
        END;


        for I := 1 to 4 do
          for J := 0 to k+1 do
          if j*4+i <= SmartCount then

          Begin

            if (SmartN = (j*4+i)) then
            Begin
              AsphCanvas.FillRect(RECT( trunc(xm+(i-1)*50-200) , trunc(ym+j*50), trunc(xm+(i)*50-200), trunc(ym+(j+1)*50)),
                    cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
                     GetRValue(Dop1Color),255));

              AsphCanvas.FillRect(RECT( trunc(xm+(i-1)*50-200+2) , trunc(ym+j*50+2), trunc(xm+(i)*50-200-2), trunc(ym+(j+1)*50-2)),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),250));
            End
             { else
                 AsphCanvas.FillRect(RECT( trunc(xm) , trunc(ym)+30, trunc(xm)+20, trunc(ym)+ 70),
                    cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),190))};

            case j*4+i of
              // icons
               1: begin
                    AsphCanvas.UseImagePx(AsphImages.Image['s_inf.image'], pxBounds4(0, 0, 64, 64));

                    if ShowInfo then                    
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
                         else
                           AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4);
               end;
               2: begin
                    AsphCanvas.UseImagePx(AsphImages.Image['s_tr1.image'], pxBounds4(0, 0, 64, 64));

                    if (HideTrack)or(MaxDotsVisible = 0) then
                    Begin
                      AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4); 
                      AsphCanvas.UseImagePx(AsphImages.Image['s_tr3.image'], pxBounds4(0, 0, 64, 64))
                    End
                      else
                         if (MaxDotsVisible = 1000) then
                         Begin
                            AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                                Point2(40, 40), 0),
                                clGray4); 
                            AsphCanvas.UseImagePx(AsphImages.Image['s_tr2.image'], pxBounds4(0, 0, 64, 64))
                         End;
                             // else
                              //  AsphCanvas.UseImagePx(AsphImages.Image['s_tr1.image'], pxBounds4(0, 0, 64, 64));
                                        
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4);
                        
                           
               end;
               3: begin
                  AsphCanvas.UseImagePx(AsphImages.Image['s_map.image'], pxBounds4(0, 0, 64, 64));

                    if ShowMaps then                    
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
                         else
                           AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4);
               end;  
               4: begin
                   AsphCanvas.UseImagePx(AsphImages.Image['s_set.image'], pxBounds4(0, 0, 64, 64));

                  AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
               end;
               5: begin
                 AsphCanvas.UseImagePx(AsphImages.Image['s_gps.image'], pxBounds4(0, 0, 64, 64));
               
                 if Realtime then                    
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
                         else
                           AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4); 
               end;
               6: begin
                 AsphCanvas.UseImagePx(AsphImages.Image['s_aux.image'], pxBounds4(0, 0, 64, 64));
                             
                 if EnableCOM2 then                    
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
                         else
                           AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4); 
               end;
               7: begin
                 AsphCanvas.UseImagePx(AsphImages.Image['s_hgt.image'], pxBounds4(0, 0, 64, 64));
                             
                 if HgtLine then                    
                    AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                        Point2(40, 40), 0),
                        clWhite4)
                         else
                           AsphCanvas.TexMap(pRotate4c(Point2(trunc(xm+(i-1)*50-200+25),trunc(ym+j*50+25)),
                            Point2(40, 40), 0),
                            clGray4); 
               end;
            end;

          End;

          
     END;

  End;

end;

procedure TMainForm.ReDrawTurnPoints;
var dx, dy, dx2, dy2, x, y, x2, y2, fi,a : Double;
    csize: integer;
    i:integer;
begin

  if ShowTP = false then
     exit;

  if RouteCount < 2 then
     exit;

  if CurrentRoute = -1 then
     exit;

  if (MapMode<=2)or(MapMode>5) then
     exit;

  if not (LocalTP) then
  Begin
    if (not((BeforeBegin) or (AfterEnd))) then
      if not(ReflyCurrent) then
        exit;
  End;

  if RecalcWay then
  Begin

    if SpecialTP then
    Begin
        if NextRoute<>-1 then
        Begin

         a := arctan2(Route[CurrentRoute].x2-Route[CurrentRoute].x1,
                           Route[CurrentRoute].y2-Route[CurrentRoute].y1);
         if FromBegin then
            if GetTurnPoints(Route[CurrentRoute].x2+ Sin(a), Route[CurrentRoute].y2 + Cos(a),
                    a,
                   Route[NextRoute].x2,
                   Route[NextRoute].y2,
                   Route[NextRoute].x1,
                   Route[NextRoute].y1, MinR, MaxR) = false then
              exit;

          if not FromBegin then
              if GetTurnPoints(Route[CurrentRoute].x1+ Sin(a+pi), Route[CurrentRoute].y1+ Cos(a+pi),

                  (a+pi),

                   Route[NextRoute].x1,
                   Route[NextRoute].y1,
                   Route[NextRoute].x2,
                   Route[NextRoute].y2, MinR, MaxR) = false then
              exit;
        End
         else
          exit;


    End
     else
       BEGIN
         //if (not((BeforeBegin) or (AfterEnd))) then
          // if not(ReflyCurrent) then
           ///Begin


              x :=   TrackRecord [SizeTrackRecord -1].x;
              y :=   TrackRecord [SizeTrackRecord -1].y;

            if FromBegin then
                if GetTurnPoints(x, y,
                   Azimuth,
                   Route[CurrentRoute].x1,
                   Route[CurrentRoute].y1,
                   Route[CurrentRoute].x2,
                   Route[CurrentRoute].y2, MinR, MaxR) = false then
                exit;

             if not FromBegin then
                if GetTurnPoints(x, y,
                   Azimuth,
                   Route[CurrentRoute].x2,
                   Route[CurrentRoute].y2,
                   Route[CurrentRoute].x1,
                   Route[CurrentRoute].y1, MinR, MaxR) = false then
                exit;
       END;
  End;


   if TPCount=0 then
     exit;

   if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

   if MapMode = 5 then
        fi := - CurrentRouteAngle;

   for I := 1 to TPCount do
   Begin

     dx := (Center.x - TurnPoints[i-1].x)/ Scale ;
     dy := (Center.y - TurnPoints[i-1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     dx := (Center.x - TurnPoints[i].x)/ Scale ;
     dy := (Center.y - TurnPoints[i].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x2 := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y2 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     FatLine(x, y, x2, y2, 1 + DopFat, false, cRGB1(GetBValue(ChoosedColor),
             GetGValue(ChoosedColor),GetRValue(ChoosedColor),40));
      
   End;

   if not LocalTP then
      HideArrow := true;
//// Base
///
   {  if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     dx := (Center.x - Base[1].x)/ Scale ;
     dy := (Center.y - Base[1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     csize := 32;
     if BigCur then
        csize := 64;

     if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
         begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['flag_big.image'], pxBounds4(0, 0, 64, 64))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['flag.image'], pxBounds4(0, 0, 32, 32));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

         end;}
end;

procedure TMainForm.DrawZone(x1, y1, x2, y2, x3, y3, x4, y4: Double);
begin
  if not( (x1 < 0) and (x2 < 0) and (x3 < 0) and (x4 < 0)) then

  if not( (x1 > (DisplaySize.X)) and (x2 > (DisplaySize.X)) and
          (x3 > (DisplaySize.X)) and (x4 > (DisplaySize.X)) ) then

  if not( (y1 < 0) and (y2 < 0)and (y3 < 0) and (x4 < 0)) then

  if not( (y1 > DisplaySize.y) and (y2 > DisplaySize.y) and
          (y3 > DisplaySize.y) and (y4 > DisplaySize.y) ) then

  if not( (abs(y1-y2) < 1) and (abs(x1-x2) < 1) and (abs(y3-y4) < 1) and (abs(x3-x4) < 1) ) then

  try
     CutLineByBufferedFrame(x1,y1,x2,y2);
     CutLineByBufferedFrame(x3,y3,x4,y4);

     AsphCanvas.FillQuad(Point4(x1, y1, x2, y2, x3, y3, x4, y4),
                        cRGB4( GetBValue(ChoosedColor),GetGValue(ChoosedColor),
                                GetRValue(ChoosedColor),100));
  except

  end;

end;

procedure TMainForm.EditMarker(I: integer; Mname: string; mB, mL: Double);
begin
  with  Markers[I] do
  begin
    Caption := mName;
    B := mB;
    L := mL;
  end;

  RefreshMarkerList;
end;

procedure TMainForm.FatLine(x, y, x2, y2: Double; Thin:integer; Dash:Boolean; Col: Cardinal);
var i,j :integer;
begin
 for I := -Thin to Thin do
   for J := -Thin to Thin do
        MyLine( x+I, y+J, x2+I, y2+J, Dash, Col)

end;

procedure TMainForm.FollowCurrentRoute(RouteN: integer; _CurTime: real; cx,cy :Double);
var L, L2, Dist : Double;
    CanDrawNextArrow : boolean;
    D2: TPosAndDist;
begin

  if RouteCount=0 then
      exit;


  if (RouteN < RouteCount) and (RouteN<>-1) then
  Begin
       if Route[RouteN].Status < 2 then
       begin

         Dist := GetDistToRoute(RouteN, cx,cy);
         DistToCurrent := trunc(Dist);
         AzimuthToCurrent := AzimuthToRoute;
         CanDrawNextArrow := not DrawArrowToCurrentRoute;

         if ShowNext then
            DrawArrowToNextRoute
         else
         if not HideNext then
           if CanDrawNextArrow then
              if RouteProgress <> -1 then
                 if ((RouteProgress < 25) and (not FromBegin))
                    or ((RouteProgress > 75) and (FromBegin))then
                       DrawArrowToNextRoute;


         if NumDist=0 then  /// Определить начало или конец
         Begin
           L := Sqr(Route[RouteN].x1-cx)+Sqr(Route[RouteN].y1-cy);
           L2 := Sqr(Route[RouteN].x2-cx)+Sqr(Route[RouteN].y2-cy);
           FromBegin := L < L2;
         End;

         if  (BeforeBegin or AfterEnd) then
         begin
            if MenuN = 4 then
               MenuN := 1;


         end;

         if (BeforeBegin and not FromBegin) or (AfterEnd and FromBegin) then
         Begin
            ///// следование завершено
           // if NumDist>0 then
              if not ReFlyCurrent then
                 GoToNextRoute
                  else
                  begin
                      L := Sqr(Route[RouteN].x1-cx)+Sqr(Route[RouteN].y1-cy);
                      L2 := Sqr(Route[RouteN].x2-cx)+Sqr(Route[RouteN].y2-cy);
                      FromBegin := L < L2;
                  end;
         End
           else
           BEGIN
            Dist := GetDistToRoute(RouteN, cx,cy);
            if not (BeforeBegin or AfterEnd) then
             if not ReFlyCurrent then
              if LastFollowedTime <> _CurTime then
              Begin
                LastFollowedTime := _CurTime;
                if Dist <= RouteMaxDist*2.5 then
                begin
                    if NumDist = 0 then
                    Begin
                       Route[CurrentRoute].StartTime := CurTime;
                       if LocalTP then
                         begin
                           SpecialTP := true;
                           RecalcWay := true;
                         end;
                    End;
                    SumDist := SumDist + (sqr(Dist));
                    Inc(NumDist);
                    
                    TrackRecord[SizeTrackRecord -1].RouteNm := Route[CurrentRoute].Name;
                    TrackRecord[SizeTrackRecord -1].RDist := round(dist*10);
                    TrackRecord[SizeTrackRecord -1].RProgress:= RouteProgress;
                    //// HGTS
                    if (Realtime) then
                    begin
                        if ((Settings.isRadio.Checked) or (Settings.isLaser.Checked)) then
                        Begin
                          if (HagR>0)and ((HagR <  {0.9*}MinHGTR) or (HagR >  {1.1*}MaxHGTR)) then
                               Inc(NumBadHgt)
                               else
                               if (HagL>0)and ((HagL < {0.9*}MinHGTL) or (HagL >  {1.1*}MaxHGTL)) then
                                   Inc(NumBadHgt)
                        End;
                    end
                      else
                         if (Settings.ContainAUX.Checked) then
                         Begin
                            if (HagR>0)and ((HagR < {0.9*}MinHGTR) or (HagR >  {1.1*}MaxHGTR)) then
                               Inc(NumBadHgt)
                               else
                               if (HagL>0)and ((HagL <  {0.9*}MinHGTL) or (HagL >  {1.1*}MaxHGTL)) then
                                   Inc(NumBadHgt)
                         End;
                   //// HGTS end
                end
                 else
                    WorstDist := true;

                if Dist > RouteMaxDist then
                begin
                   ///if not (BeforeBegin or AfterEnd or ReflyCurrent) then
                      BadDist := true;

                   if (AutoOn = false) or (AutoM[9] = 0) then
                   begin

                      if (MapMode > 2)and(MapMode < 5) then
                      begin
                         MenuN := 4;
                         MenuScroll :=0;
                      end;

                   end
                       else
                        case AutoM[9] of
                          1 : begin
                                ReflyCurrent := true;
                                BadDist := false;
                                WorstDist := false;
                              end;
                          2 : begin
                                if WorstDist then
                                Begin
                                  ReflyCurrent := true ;
                                  BadDist := false;
                                  WorstDist := false;
                                End
                                    else
                                     BadDist := false;
                              end;
                          3: if WorstDist then
                             Begin
                               if SizeTrackRecord > 1 then
                               begin
                                 GetNearestRoute(TrackRecord[SizeTrackRecord -1].x,
                                                TrackRecord[SizeTrackRecord -1].y);
                                 SetCurrentRoute(NearestRoute);
                                 Route[CurrentRoute].RLabel := '*'+inf[69];
                                 BadDist := false;
                                 WorstDist := false;
                                 SumDist := 0;
                                 NumDist := 0;
                                 NumBadHgt := 0;
                               end;
                             End
                              else
                                BadDist := false;
                        end;
              End;

            END
             else
               if ReFlyCurrent then
                 GoToNextRoute;


              if  (BeforeBegin or AfterEnd) then
              begin
                ReFlyCurrent :=False;
                BadDist := false;
                WorstDist := false;
                NumDist := 0;
                NumBadHgt := 0;
                SumDist := 0;
              end;

           END;

       end
        else GoToNextRoute;

       if AutoOn then
       Begin
          if not (BeforeBegin or AfterEnd or ReflyCurrent) then
          begin
            if (MapMode>2) and (MapMode <6) then     //// с маршрута на маршрут
            begin
              Mashtab := AutoM[5];
              MapMode := 3 + AutoM[6];
              Follow := True;   /// klm,;.
            end;
          end
          else
            begin
               GetNearestRoute(cx,cy);
               if (NearestDist > AskR)and(AskReturn)  then   ////
               begin
                   if AskR = 0 then
                     AskReturn := false
                      else
                      Begin

                        if (MapMode>2) and (MapMode <6) and (MenuN<>4) and (MenuN<>7)then
                        begin
                          MenuN := 8;
                          MenuScroll :=0;
                        end;

                      End;
               end
                else
                 begin
        /// Новое условие
                  D2 := GetPosAndDist(Route[RouteN].x1, Route[RouteN].y1, Route[RouteN].x2, Route[RouteN].y2, cx, cy);

                   if (((abs(Azimuth-AzimuthtoCurrent-pi)<pi/2)or(abs(Azimuth-pi-AzimuthtoCurrent-2*pi)<pi/2)
                        or(abs(Azimuth-AzimuthtoCurrent-pi+2*pi)<pi/2) )
                          and ((DistToCurrent<MinDistToCurrent)) and not (ReflyCurrent))
          /// СОВСЕМ Новое условие
                        OR (( ((abs(Azimuth-AzimuthtoCurrent-pi)<pi/6)or(abs(Azimuth-pi-AzimuthtoCurrent-2*pi)<pi/6)
                           or(abs(Azimuth-AzimuthtoCurrent-pi+2*pi)<pi/6) )
                          and ((DistToCurrent<MinDistToCurrent*2)) and not (ReflyCurrent)) and (D2.Dist < RouteMaxDist*2) )


                          then
                   Begin
                     Mashtab := AutoM[5];
                     MapMode := 3 + AutoM[6];
                     Follow := True;
                   End
                    else
                      Begin
                        Mashtab := AutoM[7];           //// Что было до нового условия
                        MapMode := 3 + AutoM[8];
                        DistToBase := -1;
                        Follow := (MapMode>2)and(MapMode<6);
                      End;

                   if MenuN = 8 then  /// Расстояние снова меньше 2500
                     MenuN := 1;
                 end;
            end;
       End;

  End;
end;

procedure TMainForm.FormActivate(Sender: TObject);
begin

  if JustStarted then
     Autorun;

  JustStarted := false;

  AllowAuto := AutoOn;

  if RealTime then
  Begin  /// LOAD ODO
     try
       Odometr := StrToFloat(Odo[0]);
     except
       Odometr :=0;
     end;
  End;

  {RecZone := WaitForZone;
  if not WaitForZone then
     Zone := MyZone;}


  if not Timer.Enabled then
      Timer.Enabled:= true;


  if not AllowMouse  then
  Begin
    Panel1.Cursor := crNone;
   // Panel2.Cursor := crNone;
  End
    else
      Begin
        Panel1.Cursor := crCross;
        //Panel2.Cursor := crArrow;
      End;

  if CropRoutes then
    MaxDotsVisible := 1000
     else
        MaxDotsVisible := MaxDotsCount;

  FormResize(nil);
end;

procedure TMainForm.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  SaveLogFile;
  SaveTrack;

  if MarkerCount >0 then
  if MessageDlg(Mainform.Inf[59],mtConfirmation,[mbYes, mbNo],0) = 6 then
  Begin             
    Settings.SaveDialog.FileName := Settings.MarkerFile.Text;
    if Settings.SaveDialog2.Execute() then
       Settings.SaveMarkers(Settings.SaveDialog2.FileName);
  End;

  if Settings.ShowReport.Checked then
  Begin
     if Settings.AReport.Checked then
     Begin
       SetCurrentDir(MyDir+'Utils\');
       if SizeTrackRecord > 0 then
         winexec(PChar(MainForm.MyDir+'Utils\EstimHgt.exe ..\Data\LastTrack.log'),sw_restore);
     End
      else
       Begin
        if RealTime then
           Executefile(ReportFileName+'_routes.txt','','',sw_show)
           else
            Executefile(ReportFileName+'_emulroutes.txt','','',sw_show);
       End;
  End;

end;

procedure TMainForm.FormCreate(Sender: TObject);
  var Year, Month, Day : Word ;
      s : string;
      i : integer;
begin
 MyDir := GetCurrentDir + '\';
{ LogDir := MyDir + 'Logs\';
 DataDir := MyDir + 'Data\';
 GPSDataDir := MyDir + 'Logs\GPS\';
 LogDataDir := MyDir + 'Logs\Tracks\';
 RepDataDir := MyDir + 'Logs\Reports\';
 Rep2DataDir := MyDir + 'Logs\Other\';

 if DirectoryExists(LogDir) = False then
    ForceDirectories(LogDir);
 if DirectoryExists(DataDir) = False then
    ForceDirectories(DataDir);
 if DirectoryExists(GPSDataDir) = False then
    ForceDirectories(GPSDataDir);
 if DirectoryExists(LogDataDir) = False then
    ForceDirectories(LogDataDir);
 if DirectoryExists(RepDataDir) = False then
    ForceDirectories(RepDataDir);
 if DirectoryExists(Rep2DataDir) = False then
    ForceDirectories(Rep2DataDir);     }


 GeoInit('Data\Sources.loc');
 SK := FindDatum('SK42');
 WGS := FindDatum('WGS84') ;

 JustStarted := true;
 MarkerCount := 0;

 // Enable Delphi debugger
 ReportMemoryLeaksOnShutdown:= DebugHook <> 0;

 // Set the display size
 DisplaySize:= Point2px(ClientWidth, ClientHeight);
 MenuX := DisplaySize.X - MenuW;

 // Indicate that we're using DirectX 9
 OpenGL := false;
 if ParamStr(1)='-gl' then
     OpenGL := true;
     
 if OpenGL then
   Factory.UseProvider(idOpenGL)
     else
      Factory.UseProvider(idDirectX9);

 // Create Asphyre components in run-time.
 AsphDevice:= Factory.CreateDevice();
 AsphCanvas:= Factory.CreateCanvas();
 AsphImages:= TAsphyreImages.Create();
 AsphMapImages:= TAsphyreImages.Create(); 

 AsphFonts:= TAsphyreFonts.Create();
 AsphFonts.Images:= AsphImages;
 AsphFonts.Canvas:= AsphCanvas;

 MediaASDb:= TASDb.Create();
 MediaASDb.FileName:= ExtractFilePath(PChar(DataDir)) + 'media.asdb';
 MediaASDb.OpenMode:= opReadOnly;

 AsphDevice.WindowHandle:= Self.Handle;
 AsphDevice.Size    := DisplaySize;
 AsphDevice.Windowed:= True;
 AsphDevice.VSync   := True;

 EventDeviceCreate.Subscribe(OnDeviceCreate, 0);

 // Attempt to initialize Asphyre device.
 if (not AsphDevice.Initialize()) then
  begin
   ShowMessage('Failed to initialize Asphyre device.');
   Application.Terminate();
   Exit;
  end;

 // Create rendering timer.
 Timer.OnTimer  := TimerEvent;
 Timer.OnProcess:= ProcessEvent;
 Timer.Speed    := 60.0;
 Timer.MaxFPS   := 4000;
 Timer.Enabled  := True;

 SmoothAzimuth := true;
 GPSBuffer := TStringList.Create;
 AUXBuffer := TStringList.Create;
 EmulBuffer := TStringList.Create;
 RecieveList := TStringList.Create;
 RecieveList2 := TStringList.Create;
 GPSLog := TStringList.Create;
 Odo := TStringList.Create;
 Report := TStringList.Create;

 MenuN := 1;
 MenuScroll := 0;
 _MenuScroll := 0;
 MapMode := 1;
 DopFat := 0;
 Azimuth := 0.0;
 MaxDotsVisible := MaxDotsCount;
 EmulProgress := 0;
 OldEmulProgress := 0;
 EmulSpeed := 0;
 RouteStep := 1;
 RouteMaxDist := 100;
 LastFollowedTime := -1;
 CurrentRouteAngle := 0;
 RouteAsk :=-1;
 WorstDist := false;
 MinDistToFix := 900;
 HideNext := false;

 if DirectoryExists(MyDir+'Logs') then
    ForceDirectories(MyDir+'Logs');

 DecodeDate(Date, Year, Month, Day);
 Str ( Year, GPSLogFileName );
 Str (  Month , s );
 if Month < 10 then
    s := '0'+s ;
 GPSLogFileName := GPSLogFileName + '-' + s ;
 str ( Day , s );
 if Day < 10 then
    s := '0'+s ;
 GPSLogFileName := GPSLogFileName + '-'  + s;

 ReportFileName := RepDataDir + GPSLogFileName;
 Report2FileName:= Rep2DataDir + GPSLogFileName;
 TrackFileName := LogDataDir + GPSLogFileName;
 GPSLogFileName := GPSDataDir + GPSLogFileName;
 
 _GPSLogFileName :=  GPSLogFileName;

 GPSLogFileName :=  GPSLogFileName +'.GPS';

  for I := 1 to LogsMax do
  begin
        s := _GPSLogFileName+'_'+ intToStr(i) +'.GPS';
        if Fileexists(s) then
           GPSLogFileName  := s
             else
               break;
  end;

  for I := 1 to 12 do
    JoyKeyPress[I] := false;

  JCom[1] := 3;
  JCom[2] := 1;
  JCom[3] := 4;
  JCom[4] := 6;
  JCom[5] := 8;
  JCom[6] := 7;
  JCom[7] := 5;
  JCom[9] := 10;

  RoutesTabStart := 0;
  RoutesNameTab := 0;
  RoutesXTab := 1;
  RoutesYTab := 2;
  RoutesZTab := 3;
  RoutesX2Tab := 3;
  RoutesY2Tab := 4;
  RoutesZ2Tab := 6;

  isRoutesDatum := True;
  RoutesDatum := WGS;
  RoutesCS := 0;
  
  AskMark :=-1;
  
  if Fileexists(GPSLogFileName) then
    GPSLog.LoadFromFile(GPSLogFileName);

  if Fileexists(LogDir+'Odo.log') then
    Odo.LoadFromFile(LogDir+'Odo.log')
     else
       Odo.Add('0');

  Report.Add(InttoStr(Year)+'-'+InttoStr(Month)+'-'+InttoStr(Day));
  Report.Add('');
  Report.Add(Inf[68]);

 if Fileexists(ReportFileName+'_routes.txt') then
 begin
    Report.LoadFromFile(ReportFileName+'_routes.txt');
    Report.Add('');
 end;



end;

//---------------------------------------------------------------------------
procedure TMainForm.FormDestroy(Sender: TObject);
begin
 Timer.Enabled:= False;
 if RealTime then
 Begin
    Odo.Clear;
    Odo.Add(FloatToStr(Odometr));
    Odo.SaveToFile(LogDir+'Odo.log');
 End;

 if GPSLog.Count > 0 then
   GPSLog.SaveToFile(GPSLogFileName);

 if Report.Count > 4 then
 Begin
   if RealTime then
      Report.SaveToFile(ReportFileName+'_routes.txt')
      else
         Report.SaveToFile(ReportFileName+'_emulroutes.txt');
 End;


 // Release all Asphyre components.
 FreeAndNil(AsphFonts);
 FreeAndNil(AsphImages);
 FreeAndNil(AsphMapImages);
 FreeAndNil(MediaASDb);
 FreeAndNil(AsphCanvas);
 FreeAndNil(AsphDevice);
 ComPort1.Destroy;
 ComPort2.Destroy;
 GPSBuffer.Destroy;
 AUXBuffer.Destroy;
 GPSLog.Destroy;
 EmulBuffer.Destroy;
 RecieveList.Destroy;
 RecieveList2.Destroy;
 Odo.Destroy;
 Report.Destroy;
end;

procedure TMainForm.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin

  if Key = VK_F2 then
    if Windowstate = wsMaximized then
    begin
      Windowstate := wsNormal;
      BorderStyle := BsSingle;
    end
      else
        Begin
          BorderStyle := BsNone;
          Windowstate := wsMaximized;
        End;

  if Key = VK_F1 then
  begin
    Timer.Enabled:= False;
    if OpenGL then
    begin
       // WindowState := wsMinimized;
        AsphDevice.Windowed := true;
    end;
    Settings.ShowModal;
  end;

  if Key = VK_F3 then
    if SizeTrackRecord > 0 then
       PutBaseHere(TrackRecord[SizeTrackRecord -1].Lat,
                   TrackRecord[SizeTrackRecord -1].Long);

  if Key = VK_F5 then
    Panel5.Visible := not (Panel5.Visible);

  if Key = VK_F4 then
    ShowFPS := not (ShowFPS);

  if Key = VK_F7 then
    begin
      ConnectCOM(ComPort1);
      ConnectCOM(ComPort2);
    end;

  if Key = VK_F8 then
     SaveTrack;

  if Key = VK_F12 then
    Close;

  if Key = 73 then
    ShowInfo := not (ShowInfo);

  if Key = 81 then
    if AllowAuto then
       AutoOn := not AutoOn;

  if Key = VK_Up then
    MenuKeyCommand(1);

  if Key = VK_Down then
    MenuKeyCommand(2);

 if Key = VK_Left then
    MenuKeyCommand(3);

 if Key = VK_Right then
    MenuKeyCommand(4);

 if Key = VK_Return then
    MenuKeyCommand(5);

 if Key = VK_Escape then
    MenuKeyCommand(6);

//// + - клавиши

 if (Key = 187) or (Key = 107) then
    Shiftmap(1);

 if (Key = 189) or (Key = 109) then
    Shiftmap(0);

//// W S A D

 if (Key = 87) then
    Shiftmap(2);

 if (Key = 83) then
    Shiftmap(3);

 if (Key = 65) then
    Shiftmap(4);

 if (Key = 68) then
    Shiftmap(5);


 if (Key = 78) then
 Begin
   ShowNext := true;
   ShowNextTime := 100;
 End;

 if (Key = 77)or(Key = vk_F6) then
 Begin
   ShowMaps := not ShowMaps;

   if ShowMaps then
     RecomputeMaps(False);
 End;

 if (Key = 84) then
 Begin
   if MaxDotsVisible = 0 then
      MaxDotsVisible := MaxDotsCount
       else
         if MaxDotsVisible = MaxDotsCount then
            MaxDotsVisible := 1000
              else
                if MaxDotsVisible = 1000 then
                   MaxDotsVisible := 0
 End;

end;

procedure TMainForm.FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
var Max : Integer;
begin
 if AllowMouse then
  BEGIN
   if MousePos.x < Panel1.ClientWidth-MenuW + Left then// Panel2.Left+MainForm.Left  then
   Begin
     if (AutoOn = false) or (ChangeAutoM) then
     ShiftMap(0)
   End
   else
    begin
     Max :=  MenuCount[MenuN];
     if (MenuN=5) or (MenuN=6) then
        Max :=  RouteCount-1;

     if (Max+1)*MenuButtonSize[MenuN]>DisplaySize.y then
       begin
         if MenuScroll > -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)  then
            MenuScroll := MenuScroll - MenuButtonSize[MenuN];
         if MenuScroll < -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y) then
            MenuScroll := -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)
       end;
    end;
  END;
end;

procedure TMainForm.FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
  if AllowMouse then
  BEGIN
   if MousePos.x < Panel1.ClientWidth-MenuW + Left then
   begin
     if (AutoOn = false) or (ChangeAutoM) then
     ShiftMap(1)
   end
    else
     begin
       if MenuScroll < 0 then
         MenuScroll := MenuScroll + MenuButtonSize[MenuN];
       if MenuScroll > 0 then
          MenuScroll := 0;
     end;
  END;
end;

procedure TMainForm.FormResize(Sender: TObject);
begin
  DisplaySize := Point2px(Panel1.ClientWidth, Panel1.ClientHeight);
  AsphDevice.Size := DisplaySize;
  MenuX := DisplaySize.X - MenuW;
end;

procedure TMainForm.FormShow(Sender: TObject);
begin

  if not Timer.Enabled then
      Timer.Enabled:= true;

  //if OpenGL then
   // begin
       // AsphDevice.Reset;
        Resize;
  //  end;
end;

function TMainForm.GetCOMN(N: integer):integer;
var I : Integer;
begin
 case N of
    1:   if Settings.NCom.ItemIndex<10 then
           result := Settings.NCom.ItemIndex
            else
             result := Settings.ComSp.Value-1;



         /// rewrite for com2
    2:  if Settings.NCom2.ItemIndex<10 then
           result := Settings.NCom2.ItemIndex
            else
             result := Settings.ComSp2.Value-1;

 end;


end;

function TMainForm.GetDistToRoute(RouteN : integer; x, y: double): Double;
var x1, y1, x2, y2, _x, _y, t, c, _y0: Double;
begin
  Result := -1;
  try
     x1 := Route[RouteN].x1;
     x2 := Route[RouteN].x2;
     y1 := Route[RouteN].y1;
     y2 := Route[RouteN].y2;
     if x1=x2 then
     begin
       _y := y;
       _x := x1;
        c := (_y - y1) / (y2 - y1);
     end
        else
     if y1=y2 then
     begin
       _y := y1;
       _x := x;
        c := (_x - x1) / (x2 - x1);
     end
        else
     if abs(x2-x1)>abs(y2-y1) then
     Begin
       t :=  (y2-y1)/(x2-x1);
       c := 1/t;

       _y0 := c*(x-x1) + (y-y1);

       _x := x1 + (  _y0/(t+c) );
       _y := y1 + ( t*(_x-x1) );

        c := (_x - x1) / (x2 - x1);
     End
        else
          Begin
            t := (x2-x1)/(y2-y1);
            c := 1/t;

            _y0 := (x-x1) + c*(y-y1);        /// Here _y0 as _x0

            _y := y1 + (  _y0/(t+c) );
            _x := x1 + ( t*(_y-y1) );

            c := (_y - y1) / (y2 - y1);
          End;

     Result := SQRT(SQR(x-_x)+SQR(y-_y));

     /// Если не попадаю на отрезок
     AfterEnd := c > 1;
     BeforeBegin := c < 0 ;

     RouteProgress := -1;
     if  (c >= 0) and (c <= 1) then
        RouteProgress := trunc(c*100);

     AzimuthToRoute := -1;
     if BeforeBegin then
     Begin
          Result := SQRT(SQR(x-x1)+SQR(y-y1));

          if Result>1 then
             AzimuthToRoute := ArcTan2(x-x1, y-y1);
     End
          else
            if AfterEnd then
            Begin
              Result := SQRT(SQR(x-x2)+SQR(y-y2));

              if Result>1 then
                 AzimuthToRoute := ArcTan2(x-x2, y-y2);
            End
             else
                if Result>1 then
                AzimuthToRoute := ArcTan2(x-_x, y-_y);

  except
    Result := -1;
  end;

end;


procedure TMainForm.GetDistToBase(cx, cy: double);
begin
  DistToBase :=-1;
  if SizeTrackRecord>0 then
  Try
    DistToBase := Trunc(SQRT(Sqr(Base[1].x - cx) + Sqr(Base[1].y - cy)));
    if DistToBase>1 then       //zx
       AzimuthToBase := ArcTan2(cx-Base[1].x, cy-Base[1].y);
  Except
  End;
end;

procedure TMainForm.GetNearestRoute(cx, cy: double);
var I : Integer;
    L, L2, Lmin : real;
    isBegin : Boolean;
    aim: TMyPoint;
begin
  NearestRoute := -1;
  NearestDist := -1;
  Lmin :=0;
  try
    for I := 0 to RouteCount - 1 do
    if Route[I].Status<=1 then
    Begin

      isBegin := true;
      L := Sqr(Route[i].x1-cx)+Sqr(Route[i].y1-cy);
      L2 := Sqr(Route[i].x2-cx)+Sqr(Route[i].y2-cy);

      if L2<L then
      begin
        L := L2;
        isBegin := false;
      end;

      if I=0 then
      BEGIN
      
        NearestRoute := 0;
        Lmin := L;
        //NearestIsBegin := IsBegin;

        if IsBegin then
        Begin
          Aim.x := Route[i].x1;
          Aim.y := Route[i].y1;
        End
          Else
          Begin
            Aim.x := Route[i].x2;
            Aim.y := Route[i].y2;
          End;
      END
       ELSE
        if (L < Lmin)or(NearestRoute=-1) then
        BEGIN

          NearestRoute := i;
          Lmin := L;
          //NearestIsBegin := IsBegin;

          if IsBegin then
          Begin
            Aim.x := Route[i].x1;
            Aim.y := Route[i].y1;
          End
            Else
              Begin
                Aim.x := Route[i].x2;
                Aim.y := Route[i].y2;
              End;
        END;
    End;
    NearestDist := Trunc(Sqrt(Lmin));

    if NearestDist>1 then       //zx
       AzimuthToNearest := ArcTan2(cx-Aim.x, cy-Aim.y);

  except
      NearestRoute := -1;
      NearestDist := -1;
  end;
end;

procedure TMainForm.GetNextRoute;
var i, j, step, k : integer;
    Done : boolean;
begin
   NextRoute := -1;
   DistToNext:=0;
   I := CurrentRoute;
   step := RouteStep;
   Done := false;

//   BackStep := not BackStep;

   if (RoundFly) then
   BEGIN
       //// ПЕТЛИ

   for k := 0 to 1 do
   Begin

      if BackStep = false then
      Begin
        if I+step <= RouteCount-1 then
        begin
          If  Route[I+step].Status = 0 then
          Begin
            NextRoute := I+step;
            Done := true;
            BackStep := true;
            break;
          End
      end
   End else
      if I-step+1 >= 0 then
      begin
        If  Route[I+1-step].Status = 0 then
          Begin
            NextRoute := I+1-step;
            Done := true;
            BackStep := false;
            break;
          End
       end;

     if not Done then
       BackStep := not BackStep;

   End;

   END;

   if not(RoundFly) or (Done= false) then
   BEGIN
     for step := RouteStep Downto 1 do
     Begin
       if I+step <= RouteCount - 1 then
         if Route[I+step].Status = 0 then
         Begin
            NextRoute := I+step;
            Done := true;
            break
         End;

       if I-step >= 0  then
         if Route[I-step].Status = 0 then
         Begin
            NextRoute := I-step;
            Done := true;
            break
         End;
     End;

     if Done = false then
       for j := 0 to RouteCount-1 do
       begin
         if I+j <= RouteCount-1 then
           If  Route[I+j].Status = 0  then
           Begin
             NextRoute := I+j;
             Done := true;
             break
           End;

         if I-j >= 0  then
           If  Route[I-j].Status = 0  then
           Begin
             NextRoute := I-j;
             Done := true;
             break
           End;
        end;

   END;

   CurToNextDist;
   ReCalcWay := true;
end;

function TMainForm.GetRouteAngle(RouteN: integer): Double;
begin
  Result := 0;
  if RouteN<>-1 then
    if RouteN < RouteCount then
    Begin
      Result := ArcTan2(Route[RouteN].x2-Route[RouteN].x1, Route[RouteN].y2-Route[RouteN].y1);
    End;
    if Result<0 then
       Result := Result + 2*pi
        else
        if Result > 2*pi then
          Result := Result - 2*pi

end;


function TMainForm.GetTurnPoints(xp, yp, azmt, x1, y1, x2, y2, MinR, MaxR: double): boolean;

function ang(a:double):double;
begin
   while (a<0)or(a>2*pi) do
   begin
      if a < 0 then
        a := a + 2*pi;
      if a > 2*pi then
        a := a - 2*pi;
   end;
   result := a;
end;

   
var i,j,k:integer;

    Az1, _Az1, Az2, Az3, Az4, dA, _dA, dA0, _dA0, R, cx, cy, cx2, cy2, step : double;

    RP, RP2 : TPosAndDist;
    cxy : TMyPoint;

    Dmin,L : double;

    AngStep : real;
    isRight, SideStep, SideStep0, OddStep, NeedShift, NeedLC: boolean;
begin
    ReCalcWay := false;
    needlc := false;

//    STT := SpecialTP;

    if LocalTP then
    begin

      if not SPecialTP then
      if (LocalR1 = PrevRoute) and (LocalR2 = CurrentRoute) and (not ReflyCurrent) then
      Begin
        Result := true;
        exit;
       End;

        if ReflyCurrent then
           LocalR1 := -1;

       if not SPecialTP then
       if (PrevRoute = -1) or (CurrentRoute =-1) then
       Begin
         TPCount :=0;
         exit;
       End;

       SpecialTP := false;
       
       if CurrentRoute = PrevRoute then
           exit;

       if not ReflyCurrent then
       Begin
         LocalR1 := PrevRoute;
         LocalR2 := CurrentRoute;

       ///  Az2 := ang(arctan2(x2-x1,y2-y1));
       End;
    end;


    if LocalTP then
    Begin
       xp := xp +  MinR/4*Sin(azmt);
       yp := yp +  MinR/4*Cos(azmt);
    End;


    if SpecialTP then
      if NextRoute = -1 then
         exit;

    if ReflyCurrent then
           LocalR1 := -1;


    SpecialTP := false;

    TurnPoints[0].x := xp;
    TurnPoints[0].y := yp;

    TPCount :=1;
    NeedShift := false;
    try
      /// 1

      Az1 := ang(azmt);
      Az2 := ang(arctan2(x2-x1,y2-y1));

      isRight := ang(arctan2(xp-x1,yp-y1) - az2) < pi;

      dA  := ang(Az2 - Az1);
      _dA := ang(Az2 + pi - Az1);



     // isClockwise := not( (dA < pi/2)or( dA > 3*pi/2 ) );

      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);


       if (abs(dA) = pi) then
         R := RP.Dist/2
         else
         if (dA = 0)or(dA = 2*pi) then
           R := MaxR
           else
             R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

       SideStep0 := ( (dA < pi/2)or( dA > 3*pi/2 ));
       SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

       OddStep := true;
       AngStep := 0;
       _Az1 := Az1;

       if R < MinR then
        begin
          if (Sidestep) and(RP.Pos < 0) then
          Begin
            { TPCount := 1;
             TurnPoints[1].x :=  x1;
             TurnPoints[1].y :=  y1;
             exit}

              cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                    begin
                       TurnPoints[1].x :=  x1;
                       TurnPoints[1].y :=  y1;
                    end;

                  exit;

          End else
          while (R < minR) {and (not SideStep)} and (AngStep < pi) do
          Begin

              if OddStep then
                  AngStep := AngStep + 0.01;

              if OddStep then
                   Az1 := _Az1 - AngStep
                     else
                       Az1 := _Az1 + AngStep;

             if OddStep <> isRight then
              Begin
                  OddStep := not OddStep;
                   continue;
              End;

               dA  := ang(Az2 - Az1);
               _dA := ang(Az2 + pi - Az1);
               RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

               if (abs(dA) = pi) then
                 R := RP.Dist/2
                  else
                  if (dA = 0)or(dA = 2*pi) then
                     R := MaxR
                        else
                          R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

               SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

               OddStep := not OddStep;

          End;
        end;

      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);
      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

      if (SideStep0)and(RP.Dist < RouteMaxDist*1.5){and(RP.Pos <0)} then
      Begin
       { TPCount := 1;
        TurnPoints[1].x :=  x1;
        TurnPoints[1].y :=  y1;}

         cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

         TPCount := 1;
         TurnPoints[1].x :=   cxy.x;
         TurnPoints[1].y :=   cxy.y;
         if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
         Begin
            TurnPoints[1].x :=  x1;
            TurnPoints[1].y :=  y1;
         End;

        if RP.Dist< RouteMaxDist then
           TPCount := 0;
        exit;
      End;

      if R >= MaxR then
      Begin

        SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));

        if not isRight then
        begin
           Az3 := az1+pi/2;
           dA0 := ang(Az2 +pi/2 - Az1);
           _da0 :=  -pi/2;
           Az4 := (Az2 + pi);

           R := (MaxR+MinR)/2;
           cx := xp - R*Sin(az3);
           cy := yp - R*Cos(az3);
           cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
           cx2 := cxy.x;
           cy2 := cxy.y;

           if SideStep Then
           Begin

             Az3 := Az1-pi/2;
             Az4 := (Az2 - pi);
             ///_da0 :=  -pi/2;

             R := MinR;
             cx := xp + R*Sin(az3+pi);
             cy := yp + R*Cos(az3+pi);

             cxy := GetNormalPt(x1, y1, x2, y2, cx + 2*R*Sin(az2) , cy + 2*R*Cos(az2), isRight, R);
             cx2 := cxy.x ;
             cy2 := cxy.y ;

             RP2 := GetPosAndDist(x1, y1, x2, y2, cx2, cy2);

             if RP2.Pos > 0 then
             Begin
               /// CANCEL!
               SideStep := false;
               Az3 := az1+pi/2;
               dA0 := ang(Az2 +pi/2 - Az1);
              ///_da0 :=  -pi/2;
               Az4 := (Az2 + pi);

               R := (MaxR+MinR)/2;
               cx := xp - R*Sin(az3);
               cy := yp - R*Cos(az3);
               cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
               cx2 := cxy.x;
               cy2 := cxy.y;


               if R < MinR then
               begin
                    OddStep := true;
                    AngStep := 0;
                    while (R < minR) and (AngStep < pi) do
                    Begin

                      if OddStep then
                        AngStep := AngStep + 0.01;

                      if OddStep then
                       Az1 := _Az1 - AngStep
                        else
                          Az1 := _Az1 + AngStep;

                      dA  := ang(Az2 - Az1);
                      _dA := ang(Az2 + pi - Az1);
                      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

                      if (abs(dA) = pi) then
                         R := RP.Dist/2
                            else
                            if (dA = 0)or(dA = 2*pi) then
                              R := MaxR
                                else
                                  R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

                      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));
                      OddStep := not OddStep;

                  End;
                end;

             End;


           End;

           if SideStep Then
           Begin
               if  RP.Dist > 2*MinR then
               BEGIN
                  step := ang(dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  MinR*Sin(az3+step*I)+cx;
                      TurnPoints[I].y :=  MinR*cos(az3+step*I)+cy;
                  end;


                 step := ang(-_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4-(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4-(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
               END
                ELSE
                BEGIN             
                  {TPCount := 1;
                  TurnPoints[1].x :=  x1;
                  TurnPoints[1].y :=  y1;}
                  cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                  Begin
                    TurnPoints[1].x :=  x1;
                    TurnPoints[1].y :=  y1;
                  End;
                    exit;
                END;
           End
             else
              Begin

                  step := ang(-dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az3-step*I)+cx;
                      TurnPoints[I].y :=  R*cos(az3-step*I)+cy;
                  end;


                  step := ang(-_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4-(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4-(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
              End;

        end
           else
           begin

             Az3 := Az1-pi/2;
             dA0 := ang(Az2 -pi/2 - Az1);
             Az4 := (Az2 - pi);
             _da0 :=  pi/2;

             R := (MaxR+MinR)/2;
             cx := xp - R*Sin(az3);
             cy := yp - R*Cos(az3);
             cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
             cx2 := cxy.x;
             cy2 := cxy.y;

           if SideStep Then
           Begin

             Az3 := Az1 + pi/2;
             Az4 := (Az2 + pi);

             R := MinR;
             cx := xp + R*Sin(az3+pi);
             cy := yp + R*Cos(az3+pi);

             cxy := GetNormalPt(x1, y1, x2, y2, cx + 2*R*Sin(az2) , cy + 2*R*Cos(az2), isRight, R);
             cx2 := cxy.x ;
             cy2 := cxy.y ;

             RP2 := GetPosAndDist(x1, y1, x2, y2, cx2, cy2);

             if RP2.Pos > 0 then
             Begin
               //// Cancel!

                Az3 := Az1-pi/2;
                dA0 := ang(Az2 -pi/2 - Az1);
                Az4 := (Az2 - pi);
               // _da0 :=  pi/2;

                 R := (MaxR+MinR)/2;
                 cx := xp - R*Sin(az3);
                 cy := yp - R*Cos(az3);
                 cxy := GetNormalPt(x1, y1, x2, y2, cx, cy, isRight, R);
                 cx2 := cxy.x;
                 cy2 := cxy.y;

                 SideStep := false;

                 if R < MinR then
               begin
                    OddStep := true;
                    AngStep := 0;
                    while (R < minR) and (AngStep < pi) do
                    Begin

                      if OddStep then
                        AngStep := AngStep + 0.01;

                      if OddStep then
                       Az1 := _Az1 - AngStep
                        else
                          Az1 := _Az1 + AngStep;

                      dA  := ang(Az2 - Az1);
                      _dA := ang(Az2 + pi - Az1);
                      RP := GetPosAndDist(x1, y1, x2, y2, xp, yp);

                      if (abs(dA) = pi) then
                         R := RP.Dist/2
                            else
                            if (dA = 0)or(dA = 2*pi) then
                              R := MaxR
                                else
                                  R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

                      SideStep := ( (dA < pi/2)or( dA > 3*pi/2 ));
                      OddStep := not OddStep;

                  End;
                end;
             End;


           End;

           if SideStep Then
           Begin
               if  RP.Dist > 2*MinR then
               BEGIN
                  step := ang(-dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  MinR*Sin(az3-step*I)+cx;
                      TurnPoints[I].y :=  MinR*cos(az3-step*I)+cy;
                  end;


                 step := ang(_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4+(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4+(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
               END
                ELSE
                BEGIN
                 { TPCount := 1;
                  TurnPoints[1].x :=  x1;
                  TurnPoints[1].y :=  y1;
                  exit;}

                  cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

                  TPCount := 1;
                  TurnPoints[1].x :=   cxy.x;
                  TurnPoints[1].y :=   cxy.y;
                  if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
                  Begin
                     TurnPoints[1].x :=  x1;
                     TurnPoints[1].y :=  y1;
                  End;
                    exit;
                END;
           End
             else
              Begin

                  step := ang(dA0)/24;
                  for I := 0 to 24 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az3+step*I)+cx;
                      TurnPoints[I].y :=  R*cos(az3+step*I)+cy;
                  end;


                  step := ang(_dA0)/8;
                  for I := 25 to 33 do
                  begin
                      TurnPoints[I].x :=  R*Sin(az4+(step)*(I-25))+cx2;
                      TurnPoints[I].y :=  R*cos(az4+(step)*(I-25))+cy2;
                  end;

                  TPCount := 33;
              End;

           end;


      End else
      Begin
       /// Caption := IntToStr(Trunc(RP.DistTo0));

        ///  4    if Ok
        if not isRight then
          az3 := az1+pi/2
           else
             az3 := az1-pi/2;

         cx := xp - R*Sin(az3);
         cy := yp - R*Cos(az3);

         RP2 := GetPosandDist(x1,y1,x2,y2,cx,cy);

        if ( ( abs(RP.DistTo0)<MaxR)and((R> MaxR)or(R<MinR)and(not SideStep0)) {or (RP.Pos > 0)} or (RP2.Pos > 0.01) ) and (R< MaxR)or(R<MinR) and
            ((not isRight)and((_dA)<pi)or
             ( isRight)and(ang(-_dA)<pi)) then
         begin
           NeedLC := true;

           if not isRight then
            Az1 := az2 - pi/2 //ang(az1-pi/4)
             else
               Az1 := az2 + pi/2;// ang(az1+pi/4);

            dA  := ang(Az2 - Az1);
            _dA := ang(Az2 + pi - Az1);

            if (abs(dA) = pi) then
                 R := RP.Dist/2
                  else
                  if (dA = 0)or(dA = 2*pi) then
                     R := MaxR
                        else
                          R := tan((_dA)/2) * (RP.Dist/Sin(_dA));
             if R < MinR then
             Begin
               R := MinR;
               NeedShift := true;
             End;

          if not isRight then
          az3 := az1+pi/2
           else
             az3 := az1-pi/2;

           cx := xp - R*Sin(az3);
           cy := yp - R*Cos(az3);

         end;

        // SideStep := ( (ang(dA) < pi/2)or( ang(dA) > 3*pi/2 ));
         SideStep :=  (not isRight) and (ang(dA) < pi/2)or (isRight) and ( ang(dA) > 3*pi/2 );

         if (SideStep0) and ((RP.Pos < 0) and not(ReflyCurrent){and(abs(RP.DistTo0) < MaxR)}) Then
           Begin
            { TPCount := 1;
             TurnPoints[1].x :=  x1;
             TurnPoints[1].y :=  y1;
             exit;}
              cxy := GetNormalPt(x1,y1,x2,y2, xp + sin(az2)*RP.Dist, yp + cos(az2)*RP.Dist, isRight,0);

              TPCount := 1;
              TurnPoints[1].x :=   cxy.x;
              TurnPoints[1].y :=   cxy.y;

              if GetPosAndDist(x1,y1,x2,y2,cxy.x,cxy.y).Pos > 0 then
              Begin
                 TurnPoints[1].x :=  x1;
                 TurnPoints[1].y :=  y1;
              End;

              exit;

            // FOrm1.Memo1.Lines.Add('rrr');
           end;
            {else
              if (SideStep) and }

       ///// if Ok      2

         TPCount := 24;

         if not isRight then
         Begin
           step := ang(-dA)/24;

           for I := 0 to 24 do
           begin
             TurnPoints[I].x :=  R*Sin(az3-step*I)+cx;
             TurnPoints[I].y :=  R*cos(az3-step*I)+cy;
           end;

         End
          else
          Begin
            step := ang(dA)/24;

            for I := 0 to 24 do
            begin
              TurnPoints[I].x :=  R*Sin(az3+step*I)+cx;
              TurnPoints[I].y :=  R*cos(az3+step*I)+cy;
            end;
          End;

       End;

       RP2 := GetPosAndDist(x1, y1, x2, y2, TurnPoints[TPCount].x, TurnPoints[TPCount].y);

       if NeedShift then
       for i:= 1 to TPCount do
       begin
          if not isRight then
            az4 := az2 + pi/2
              else
                az4 := az2 - pi/2;

          L := RP2.Dist;

          TurnPoints[i].x :=  TurnPoints[i].x - sin(az4)*L;
          TurnPoints[i].y :=  TurnPoints[i].y - cos(az4)*L;
       end;

      RP2 := GetPosAndDist(x1, y1, x2, y2, TurnPoints[TPCount].x, TurnPoints[TPCount].y);
      if RP2.Pos >0 then
      try


        dmin := pi;
        j:= 1;
        for i := 1 to TPcount do
        begin
          l := (ang(arctan2(TurnPoints[i].x - TurnPoints[i-1].x,
              TurnPoints[i].y - TurnPoints[i-1].y))-ang(pi+az2)) ;
          if abs(l) < abs(dmin) then
          begin
            dmin := l;
            j := i;
          end;
        end;



        L := sqrt(sqr(x2-x1)+sqr(y2-y1))*(RP2.Pos);
        for i:= j to TPCount do
        begin
               TurnPoints[i].x :=  TurnPoints[i].x - sin(az2)*L;
               TurnPoints[i].y :=  TurnPoints[i].y - cos(az2)*L;
        end;

      except
        TPCount := 0;
        exit;
      end;

      Result := true;

      

      if (localTP)and not(ReflyCurrent) then
      Begin
       { j := 1;
      if NeedLC then
         j := 2;}

        TurnPoints[TPCount+2].x :=  TurnPoints[TPCount].x ;
        TurnPoints[TPCount+2].y :=  TurnPoints[TPCount].y ;

        inc(TPCount);
        for i:= TPCount Downto 1 do
        begin
               TurnPoints[i].x :=  TurnPoints[i-1].x - sin(az2)*MinR*1.5;
               TurnPoints[i].y :=  TurnPoints[i-1].y - cos(az2)*MinR*1.5;
        end;
        inc(TPCount);




       if LocalTP then
       Begin
        ///// SMOOTH!
          dmin := pi/4;
          j:= 0;

          for i := 2 to trunc(TPcount/1.5) do
          begin
            l := ang( ang(arctan2(TurnPoints[i+1].x - TurnPoints[i].x,
                     TurnPoints[i+1].y - TurnPoints[i].y))) -
                     ang(arctan2(TurnPoints[i].x - TurnPoints[0].x,
                     TurnPoints[i].y - TurnPoints[0].y));
            if abs(l) < abs(dmin) then
            begin
             dmin := l;
             dA0 :=  ang(arctan2(TurnPoints[i+1].x - TurnPoints[i].x,
                     TurnPoints[i+1].y - TurnPoints[i].y));
             j := i;
            end;
          end;

          if j<2 then
             exit;

          if abs(ang(az2 - dA0)) > pi/10 then
          Begin

             {if NeedLC then
             Begin
                TurnPoints[1].x :=  TurnPoints[0].x - sin(az2)*MinR/2;
                TurnPoints[1].y :=  TurnPoints[0].y - cos(az2)*MinR/2;
             End
              else
              begin}
                 TurnPoints[1].x :=  TurnPoints[0].x - sin(az2)*MinR/2;
                 TurnPoints[1].y :=  TurnPoints[0].y - cos(az2)*MinR/2;
           //   end;

             if dmin < pi/4 then
             for i:= 2 to j do
             Begin
               TurnPoints[i].x :=  TurnPoints[1].x + (i)/j*(TurnPoints[j+1].x- TurnPoints[1].x);
               TurnPoints[i].y :=  TurnPoints[1].y + (i)/j*(TurnPoints[j+1].y- TurnPoints[1].y);
             End;

             for i:= 1 to j do
             Begin
               TurnPoints[i].x := (TurnPoints[i-1].x +   TurnPoints[i+1].x )/2;
               TurnPoints[i].y := (TurnPoints[i-1].y +   TurnPoints[i+1].y )/2;
             End;

            { if NeedLC then
             Begin
               TurnPoints[TPCount+3].x :=  TurnPoints[TPCount].x ;
               TurnPoints[TPCount+3].y :=  TurnPoints[TPCount].y ;

               for k := 0 to  1 do
               begin
                 inc(TPCount);
                 for i:= TPCount Downto 1 do
                 begin
                   TurnPoints[i].x :=  TurnPoints[i-1].x - sin(az2)*MinR/2;
                   TurnPoints[i].y :=  TurnPoints[i-1].y - cos(az2)*MinR/2;
                 end;
               end;
               inc(TPCount);

               for i:= 1 to j do
               Begin
                 TurnPoints[i].x := (TurnPoints[i-1].x +   TurnPoints[i+1].x )/2;
                 TurnPoints[i].y := (TurnPoints[i-1].y +   TurnPoints[i+1].y )/2;
               End;
             End;  }

            { Az1 := Az2;
             Az2 := dA0;

             isRight := ang(arctan2(TurnPoints[1].x-TurnPoints[j].x,
                            TurnPoints[1].y-TurnPoints[j].y) - az2) < pi;


             dA  := ang(Az2 - Az1);
             _dA := ang(Az2 + pi - Az1);

             RP := GetPosAndDist( TurnPoints[j+1].x, TurnPoints[j+1].y  , TurnPoints[j].x, TurnPoints[j].y ,
                                      TurnPoints[1].x,  TurnPoints[1].y);


             if (abs(dA) = pi) then
                  R := RP.Dist/2
                  else
                    if (dA = 0)or(dA = 2*pi) then
                      exit
                        else
                          R := tan((_dA)/2) * (RP.Dist/Sin(_dA));

             if not isRight then
                  az3 := az1+pi/2
                  else
                     az3 := az1-pi/2;

             cx := TurnPoints[0].x - R*Sin(az3);
             cy := TurnPoints[0].y - R*Cos(az3);

             if not isRight then
             Begin
                  step := ang(-dA)/(j-1);

                  for I := 1 to j do
                  begin
                      TurnPoints[I].x :=  R*Sin(az3-step*(I-2))+cx;
                      TurnPoints[I].y :=  R*cos(az3-step*(I-2))+cy;
                  end;

             End
                else
                  Begin
                    step := ang(dA)/(j-1);

                    for I := 1 to j do
                    begin
                      TurnPoints[I].x :=  R*Sin(az3+step*(I-2))+cx;
                      TurnPoints[I].y :=  R*cos(az3+step*(I-2))+cy;
                    end;
                  End;
                         }
                   //
                  ///         TurnPoints[0].x :=  cx;
                  //    TurnPoints[0].y := cy;

             End;
           

       End;

      End;
    except
      Result := false;
    end;
end;



function TMainForm.GetWGSCursor: TLatLong;
var xm, ym, x2: double;
Begin

      xm := Panel1CursorX - (DisplaySize.X - MenuW)/2;
      ym := -Panel1CursorY + DisplaySize.Y/2 + VYShift;
      x2 := xm;
      if MapModeDoRotate[MapMode] then
      begin
        if MapMode=5 then
        begin
           xm := xm * Cos (CurrentRouteAngle) + ym * sin(CurrentRouteAngle);
           ym := ym * Cos (CurrentRouteAngle) - x2* sin(CurrentRouteAngle);
        end
          else
          begin
            xm := xm * Cos (azimuth) + ym * sin (azimuth);
            ym := ym * Cos (azimuth) - x2* sin (azimuth);
          end;
      end;

      xm := xm * Scale + Center.X;
      ym := ym * Scale + Center.Y;

      if UTM then
         UTMToGeo(WGS,ym,xm,South,Result.lat,Result.long)
        else
          SKToWGS(ym,xm,0,Result.lat,Result.long);

  // ShowMessage(DegToDMS(Result.lat,4)+' '+DegToDMS(Result.long,4));
End;


procedure TMainForm.GoToNextRoute;
var L,L2 : longInt;
    OldRoute : integer;
    s : string;
begin
    OldRoute := CurrentRoute;
    if NumDist>0 then
      if not ReflyCurrent then
      begin
        Route[CurrentRoute].AverageDist := (sqrt(SumDist/NumDist));
        Route[CurrentRoute].BadHgts := round(100*(NumBadHgt/NumDist));

        if Route[CurrentRoute].badHgts = 0 then
          s := '-'
            else
              s := IntTostr(Route[CurrentRoute].badHgts)+' %';
//        if RealTime then    z
        FromBegin := not (FromBegin);
        Route[CurrentRoute].EndTime :=  CurTime ;
        Report.Add( Route[CurrentRoute].Name + #$9 + Route[CurrentRoute].StartTime + #$9
                    + Route[CurrentRoute].EndTime + #$9
                    + format('%.1f',[Route[CurrentRoute].AverageDist]) + inf[20] + #$9 + #$9
                    + s + #$9
                    + Route[CurrentRoute].RLabel);

        Route[CurrentRoute].RLabel :='';
      end;

    if not BadDist then
    begin
      if Route[CurrentRoute].AverageDist < RouteMaxDist/2 then
      begin
       Route[CurrentRoute].Status := 2
      end
        else
          Route[CurrentRoute].Status := 3;
    end
      else
      Begin
         if MenuN = 4 then
         begin
           MenuN := 1;
           MenuScroll :=0;
           RouteAsk :=-1;
         end;

          if not WorstDist then
             Route[CurrentRoute].Status := 3
               else
                begin
                  ReflyCurrent := True;
                  BadDist := false;
                  WorstDist := false;
                end;
      End;

    if not ReflyCurrent then
    Begin
        if NextRoute=-1 then
          GetNextRoute;

        if NextRoute<>-1 then
          SetCurrentRoute(NextRoute)
            else
             Begin               /// Routes are over
                CurrentRoute :=-1;
                if AutoON then
                begin
                  RouteAsk :=-1;
                  MenuScroll :=0;
                  MenuN := 10;
                end;
             End;
    End;

    if OldRoute<>CurrentRoute then
       PrevRoute := OldRoute;

    ReFlyCurrent := false;
    SumDist := 0;
    NumDist := 0;
    NumBadHgt := 0;
    BadDist := false;
    WorstDist := false;
   // BackStep := not BackStep;
end;

procedure TMainForm.GPSTimerEvent;
var i, j : Integer ;
      s1 : String ;
      s2 : String ;
begin


  if RealTime then
    begin
        if not OpenPort1 then exit ;
        i := GPSBuffer.Count;
        for j := 0 to i-1 do
           if GPSBuffer[j] <> #0 then
           begin
             CurrentS := GPSBuffer[j];
             GPSLog.Add(CurrentS);
             AnalyseStr(CurrentS);
           end;
        GPSBuffer.Clear;

        if EnableCOM2 then
        Begin
          i := AUXBuffer.Count;
          for j := 0 to i-1 do
            if AUXBuffer[j] <> #0 then
            begin
             CurrentS := AuxBuffer[j];
             AnalyseAUXStr(CurrentS, true);
            end;
           AUXBuffer.Clear;
        End;

    end
      else begin
      /// Режим воспроизведения
        if EmulProgress < EmulBuffer.Count-1 then
          if EmulSpeed > 0 then
          begin

            EmulProgress := EmulProgress + EmulSpeed*LagCount*0.2;
            I := OldEmulProgress;

            if trunc(EmulProgress) > OldEmulProgress+1 then
            begin
              for I := OldEmulProgress to trunc(EmulProgress) do
              begin
                if EmulProgress < EmulBuffer.Count-1 then
                begin
                  CurrentS := EmulBuffer[I];
                  AnalyseStr(CurrentS);
                end;
              end;
              OldEmulProgress := i;
            end;


           PBar.Position := trunc(100*EmulProgress/EmulBuffer.Count);
         end;
      end;

end;

procedure TMainForm.InitAutoMode;
var i: integer;
begin
 AutoOn := False;
 AutoM[1] := AutoSettings.M1Min+2;
 AutoM[2] := 0;
 AutoM[3] := AutoSettings.M3Min+1;
 AutoM[4] := 1;
 AutoM[5] := 2;
 AutoM[6] := 1;
 AutoM[7] := AutoSettings.M7Min+2;
 AutoM[8] := 1;
 AutoM[9] := 2;

 MinDistToCurrent := 200;

 AutoSettings.M1.Clear;
 AutoSettings.M2.Clear;
 AutoSettings.M3.Clear;
 AutoSettings.M4.Clear;
 AutoSettings.M5.Clear;
 AutoSettings.M6.Clear;
 AutoSettings.M7.Clear;
 AutoSettings.M8.Clear;


 for I := 0 to MaxMashtab - 1 do
 begin
    if (i >= AutoSettings.M1Min) then
        AutoSettings.M1.Items.Add(MashtabNames[I]);
    if (i >= AutoSettings.M3Min) then
        AutoSettings.M3.Items.Add(MashtabNames[I]);
    if (i <= AutoSettings.M5Max) then
        AutoSettings.M5.Items.Add(MashtabNames[I]);
    if (i >= AutoSettings.M7Min)and(i <= AutoSettings.M7Max) then
        AutoSettings.M7.Items.Add(MashtabNames[I]);
 end;

 for I := 3 to 5 do
 begin
   if i<5 then
     AutoSettings.M2.Items.Add(MapModeSubNames[I]);
   if i<5 then
     AutoSettings.M4.Items.Add(MapModeSubNames[I]);

   AutoSettings.M6.Items.Add(MapModeSubNames[I]);
   AutoSettings.M8.Items.Add(MapModeSubNames[I]);
 end;

end;

procedure TMainForm.InitData;
begin
 { CreateEllipsoid('WGS84','',6378137, 1/298.257223563);
  CreateEllipsoid('Krasowsky','',6378245, 1/298.3);

  WGS := CreateDatum('WGS84','','WGS84');
  SK  := CreateDatum('SK42','','Krasowsky');

  AddConversionProperties(SK,'WGS84', 23.92, -141.27, -80.9, 0, -0.35, -0.82, -0.00000012);   }

  MashtabNames [0] := '10 м' ;
  MashtabNames [1] := '20 м' ;
  MashtabNames [2] := '50 м' ;
  MashtabNames [3] := '100 м';
  MashtabNames [4] := '200 м';
  MashtabNames [5] := '500 м';
  MashtabNames [6] := '1 км' ;
  MashtabNames [7] := '2 км' ;
  MashtabNames [8] := '5 км' ;
  MashtabNames [9] := '10 км' ;
  MashtabNames [10] := '20 км' ;
  MashtabNames [11] := '50 км' ;

  MapModeNames [0] := 'Обзор карты'        ;
  MapModeNames [1] := 'Полет к ближайшему' ;
  MapModeNames [2] := 'Полет к ближайшему' ;
  MapModeNames [3] := 'Полет по маршрутам' ;
  MapModeNames [4] := 'Полет по маршрутам' ;
  MapModeNames [5] := 'Полет по маршрутам' ;
  MapModeNames [6] := 'Возвращение на базу';
  MapModeNames [7] := 'Возвращение на базу';
  MapModeNames [8] := 'Свободный полет';
  MapModeNames [9] := 'Свободный полет';


  MapModeShortNames [0]:= 'ОБЗОР';
  MapModeShortNames [1]:= 'БЛИЖ.';
  MapModeShortNames [2]:= 'БЛИЖ.';
  MapModeShortNames [3]:= 'МАРШ.';
  MapModeShortNames [4]:= 'МАРШ.';
  MapModeShortNames [5]:= 'МАРШ.';
  MapModeShortNames [6]:= 'БАЗА';
  MapModeShortNames [7]:= 'БАЗА';
  MapModeShortNames [8]:= 'СВОБ.';
  MapModeShortNames [9]:= 'СВОБ.';

  MapModeSubNames [0] := '(ориентация на Север)'   ;
  MapModeSubNames [1] := '(ориентация на Север)'   ;
  MapModeSubNames [2] := '(ориентация по азимуту)' ;
  MapModeSubNames [3] := '(ориентация на Север)'   ;
  MapModeSubNames [4] := '(ориентация по азимуту)' ;
  MapModeSubNames [5] := '(ориентация по маршруту)';
  MapModeSubNames [6] := '(ориентация на Север)'   ;
  MapModeSubNames [7] := '(ориентация по азимуту)' ;
  MapModeSubNames [8] := '(ориентация на Север)'   ;
  MapModeSubNames [9] := '(ориентация по азимуту)' ;

  MapModeShortSubNames [0] := ' (Север)'   ;
  MapModeShortSubNames [1] := ' (Север)'   ;
  MapModeShortSubNames [2] := ' (Аз.)' ;
  MapModeShortSubNames [3] := ' (Север)'   ;
  MapModeShortSubNames [4] := ' (Аз.)' ;
  MapModeShortSubNames [5] := ' (Марш.)';
  MapModeShortSubNames [6] := ' (Север)'   ;
  MapModeShortSubNames [7] := ' (Аз.)' ;
  MapModeShortSubNames [8] := ' (Север)'   ;
  MapModeShortSubNames [9] := ' (Аз.)' ;

  Inf [1] := 'Зона проекции:';
  Inf [2] := 'Спутники:';
  Inf [3] := 'Время GPS:';
  Inf [4] := 'Текущий путь:';
  Inf [5] := 'Полный путь:';
  Inf [6] := 'Для перемещения карты используйте';
  Inf [7] := 'левую кнопку мыши или клавиши W S A D';
  Inf [8] := 'Превышен допуск расстояния до маршрута';
  Inf [9] := 'Выполните повторный заход на маршрут';
  Inf [10] := 'Маршрут уже пройден. Выполнить повторное следование?';
  Inf [11] :=  'Удаление от маршрутов более 2 км. Продолжить съемку?';
  Inf [12] :=  'База достигнута';
  Inf [13] :=  'Нет непройденных маршрутов в очереди';
  Inf [14] :=  'Добавлено продолжений:';
  Inf [15] :=  'Настройки файла маршрутов заданы неверно или файл имеет некорректный формат!';
  Inf [16] :=  'Скорость: ';
  Inf [17] :=  ' км/ч';
  Inf [18] :=  'Азимут: ';
  Inf [19] :=  'Высота: ';
  Inf [20] :=  ' м';
  Inf [21] :=  'Режим:';
  Inf [22] :=  'Масштаб:';
  Inf [23] :=  'Текущий:';
  Inf [24] :=  'Следующий:';
  Inf [25] :=  ' км';
  Inf [26] :=  'От текущего:';
  Inf [27] :=  'Авторежим:';
  Inf [28] :=  'Вкл.';
  Inf [29] :=  'Выкл.';
  Inf [30] :=  'Пролететь текущий';
  Inf [31] :=  'Перейти к ближайшему';
  Inf [32] :=  'Продолжить следование';
  Inf [33] :=  'маршрут заново';
  Inf [34] :=  'маршруту';
  Inf [35] :=  'по текущему';
  Inf [36] :=  'Маршрут';
  Inf [37] :=  'Статус:';
  Inf [38] :=  'не пройден';
  Inf [39] :=  'текущий';
  Inf [40] :=  'пройден (Ок)';
  Inf [41] :=  'пройден (грубо)';
  Inf [42] :=  'Лететь заново';
  Inf [43] :=  'Отмена';
  Inf [44] :=  'К маршрутам';
  Inf [45] :=  'На базу';
  Inf [46] :=  'Продолжить полет';
  Inf [47] :=  'Завершить навигацию';
  Inf [48] :=  '(Полет к ближайшему)';
  Inf [49] :=  '(Обзор карты, авто: выкл)';
  Inf [50] :=  'Перепройти маршрут';
  Inf [51] :=  'Вернуться на базу';
  Inf [52] :=  'Выйти из режима авто';

  Inf [53] :=  'Не пройд.';
  Inf [54] :=  'ОК'; 
  Inf [55] :=  'Грубо';

  LangExe :='';

  with LoadRData do
  begin
    LatS := 'Широта B, ';
    LonS := 'Долгота L, ';
    XS := 'X, м'; YS := 'Y, м'; ZS := 'Z, м';
    NordS := 'Север, м';
    SouthS:= 'Юг, м';
    NSS := 'Север/Юг, м';
    EWS := 'Запад/Восток, м';
    WestS := 'Запад, м';
    EastS := 'Восток, м';
    NameS := 'Имя'
  end;

  Settings.ProtList;

  Settings.Languages.OnChange(nil);
  JoyResetN :=0;
  HgtID := 0;

  Center.x := 0;
  Center.y := 0;

  Mashtab := 7;

  MinR := 100;
  MaxR := 200;

  TPCount :=0;
  Settings.AutoZone.Checked := true;

  AskR :=  2500;
  AskReturn := true;
end;

procedure TMainForm.LoadAUXProt(FName:string);
var S: TStringList;
begin
   FName := DataDir+'Protocols\'+FName+'.prt';

   S:= TStringList.Create;
   
   try
    S.LoadFromFile(FName);

    with AUXProt do
    begin
      RName := s[0];
      RSepN := StrToInt(s[1]);
      RSep  := s[2];
      RParN := StrToInt(s[3]);
      RDataType  := StrToInt(s[4]);
      RCoef := StrToFloat2(s[5]);

      case RSepN  of
         0: RSep := ' ';
         1: RSep := #$9;
         2: RSep := ',';
         3: RSep := '.';
      end;

      LName := s[7];
      LSepN := StrToInt(s[8]);
      LSep  := s[9];
      LParN := StrToInt(s[10]);
      LDataType  := StrToInt(s[11]);
      LCoef := StrToFloat2(s[12]);

      case LSepN  of
         0: LSep := ' ';
         1: LSep := #$9;
         2: LSep := ',';
         3: LSep := '.';
      end;
    end;
   except
   end;

   S.Destroy;
end;

procedure TMainForm.LoadMaps(Filename:String);
var
 MapAsdb : TASDB;
 i, j, N, k : integer;
 S : TStringList;
 Stream : TFileStream;
 ImgName, CurImgName : String;
 xx, yy : Double;
begin

 FLoadGPS.Show;
 FLoadGPS.GPSLoad.Visible := false;
 FLoadGPS.GPSLoad2.Visible := false;
 FLoadGPS.MapLoad.Visible := true;
 FLoadGPS.LCount.Visible := true;
 FLoadGPS.Repaint;
 FloadGPS.ProgressBar1.Position := 0;


 MapASDb:= TASDb.Create();
 MapASDb.FileName:= FileName;
 MapASDb.OpenMode:= opReadOnly;

 MapAsdb.Update;

 S := TStringList.Create;
 //if fileexists(DataDir+'stream.tmp') then
   S.SaveToFile(DataDir+'stream.tmp');

 

 for I := 0 to MapASDb.RecordCount-1 do
   if MapASDb.RecordType[i] = recFile then
   Begin
     Stream := TFileStream.Create(DataDir+'stream.tmp',1);
   //  Stream := MapASDb.ReadStream(MapASDb.RecordKey[i])
     MapASDb.ReadStream(MapASDb.RecordKey[i] ,Stream);

     Stream.Destroy;
     S.Clear;
     //S.LoadFromStream(Stream);
     S.LoadFromFile(DataDir+'stream.tmp');

     ImgName := MapASDb.RecordKey[i];
     ImgName := Copy(ImgName,1,length(ImgName)-4);

     for J := 0 to S.Count - 1 do
     begin
          FLoadGPS.ProgressBar1.Position := Trunc(100*j/(S.Count-1));

          CurImgName := ImgName+'_'+GetCols(S[j],0,1,0)+'_'+GetCols(S[j],1,1,0);
          N := AsphMapImages.AddFromASDb(CurImgName+'_t', MapASDb, CurImgName+'_t', true);
          N := AsphMapImages.AddFromASDb(CurImgName+'_s', MapASDb, CurImgName+'_s', true);
          N := AsphMapImages.AddFromASDb(CurImgName, MapASDb, CurImgName, true);
          if N > -1 then
          Begin
//           AsphMapImages.Items[N].

            SetLength(MapList,Length(MapList)+1);
            MapList[Length(MapList)-1].imgName := CurImgName;
            MapList[Length(MapList)-1].imgN := N;

            for k := 1 to 4 do
            Begin
              MapList[Length(MapList)-1].Gx[k] := StrToFloat(GetCols(S[j],k*2,1,0));
              MapList[Length(MapList)-1].Gy[k] := StrToFloat(GetCols(S[j],k*2+1,1,0));

              if UTM then
                 GeoToUTM(WGS,MapList[Length(MapList)-1].Gx[k],
                          MapList[Length(MapList)-1].Gy[k],
                          South, yy,xx, Myzone, WaitForZone)
               else
                   WGSToSK(MapList[Length(MapList)-1].Gx[k],
                           MapList[Length(MapList)-1].Gy[k],
                           0, xx,yy, MyZone, WaitForZone);

              MapList[Length(MapList)-1].x[k] := xx;
              MapList[Length(MapList)-1].y[k] := yy;
            End;  /// k cycle

          End;  /// N>-1

     end;

   End;

// Stream.Destroy;
 FLoadGPS.Hide;
 S.Destroy;
 MapAsdb.Destroy;
end;

procedure TMainForm.MenuKeyCommand(Key: Byte);
var I, MN, OldMode:integer;
begin
///

  if inSmart then
  Begin
    SmartMenuKeyCommand(Key);
    exit;
  End;

  case Key of
    1: Begin  /// UP
        case (SmartMenu) and (MenuN=1) of
           true:  if ChoosedMenu > -1 then
                     Dec(ChoosedMenu)
                       else
                         if (MenuN<>5)and(MenuN<>6) then
                         Begin
                            ChoosedMenu := MenuCount[MenuN];
                            if (MenuN=1) then
                            begin
                                // ChangeAutoM := False;
                                if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
                                    ChoosedMenu := MenuCount[MenuN]-1;
                            end;

                         End;

           false: if ChoosedMenu > 0 then
                     Dec(ChoosedMenu);
        end;


       if (MenuN = 5 ) or (MenuN = 6) then
          RouteAsk :=  ChoosedMenu;

       if MenuN=1 then
          ChangeAutoM := False;
    End;
    
    2: Begin   /// DOWN
       if (MenuN = 5 ) or (MenuN = 6) then
       begin
         if ChoosedMenu < RouteCount-1 then
            Inc(ChoosedMenu);
            RouteAsk :=  ChoosedMenu;
       end else
          if ChoosedMenu < MenuCount[MenuN] then
              Inc(ChoosedMenu)
                else
                  if (SmartMenu) and (MenuN=1) then /// Если есть кнопка SmartMenu
                  begin
                     ChoosedMenu := -1;
                  end;

          if (MenuN=1) then
          begin
              ChangeAutoM := False;
              if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
                   ChoosedMenu := MenuCount[MenuN]-1;
          end;
    End;

    3: Begin   /// LEFT
       case MenuN of
          1: begin
            CASE ChoosedMenu OF
               0: if SmartMenu then
                   ChoosedMenu := -1;
               1: //if EnableCom2 then
                 begin
                    Dec(HgtID);
                    if HgtId<0 then
                    HgtId := 3;
                 end;
                  // else
                    // HgtId := 0;
               3:if not AutoOn then
                 begin
                 if MapMode>0 then
                   Dec(MapMode)
                    else
                      MapMode:= MapModesCount;
                   DistToBase := -1;
                   Follow := (MapMode>2)and(MapMode<6);
                 end;
               4: if AutoOn = false or ChangeAutoM then
                    if Mashtab > 0 then
                      Dec(Mashtab);

               5 : for I := CurrentRoute-1 Downto 0 do
                     if Route[i].Status=0 then
                       begin
                          SetCurrentRoute(i);
                          break;
                       end;

               6 : for I := NextRoute-1 Downto 0 do
                     if Route[i].Status=0 then
                       begin
                          NextRoute := i;
                          SpecialTP := true;
                          CurToNextDist;
                          break;
                       end;

               7: AutoOn := not AutoOn;
            END;
          end;



       end;

    End;

    4: Begin   ///  RIGHT
      case MenuN of
          1: begin
            CASE ChoosedMenu OF
               -1: ChoosedMenu := 0;
               1: //if EnableCom2 then
               begin
                    Inc(HgtID);
                    if HgtId>3 then
                    HgtId := 0;
               end;
                // else
                  // HgtId := 0;


               3:if not AutoOn then
                 begin
                   if MapMode< MapModesCount then
                    Inc(MapMode)
                     else
                       MapMode:=0 ;

                   DistToBase := -1;

                   //if MapMode>2 then
                    Follow := (MapMode>2)and(MapMode<6);
                 end;
                 
               4: if AutoOn = false or ChangeAutoM then
                    if Mashtab < MaxMashtab-1 then
                      Inc(Mashtab);

               5 : for I := CurrentRoute+1 to RouteCount - 1 do
                     if Route[i].Status=0 then
                       begin
                          SetCurrentRoute(i);
                          break;
                       end;

               6 : for I := NextRoute+1 to RouteCount - 1 do
                     if Route[i].Status=0 then
                       begin
                          NextRoute := i;
                          SpecialTP := true;
                          CurToNextDist;
                          break;
                       end;

               7: AutoOn := not AutoOn; 
            END;
          end;



       end;

    End;

    5: Begin   ///  ENTER
        case MenuN of
          1: begin
            case ChoosedMenu of
               -1: inSmart := true;


               1:   //if EnableCom2 then
               begin
                    Inc(HgtID);
                    if HgtId>3 then
                    HgtId := 0;
               end;
                // else
                  // HgtId := 0;
               3: if not AutoOn then
               begin
                  MenuN:=2;
                  ChoosedMenu := MapMode;
                  Menuscroll := 0;
               end;
               4: if AutoOn = false or ChangeAutoM then
               begin
                  MenuN:=3;
                  ChoosedMenu := Mashtab;
                  Menuscroll := 0;
               end
                else
                  if AutoOn then
                    ChangeAutoM := not ChangeAutoM;

               5: if RouteCount >0 then
               begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
               end;
               6: if RouteCount >0 then
               begin
                  MenuN:=6;
                  ChoosedMenu := NextRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
               end;
               7: AutoOn := not AutoOn;
            end;
            {if MenuN < 3 then
               ChoosedMenu := 0; }

          end;
          2: begin
            OldMode := MapMode;
            MapMode := ChoosedMenu;
            Follow := (MapMode>2)and(MapMode<6);
            if Follow then
                if RouteCount=0 then
                Begin
                    MapMode := OldMode;
                    Follow := false;
                End;

            MenuN:=1;
            ChoosedMenu := 3;
            Menuscroll := 0;
            DistToBase :=-1;
          end;
          3: begin
            Mashtab := ChoosedMenu;
            MenuN:=1;
            ChoosedMenu := 4;
            Menuscroll := 0;
          end;
          4: begin
            case ChoosedMenu of
              0: begin
                  ReflyCurrent := true;
                  WorstDist:= false;
                  BadDist := false;
                 end;
              1: begin
                   if SizeTrackRecord > 1 then
                   Begin
                      GetNearestRoute(TrackRecord[SizeTrackRecord -1].x,
                                      TrackRecord[SizeTrackRecord -1].y);
                      SetCurrentRoute(NearestRoute);
                      BadDist := false;
                      WorstDist:= false;
                      Route[CurrentRoute].RLabel := '*'+inf[69];
                   End;

                 end;
              2: Begin
                  WorstDist:= false;
                  BadDist := false;
                 End;
            end;
            MenuN:=1;
            ChoosedMenu := 4;
            Menuscroll := 0;
          end;
          5: begin
            if (ChoosedMenu >= 0) and (ChoosedMenu < RouteCount) then
               if Route[ChoosedMenu].Status > 1 then
               begin
                  MenuN:=7;
                  AskForNext := False;
                  RouteAsk :=  ChoosedMenu;
                  ChoosedMenu := 0;
               end
                else
                Begin
                  SetCurrentRoute(ChoosedMenu);
                  MenuN:=1;
                  ChoosedMenu := 5;
                  RouteAsk :=-1;
                End;

               Menuscroll := 0;
          end;
          6: begin
            if (ChoosedMenu >= 0) and (ChoosedMenu < RouteCount) then
               if Route[ChoosedMenu].Status > 1 then
               begin
                  MenuN:=7;
                  AskForNext := True;
                  RouteAsk :=  ChoosedMenu;
                  ChoosedMenu := 0;
               end
                else
                Begin
                  NextRoute := ChoosedMenu;
                  SpecialTP := true;
                  CurToNextDist;
                  MenuN:=1;
                  ChoosedMenu := 6;
                  RouteAsk :=-1;
                End;

               Menuscroll := 0;
          end;

          7: begin
            if (ChoosedMenu = 0 ) then
            BEGIN
               if (RouteAsk >= 0) and (RouteAsk < RouteCount) then
               Begin
                 Route[RouteAsk].Status := 0;
                 Route[RouteAsk].AverageDist:= 0;
                 if not AskForNext then
                    SetCurrentRoute(RouteAsk)
                      else
                      begin
                        NextRoute := ChoosedMenu;
                        SpecialTP := true;
                        CurToNextDist;
                      end;
               End;
               MenuN:=1;
               RouteAsk :=-1;
               Menuscroll := 0;
            END
             else
             Begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
             End;
          end;

          8: Begin
               RouteAsk :=-1;
               Menun:=1;
               if ChoosedMenu = 0 then
               begin
                  Mashtab := AutoM[3];
                  MapMode := 1 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
               end
                else
                begin
                  GetDistToBase(TrackRecord [SizeTrackRecord -1].x,
                                TrackRecord [SizeTrackRecord -1].y );
                  Mashtab := AutoM[3];
                  MapMode := 6 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
                end;

             End;

          9: Begin
               RouteAsk :=-1;
               Menun:=1;
               if ChoosedMenu = 0 then
               begin
                  Mashtab := AutoM[3];
                  MapMode := 1 + AutoM[4];
                  Follow := (MapMode>2)and(MapMode<6);
               end
                else
                begin
                  ///Mashtab := AutoM[3];
                  AutoOn := false;
                  MapMode := 0;
                  Follow := (MapMode>2)and(MapMode<6);
                end;

             End;

          10: Begin
               RouteAsk :=-1;
               Menun:=1;
               case ChoosedMenu of
                  0:begin
                    MenuN:=5;
                    ChoosedMenu := 0;
                    RouteAsk :=  ChoosedMenu;
                    Menuscroll := 0;
                  end;
                  1:begin
                    Mashtab := AutoM[3];
                    MapMode := 6 + AutoM[4];
                    Follow := (MapMode>2)and(MapMode<6);
                  end;
                  2: begin
                    AutoOn := false;
                    MapMode := 0;
                    Follow := (MapMode>2)and(MapMode<6);
                  end;
               end;


             End;
        end;
        Follow := (MapMode>2)and(MapMode<6);
    End;

    6: Begin   ///  ESC
      if Menun<>1 then
      begin
         case menun of
           2: ChoosedMenu := 3;
           3: ChoosedMenu := 4;
           4: BadDist := false;

           5: ChoosedMenu := 5;

           6: ChoosedMenu := 6;

           7: Begin
                  MenuN:=5;
                  ChoosedMenu := CurrentRoute;
                  RouteAsk :=  ChoosedMenu;
                  Menuscroll := 0;
              End;

           8: Begin
               Mashtab := AutoM[3];
               MapMode := 1 + AutoM[4];
               Follow := (MapMode>2)and(MapMode<6);
           End;
         end;
         RouteAsk :=-1;
         Menun:=1;
         MenuScroll := 0;
         ChangeAutoM := False;
      end;

    End;

  end;

  if AutoOn then
  begin
    //if (MapMode > 7)or(MapMode = 0) then
     //  ChangeAutoM := true;

    if ChangeAutoM then
    begin
       case MapMode of
         1,2,6,7 : if Speed < 10 then
                    AutoM[1] :=  Mashtab
                      else
                        AutoM[3] :=  Mashtab;
         3,4,5 : if not (BeforeBegin or AfterEnd or ReflyCurrent) then
                     AutoM[5] :=  Mashtab
                           else
                             AutoM[7] :=  Mashtab;
       end;
    end;

    if (MapMode = 0) or (MapMode > 7) then
       MapMode := 1;
  end;

  MN := ChoosedMenu;
  if MN=-1 then MN :=0;
  

  if (MN+1)*MenuButtonSize[MenuN] > AsphDevice.Size.y - MenuScroll then
      MenuScroll := MenuScroll - ( -AsphDevice.Size.y + MenuScroll
                    + (MN+1)*MenuButtonSize[MenuN]);

  if ChoosedMenu*MenuButtonSize[MenuN] < - MenuScroll then
      MenuScroll := MenuScroll + ( -MenuScroll - MN*MenuButtonSize[MenuN]);

end;

procedure TMainForm.MenuUnscroll;
var Max : Integer;
begin

    if MenuScroll < 0 then
    begin
        MenuScroll := MenuScroll + MenuButtonSize[MenuN];
    end;

    if MenuScroll > 0 then
       MenuScroll := 0;
    

    Max :=  MenuCount[MenuN];
     if (MenuN=5) or (MenuN=6) then
        Max :=  RouteCount-1;

     if (Max+1)*MenuButtonSize[MenuN]>DisplaySize.y then
       begin
         if MenuScroll > -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)  then
            MenuScroll := MenuScroll; //- MenuButtonSize[MenuN];
         if MenuScroll < -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y) then
            MenuScroll := -((Max+1)*MenuButtonSize[MenuN]-DisplaySize.y)
       end
        else
           MenuScroll := 0;

end;

procedure TMainForm.MyLine(x,y,x2,y2:Double; Dash:Boolean; Col: Cardinal);
var i, l :integer;
    dx, dy :real;
const dashstep = 20;
begin
  if not( (x < 0) and (x2 < 0)) then
  if not( (x > (DisplaySize.X - MenuW)) and (x2 > (DisplaySize.X - MenuW))) then
  if not( (y < 0) and (y2 < 0)) then
  if not( (y > DisplaySize.y) and (y2 > DisplaySize.y)) then
  if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
  Begin
   { if x < 0 then
    begin
      if abs(x2-x) > 0 then
        y := ((-x)/(x2-x))*(y2-y)+y
          else
            y := y2;
      //Col := $FFFF0000;
      x := 0;
    end
      else
       if x > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y := (((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y
               else
                 y := y2;
          //Col := $FFFF0000;
          x := (DisplaySize.X - MenuW);
       end;

    if x2 < 0 then
    begin
      if abs(x2-x) >0 then
        y2 := ((-x)/(x2-x))*(y2-y)+y
          else
            y2 := y;
      //Col := $FFFF0000;
      x2 := 0;
    end
      else
       if x2 > (DisplaySize.X - MenuW) then
       begin
          if abs(x2-x) > 0 then
              y2 := (((DisplaySize.X - MenuW)-x)/(x2-x))*(y2-y)+y
               else
                 y2 := y;
          //Col := $FFFF0000;
          x2 := (DisplaySize.X - MenuW);
       end;

    if y < 0 then
    begin
      if abs(y2-y)>0 then
          x := ((-y)/(y2-y))*(x2-x)+x
          else
            x := x2;
      //Col := $FFFF0010;
      y := 0;
    end
      else
       if y > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x := ((DisplaySize.y-y)/(y2-y))*(x2-x)+x
               else
                 x := x2;
         //Col := $FFFF0010;
         y := DisplaySize.y;
       end;

   if y2 < 0 then
    begin
      if abs(y2-y) > 0 then
          x2 := ((-y)/(y2-y))*(x2-x)+x
          else
            x2 := x;
      //Col := $FFFF0010;
      y2 := 0;
    end
      else
       if y2 > DisplaySize.y then
       begin
          if abs(y2-y) > 0 then
               x2 := ((DisplaySize.y-y)/(y2-y))*(x2-x)+x
               else
                 x2 := x;
         //Col := $FFFF0010;
         y2 := DisplaySize.y;
       end;
  End;  }



   CutLineByFrame(x,y,x2,y2);

   try
    if Dash then
    Begin
       L := trunc(Sqrt (Sqr(x2-x)+sqr(y2-y)));
       if L>0 then
       BEGIN
          dx := (x2 - x)/L;
          dy := (y2 - y)/L;
          for I := 0 to L div dashstep do
          begin

            if Smooth {and Scale < NNN} then
                AsphCanvas.WuLine( Point2(x+i*dashstep*dx, y+i*dashstep*dy),
                Point2(x+(i+0.5)*dashstep*dx,y+(i+0.5)*dashstep*dy ), Col, Col)
            else
              AsphCanvas.Line( Point2(x+i*dashstep*dx, y+i*dashstep*dy),
                Point2(x+(i+0.5)*dashstep*dx,y+(i+0.5)*dashstep*dy ), Col, Col)

          end;

        

       END;



    End else
      Begin


          if Smooth then
          begin
            if not( (abs(y-y2) < 1) and (abs(x-x2) < 1) ) then
                AsphCanvas.WuLine( Point2(x, y), Point2(x2, y2), Col, Col)
          end
          else
                AsphCanvas.Line( Point2(x, y), Point2(x2, y2), Col);


      End;

   except
   end;
  End;
end;

procedure TMainForm.N1Click(Sender: TObject);
var CurPosBL : TLatLong;
begin
  CurPosBL := GetWGSCursor;
  NewMarkerForm.Top := Top + Panel1CursorY + Panel1.Top;
  NewMarkerForm.Left := Left + Panel1CursorX + Panel1.Left;
  NewMarkerForm.ShowModal;

  if NewMarkerForm.isOk then
     AddMarker(NewMarkerForm.MarkerName.Text, CurPosBL.lat, CurPosBL.long);
end;

procedure TMainForm.N2Click(Sender: TObject);
var CurPosBL : TLatLong;
begin
  CurPosBL := GetWGSCursor;
  PutBaseHere(CurPosBL.lat, CurPosBL.long);
end;

procedure TMainForm.N3Click(Sender: TObject);
begin
 if AskMark<>-1 then
   DelMarker(AskMark);

  AskMark :=-1;
end;

//---------------------------------------------------------------------------
procedure TMainForm.OnDeviceCreate(Sender: TObject; Param: Pointer;
 var Handled: Boolean);
var
 Success: Boolean;
begin
 // This variable returns "Success" to Device initialization, so if you
 // set it to False, device creation will fail.
 Success:= PBoolean(Param)^;
 try
   AsphImages.RemoveAll();
   AsphMapImages.RemoveAll(); 
   AsphFonts.RemoveAll();

   // This image is used by our bitmap font.
   AsphImages.AddFromASDb('font0.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font3.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font4.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font5.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('font6.image', MediaASDb, '', False);


   AsphImages.AddFromASDb('arrow1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow3.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow4.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('az.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('spd.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('spd2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('h.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('lh.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('rh.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('lock.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('unlock.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('flag.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('flag_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('marker1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('marker1_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('arrow1_big.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('sat.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('dop.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('dot.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('hgtm.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('hgta.image', MediaASDb, '', False);

   AsphImages.AddFromASDb('s_inf.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_gps.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_aux.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_map.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_hgt.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_set.image', MediaASDb, '', False);
   
   AsphImages.AddFromASDb('s_tr1.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_tr2.image', MediaASDb, '', False);
   AsphImages.AddFromASDb('s_tr3.image', MediaASDb, '', False);

   
   Font0:= AsphFonts.Insert('Data/media.asdb | font0.xml', 'font0.image');
   Font1:= AsphFonts.Insert('Data/media.asdb | font1.xml', 'font1.image');
   Font2:= AsphFonts.Insert('Data/media.asdb | font2.xml', 'font2.image');
   Font3:= AsphFonts.Insert('Data/media.asdb | font3.xml', 'font3.image');
   Font4:= AsphFonts.Insert('Data/media.asdb | font4.xml', 'font4.image');
   Font5:= AsphFonts.Insert('Data/media.asdb | font5.xml', 'font5.image');
   Font6:= AsphFonts.Insert('Data/media.asdb | font6.xml', 'font6.image');

   AsphFonts[Font0].Kerning:=2;
   AsphFonts[Font1].Kerning:=1.2;
   AsphFonts[Font2].Kerning:=-1.5;
   AsphFonts[Font3].Kerning:= -1.5;
   AsphFonts[Font4].Kerning:= -1.5;
 finally
   Success:= true ;
 end;

 PBoolean(Param)^:= Success;
end;

procedure TMainForm.OpenEmulFile(FileName: String);
var j, Added  : integer;
    i : LongInt;
    s, ext  : string;
    S2 : TStringList;
begin
  if Filename='' then
    exit;

  if Settings.ContainAUX.Checked then
     LoadAUXProt(Settings.AUXProt.Items[Settings.AUXProt.ItemIndex]);
    
  S2 := TStringList.Create;

  try
  FLoadGPS.Show;
  
  FLoadGPS.GPSLoad.Visible := false;
  FLoadGPS.GPSLoad2.Visible := false;
  
  if Settings.DataFilter.Checked then
    FLoadGPS.GPSLoad.Visible := true
      else
        FLoadGPS.GPSLoad2.Visible := true;

  FLoadGPS.MapLoad.Visible := false;
  FLoadGPS.LCount.Visible := false;
  FLoadGPS.Repaint;
  FloadGPS.ProgressBar1.Position := 0;

  Odometr := 0;
  Trip := 0;
  EmulProgress := 0;
  OldEmulProgress := 0;
  ClearGPS;
  EmulBuffer.LoadFromFile(FileName);

  if Settings.AddAll.Checked then
  begin

     for i := length(filename) Downto 1 do
       if filename[i]='.' then
       begin
          s := copy(Filename,1,i-1);
          ext := copy(Filename,i,length(filename)-i+1);
          break;
       end;
    // showmessage(s);
    // showmessage(ext);
     Added := 0;
     for I := 1 to LogsMax do
     begin
        if Fileexists(s+'_'+intTostr(i)+ext) then
        begin
          inc(Added);
          //showmessage(s+'_'+intTostr(i)+ext);
          S2.LoadFromFile(s+'_'+intTostr(i)+ext);
          for J := 0 to S2.Count - 1 do
            EmulBuffer.Add(S2[j]);
        end
          else
            break;
     end;
       if not Settings.LoadingS then
       showmessage(inf[14]+intTostr(Added));
  end;

  FloadGPS.ProgressBar1.Repaint;

  if Settings.DataFilter.Checked then
  BEGIN
    S2.Assign(EmulBuffer);
    EmulBuffer.Clear;
    
    for I := 0 To S2.Count-1 do
    begin
       { if  Pos( 'V', s2[i] ) = 0 then  }
           if ( (Pos ( 'RMC', s2[i]) > 0) or (Pos('GGA', s2[i]) > 0 ) )
            ///   or(Pos ( 'VTG', s2[i]) > 0) 
             or ( (Settings.ContainAUX.Checked) and
              ( (Pos( AUXProt.RName, s2[i] ) > 0) or (Pos( AuxProt.LName, s2[i] ) > 0 )) )
                then
                  EmulBuffer.Add(S2[i]);

      if i mod 50000 = 0 then
       Begin
         FloadGPS.ProgressBar1.Position := trunc(100*i/S2.Count);
         FloadGPS.ProgressBar1.Repaint;
       End;
    end;
  END;

  try
    floadGPS.Hide;
  except
  end;

  except
  end;
  
  S2.Destroy;
  GPSLog.SaveToFile(GPSLogFileName);
  Report.Clear;

  Report.Add(Inf[70]);
  Report.Add(FileName);
  Report.Add('');
  Report.Add(Inf[68]);
end;

//---------------------------------------------------------------------------
procedure TMainForm.TimerEvent(Sender: TObject);
begin

  if Timer.FrameRate>0 then
    LagCount := 1 // Timer.FrameRate
      else
        LagCount := 0;

  AsphDevice.Render(Panel1.Handle, RenderEvent, BackGroundColor);

  Timer.Process();
  
end;

//---------------------------------------------------------------------------
procedure TMainForm.Panel1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  TapOnMenu := false;
  if AllowMouse then
  Begin
    if X > MenuX  then
    begin
       MShiftY0 := y ;
       MShiftY  := y ;
       TapOnMenu := true;
       ScrollMenu := false;
    end
     else
      if MapMode = 0 then
      begin
          MShiftX := x ;
          MShiftY := y ;
      end;
  End;


end;

procedure TMainForm.Panel1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var Mas: Single;
    I,J,k: integer;
begin
  if not AllowMouse  then
  Begin
    Panel1.Cursor := crNone;
  End
    else
      Begin
        if X < Panel1.ClientWidth - MenuW then
          Panel1.Cursor := crCross
          else
             Panel1.Cursor := crArrow;

        if SmartMenu then
        Begin
          SmartN := -1;
          
          if (x > SmartX)and(x < SmartX+30) then
            if (y > SmartKeyY+30)and(y < SmartKeyY+70) then
            Begin
               ChoosedMenu := -1;
               SmartN := 0;

               Panel1.Cursor := crArrow;
            End;

          k := trunc(smartCount/4);
          
          if inSmart then
          Begin
            for I := 1 to 4 do
            for J := 0 to k do
            Begin
                //// SMARTBUTTONS
                if (x > SmartX+(i-1)*50-200)and(x <= SmartX+i*50-200) then
                  if (y > SmartY+j*50)and(y <= SmartY+(j+1)*50) then
                  Begin
                     SmartN := j*4+i;
                     Panel1.Cursor := crArrow;
                  End;
            End;
          End;

        End;

      End;


  if AllowMouse then
  begin
   Panel1CursorX  := x;
   Panel1CursorY  := y;

   ShowCurXY := ssRight in Shift;

   if MapMode = 0 then
   if not(TapOnMenu) then
    if ssLeft in Shift then
        begin
            Mas := {TMashtab[Mashtab]/50} Scale;
            Center.x := Center.x - ( x - MShiftX ) * Mas ;
            Center.y := Center.y + ( y - MShiftY ) * Mas ;
            MShiftX := x ;
            MShiftY := y ;
        end;
  end;

  if TapOnMenu then
    if ssLeft in Shift then
    BEGIN
      if not(ScrollMenu) then
      if abs(y-MShiftY0) > 100 then
      Begin
          ScrollMenu := true;
          MenuScroll0 := MenuScroll;
      End;

      if ScrollMenu then
      begin
        MenuScroll := MenuScroll0 + (y-MShiftY0) ;
        _MenuScroll := MenuScroll;

        //MenuUnscroll;
      end;
    END;

  if x > Panel1.ClientWidth - MenuW then
     Panel2MouseMove(nil,[], x-Panel1.ClientWidth, y)
end;

procedure TMainForm.Panel1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var w: integer;
begin

  if (X > Panel1.ClientWidth-MenuW)or(TapOnMenu) then
  begin

    if not(ScrollMenu) then
       Panel2MouseUp(nil, Button, Shift, X-Panel1.ClientWidth, Y)
         else
             MenuUnscroll;
  end
      else
      BEGIN
        if AllowMouse then
         if MapMode=0 then
         begin

            if Button = mbRight then
            begin
              if borderStyle<>bsNone then
                w:= GetSystemMetrics(SM_CYCAPTION)
              else
                w:=0;
              CheckNearestMarkers(x,y);
              PopupMenu1.Popup(x+left,y+top+w);
            end;
         end;
     // end
       //  else
          //   BEGIN
              // if Button = mbRight then
        if menun>1 then
          Panel2MouseUp(nil, mbRight, Shift, X-Panel1.ClientWidth, Y);

        if SmartMenu then
        Begin
          if inSmart then
             SmartMenuKeyCommand(5)
              else
               if ChoosedMenu = -1 then
                 MenuKeyCommand(5);
        End;

      END;

  ScrollMenu := false;
end;

procedure TMainForm.Panel1Resize(Sender: TObject);
begin
  MainForm.OnResize(nil);
end;

procedure TMainForm.Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var I, Max : Integer;
begin
  if AllowMouse then
  BEGIN
    Max :=  MenuCount[MenuN];
    if (MenuN=5) or (MenuN=6) then
      Max :=  RouteCount-1;

    for I := 0 to Max do
      if Y > i*MenuButtonSize[MenuN]+_MenuScroll then
       if Y < (i+1)*MenuButtonSize[MenuN]+_MenuScroll then
       begin
         ChoosedMenu :=i;
         if (MenuN=5) or (MenuN=6) then
           RouteAsk :=  ChoosedMenu;
         break;
       end;

    if (MenuN=1) then
    Begin

       if (AllowAuto=false) and (ChoosedMenu = MenuCount[MenuN]) then
         ChoosedMenu := MenuCount[MenuN]-1;
       if AutoOn then
       Begin
         if ChangeAutoM then
            if ChoosedMenu<>4 then
                ChangeAutoM := false;

         if (MapMode>7) or (MapMode=0) then
           ChangeAutoM := true;
       End;
    End;
  END;
end;

procedure TMainForm.Panel2MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if AllowMouse then
  BEGIN
    Panel2MouseMove(sender,Shift,x,y);

    if Button = mbLeft then
      MenuKeyCommand(5);

    if Button = mbRight then
      MenuKeyCommand(6);
  END;
end;

procedure TMainForm.ProcessEvent(Sender: TObject);
var ScrollSpd : integer;
begin
 Inc(AsphTicks);
 // Caption := IntToStr(AsphTicks);
 if AsphTicks > 3141 then
 begin
   SaveLogFile;
   AsphTicks := 0;
 end;


 case inSmart of
   true:
      Begin
        if SmartX < 200 then
            SmartX := SmartX + LagCount*15;

        if SmartX > 200 then
            SmartX := 200;
      End;


   false:
       Begin
        if SmartX > 0 then
            SmartX :=  SmartX - LagCount*25;

        if SmartX < 0 then
            SmartX := 0;
      End;
 end;



   if _MenuScroll <> MenuScroll then
   Begin
      ScrollSpd := 5;
       if Abs(_MenuScroll - MenuScroll) > DisplaySize.y*2 then
         ScrollSpd := 150
         else
         if Abs(_MenuScroll - MenuScroll) > DisplaySize.y then
           ScrollSpd := 50
            else
            if Abs(_MenuScroll - MenuScroll) > DisplaySize.y/2 then
               ScrollSpd := 15;

     

      if _MenuScroll < MenuScroll then
      Begin
         _MenuScroll := _MenuScroll+LagCount*2*ScrollSpd;
         if _MenuScroll > MenuScroll then
             _MenuScroll := MenuScroll
      End
       else
         if _MenuScroll>MenuScroll then
       Begin
         _MenuScroll := _MenuScroll-LagCount*2*ScrollSpd;
         if _MenuScroll < MenuScroll then
             _MenuScroll := MenuScroll
       End
   End;

  //// ОПРОС ДЖОЙСТИКА
  
 GPSTimerEvent;
 if AllowJoystick then
     AskJoysticKey;
end;

procedure TMainForm.PutBaseHere(B, L:Double);
var xx, yy : Double;
begin
  Base[2].x := B;
  Base[2].y := L;
                                                   /// 11-05
  Settings.BaseB.Text := DegToDMS(B, true, 4, false);
  Settings.BaseL.Text := DegToDMS(L, false, 4, false);

  if UTM then
     GeoToUTM(WGS,Base[2].x,Base[2].y,South,yy,xx, Myzone, WaitForZone)
       else
          WGSToSK(Base[2].x,Base[2].y,0,xx,yy, MyZone, WaitForZone);
  Base[1].x := xx;
  Base[1].y := yy;
end;

//---------------------------------------------------------------------------
procedure TMainForm.ReComputeMaps(WFZ: Boolean);
var i,j :integer;
    xx, yy:Double;
begin
   WaitForZone := WFZ;

   for I := 0 to Length(MapList)- 1 do
      for j := 1 to 4 do
      Begin
         if UTM then
            GeoToUTM(WGS,MapList[i].Gx[j],MapList[i].Gy[j],South, yy,xx, Myzone, WaitForZone)
               else
                   WGSToSK(MapList[i].Gx[j],MapList[i].Gy[j],0, xx,yy, MyZone, WaitForZone);

         MapList[i].x[j] := xx;
         MapList[i].y[j] := yy;
         WaitForZone := false;
      End;
end;

procedure TMainForm.ReComputeRoutes(WFZ:Boolean);
var i:integer;
    xx,yy : Double;
    Str: String;
begin
  ReCalcWay := true;
  
  LoadedRoutesList.ListBox1.Clear;
  if  RouteCount > 0 then
  Begin
    LoadedRoutesList.StringGrid1.RowCount :=RouteCount +1;
  End
   else
      Begin
        LoadedRoutesList.StringGrid1.RowCount :=2;
        for I := 0 to LoadedRoutesList.StringGrid1.ColCount-1 do
          LoadedRoutesList.StringGrid1.Cells[I,1] := '';
      End;

  for I := 0 to RouteCount - 1 do
  begin
     if i=0 then
      WaitForZone := WFZ
       else
           WaitForZone := false;
           
     LoadedRoutesList.ListBox1.Items.Add(Route[i].Name);
                                                                             ///11-05
     LoadedRoutesList.StringGrid1.Cells[0,I+1] := Route[I].Name;
     LoadedRoutesList.StringGrid1.Cells[1,I+1] := DegToDMS(Route[I].Gx1,true,4,false);
     LoadedRoutesList.StringGrid1.Cells[2,I+1] := DegToDMS(Route[I].Gy1,false,4,false);
     LoadedRoutesList.StringGrid1.Cells[3,I+1] := DegToDMS(Route[I].Gx2,true,4,false);
     LoadedRoutesList.StringGrid1.Cells[4,I+1] := DegToDMS(Route[I].Gy2,false,4,false);
     case Route[i].Status of
                 0 : Str := inf[38];
                 1 : Str := inf[39];
                 2 : Str := inf[40];
                 3 : Str := inf[41];
     end;
     LoadedRoutesList.StringGrid1.Cells[5,I+1] := Str;
     { if Route[i].Geo = false then
      Begin
        if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,Route[i].x1, Route[i].y1,Settings.RSouth.Checked, xx, yy)
          else
           SKToWGS(Route[i].y1, Route[i].x1,0, xx, yy);
        Route[i].Gx1 := xx;
        Route[i].Gy1 := yy;

        if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,Route[i].x2, Route[i].y2,Settings.RSouth.Checked, xx, yy)
          else
            SKToWGS(Route[i].y2, Route[i].x2,0, xx, yy);
        Route[i].Gx2 := xx;
        Route[i].Gy2 := yy;

        Route[i].Geo := true;
      End;   }

      if Route[i].Geo then
      Begin
        if UTM then
            GeoToUTM(WGS,Route[i].gx1,Route[i].gy1,South,yy,xx, Myzone, WaitForZone)
             else
               WGSToSK(Route[i].gx1, Route[i].gy1,0, xx, yy, MyZone, WaitForZone);
        Route[i].x1 := xx;
        Route[i].y1 := yy;

        if UTM then
            GeoToUTM(WGS,Route[i].gx2,Route[i].gy2,South,yy, xx, Myzone, WaitForZone)
             else
                WGSToSK(Route[i].gx2, Route[i].gy2,0, xx, yy, MyZone, WaitForZone);
        Route[i].x2 := xx;
        Route[i].y2 := yy;
      End;

  end;

  if Frame then
  Begin
  { if FrameGeo = false then
   for I := 0 to FrameCount - 1 do
   begin
     if Settings.SK.ItemIndex = 2 then /// UTM
          UTMToGeo(WGS,FramePoints[i,1].x, FramePoints[i,1].y,Settings.RSouth.Checked, xx, yy)
            else
              SKToWGS(FramePoints[i,1].y, FramePoints[i,1].x,0, xx, yy);
      FramePoints[i,2].x := xx;
      FramePoints[i,2].y := yy;
      FrameGeo := True;
   end;   }
   
   if FrameGeo then
   for I := 0 to FrameCount - 1 do
   begin
     if UTM then
        GeoToUTM(WGS,FramePoints[i,2].x,FramePoints[i,2].y,South,yy,xx,Myzone, WaitForZone)
          else
            WGSToSK(FramePoints[i,2].x, FramePoints[i,2].y,0, xx, yy, MyZone, WaitForZone);
      FramePoints[i,1].x := xx;
      FramePoints[i,1].y := yy;
   end;
  End;

  CurrentRouteAngle := GetRouteAngle(CurrentRoute);
  CurToNextDist;

  TPCount :=0;
  LocalR1 := -1;
end;

procedure TMainForm.ReComputeTracks(WFZ: Boolean);
var i,j:Integer;
    xx, yy :Double;
begin
    WaitForZone := WFZ;

   if SizeTrackRecord > 0 then
      for i := 0 to SizeTrackRecord - 1 do
         if (TrackRecord[i].mZone <> MyZone)
             or (UTM<>TrackRecord[i].mUTM) then
          Begin      // / zczxc

            if UTM then
              GeoToUTM(WGS,TrackRecord[i].Lat,TrackRecord[i].Long,South,yy,xx,Myzone, WaitForZone)
                else
                  WGSToSK(TrackRecord[i].Lat, TrackRecord[i].Long,0, xx, yy,MyZone, WaitForZone);

            TrackRecord[i].x := xx;
            TrackRecord[i].y := yy;
            TrackRecord[i].mZone := MyZone;
            TrackRecord[i].mUTM := UTM;
            WaitForZone := false;
          End;

   if Base[2].x<>0 then
   Begin
     if UTM then
      GeoToUTM(WGS,Base[2].x,Base[2].y,South, yy,xx, Myzone, WaitForZone)
        else
          WGSToSK(Base[2].x,Base[2].y,0, xx,yy, MyZone, WaitForZone);
      Base[1].x := xx;
      Base[1].y := yy;
   End;

   if ShowMaps then
     RecomputeMaps(False);

   if MarkerCount>0 then
     RefreshMarkerList;
end;

procedure TMainForm.ReDrawTrack;
var w, h   : Integer ;
  Mas      : double ;
  Cx, cy   : double ;
  dx, dy   : double ;
  dx2, dy2 : double ;
  Px, Py   : double ;
  i        : Integer ;
  x, y     : Integer ;
  _x,_y    : Integer;
  csize    : Integer;
  Fi, Fi2, Fi3  : double ;
  OldFlag  : Boolean ;
  NeedCrack : Boolean;
  Str: string;
begin

  if SizeTrackRecord=0 then
  Begin

    

    if (Center.x = 0) and (Center.y = 0) then
    Begin
      if ((Base[1].x<>0) and (Base[1].y<>0)) then
      Begin
         RecomputeTracks(WaitForZone);
         RecomputeMaps(false);
         RecomputeRoutes(false);
         Center.x  := Base[1].x;
         Center.y  := Base[1].y;
      End
      Else
      if (RouteCount > 0) then
      Begin
        RecomputeRoutes(WaitForZone);
        RecomputeMaps(false);
        Center.x := Route[0].x1;
        Center.y := Route[0].y1;
      End
       Else
      if (Length(MapList)> 0) then
      Begin
        RecomputeMaps(WaitForZone);
        Center.x := MapList[0].x[3];
        Center.y := MapList[0].y[3];
      End;

    End
      else
        Begin
            if ShowMaps then
              ReDrawMaps;

            if DrawLines then
             ReDrawLines(DashLines);

            ReDrawRoutes;
            RedrawBase;
            RedrawMarkers;
            ReDrawTurnPoints;
        End;
  End;


  if SizeTrackRecord>1 then
  Begin
   // if Not DrawFlag then exit ;

      w := (DisplaySize.X - MenuW);
      h := DisplaySize.y;

      Fi3 := 0;
      Mas := Scale;

      if (SizeTrackRecord > 0) then
      begin
          cx := TrackRecord [SizeTrackRecord -1].x ;
          cy := TrackRecord [SizeTrackRecord -1].y ;
          px := cx;
          py := cy;

      end;

      if MapMode > 0 then
      begin
          Center.x := Cx ;
          Center.y := Cy ;
      end
        else
          begin
            Cx := Center.x ;
            Cy := Center.y ;
          end ;

      px := (Cx - px) / Mas ;
      py := (Cy - py) / Mas ;
      px := round (w div 2 - px);
      py := h - round (h div 2 - py) + VYShift;

      x := trunc(px);
      y := trunc(py);

      i := SizeTrackRecord -1 ;
      dx := TrackRecord[i].x - TrackRecord [i-1].x ;
      dy := TrackRecord[i].y - TrackRecord [i-1].y ;

      if CountAz then
      Begin
        if (dx=0)and(dy=0) then
          fi := 0
           else
             fi := ArcTan2(dy, dx) - pi/2;

        if SmoothAzimuth then
          AxelAzimuth(-fi)
           else
           Begin
            Azimuth := - fi;
            if Azimuth<0 then
               Azimuth := Azimuth + 2*pi
                 else
            if Azimuth> 2*pi then
               Azimuth := Azimuth - 2*pi
           End;
      End
        else
          BEGIN
             if SmoothAzimuth then
               AxelAzimuth(Az)
                else
                  Azimuth := Az;


          END;

      OldFlag := false;

      if MapMode=5 then
        if abs(CurrentRouteAngle-Azimuth) > pi/2 then
                if CurrentRouteAngle > Azimuth then
                  CurrentRouteAngle := CurrentRouteAngle - pi
                      else
                          CurrentRouteAngle := CurrentRouteAngle + pi;

      if ShowMaps then
         ReDrawMaps;

      if DrawLines then
         ReDrawLines(DashLines);


      if MapModeDoRotate[MapMode]=false then     /// НЕ ВРАЩАЮ!
      Begin
          VYShift := 0;
          if not HideTrack then
          for i := SizeTrackRecord -1 downto 0 do
          begin
              if i < SizeTrackRecord - MaxDotsVisible then
                   break;

              if i < SizeTrackRecord -1 then
                   NeedCrack :=  TrackRecord[i+1].Crack;
              if not ShowCracks then
                   NeedCrack := false;

              _x := x;
              _y := y;

              dx := (Cx - TrackRecord[i].x) / Mas ;
              dy := (Cy - TrackRecord[i].y) / Mas ;

              x := round (w div 2 - dx);
              y := h - round (h div 2 - dy);


              if OldFlag <> TrackRecord[i].Flag then
              begin
                 //
              end
                 else
                  if NeedCrack = false then
                    FatLine(_x, _y, x, y, 0+DopFat, false, TrackColor)
                      else
                      begin
                        CrackDot( x, y, TrackColor);
                        CrackDot( _x, _y, TrackColor);
                        FatLine(_x, _y, x, y, 0, true, TrackColor)
                      end;

              OldFlag :=  TrackRecord[i].Flag;
          end;

          ReDrawRoutes;
          RedrawBase;
          RedrawMarkers;
          ReDrawTurnPoints;
          DrawArrowToNearest;

          csize := 32;
          if BigCur then
          begin
            csize := 64;
            AsphCanvas.UseImagePx(AsphImages.Image['arrow1_big.image'], pxBounds4(0, 0, 64, 64));
          end
            else
               AsphCanvas.UseImagePx(AsphImages.Image['arrow1.image'], pxBounds4(0, 0, 32, 32));

          if MapMode = 0 then
              AsphCanvas.TexMap(pRotate4c(
                      Point2(px, py),
                      Point2(CSize, CSize),
                      Azimuth),
                      cColor4(CurColor))
          else
              AsphCanvas.TexMap(pRotate4c(
                      Point2(w/2, h/2),
                      Point2(CSize, CSize),
                      Azimuth),
                      cColor4(CurColor));

      End
        Else             /////// ВРАЩАЮ!
        Begin

            VYShift := trunc (h* 0.3);

            fi3 := 0;

            if MapMode= 5 then
            begin
              fi3 := - CurrentRouteAngle;
              fi :=  fi3;
            end
             else
              fi := -Azimuth;

            cx := TrackRecord[SizeTrackRecord -1].x ;
            cy := TrackRecord[SizeTrackRecord -1].y ;

            Center.x := Cx ;
            Center.y := Cy ;
            if not HideTrack then
            for i := SizeTrackRecord -1 downto 0 do
            begin
               if i < SizeTrackRecord - MaxDotsVisible then
                   break;

               if i < SizeTrackRecord -1 then
                   NeedCrack := TrackRecord[i+1].Crack;

               if not ShowCracks then
                   NeedCrack := false;

               _x := x;
               _y := y;

               dx := (Cx - TrackRecord [i].x) ;
               dy := (Cy - TrackRecord [i].y) ;

               dx2 := dx * Cos (fi) + dy * sin (fi);
               dy2 :=-dx * Sin (fi) + Dy * Cos (fi);

               dx2 := dx2 / Mas ;
               dy2 := dy2 / Mas ;

               x := round (w div 2 - dx2 );
               y := h -  round (h div 2 - dy2 ) + VYShift;

               if OldFlag <> TrackRecord[i].Flag then
               begin
                 // PaintBox1 . Canvas . MoveTo ( x, y );
               end
                  else
                   if NeedCrack = false then
                    FatLine(_x, _y, x, y, 0 + DopFat, false, TrackColor)
                      else
                      begin
                        CrackDot( x, y, TrackColor);
                        CrackDot( _x, _y, TrackColor);
                        FatLine(_x, _y, x, y, 0, true, TrackColor)
                      end;

               OldFlag := TrackRecord[i].Flag;
            end;

            ReDrawRoutes;
            RedrawBase;
            RedrawMarkers;
            ReDrawTurnPoints;
            DrawArrowToNearest;

            csize := 32;
            if BigCur then
            begin
              csize := 64;
              AsphCanvas.UseImagePx(AsphImages.Image['arrow1_big.image'], pxBounds4(0, 0, 64, 64));
            end
              else
                AsphCanvas.UseImagePx(AsphImages.Image['arrow1.image'], pxBounds4(0, 0, 32, 32));

            if MapMode= 5 then
               fi := -fi3 - Azimuth
                 else
                  fi := 0;
                 

            AsphCanvas.TexMap(pRotate4c(
                      Point2(px, py),
                      Point2(CSize, CSize),
                      -fi),
                      cColor4(CurColor));

        End;

   if Follow and (CurrentRoute <> -1) then
      FollowCurrentRoute(CurrentRoute,TrackRecord [SizeTrackRecord -1].Time,
                          TrackRecord [SizeTrackRecord -1].x, TrackRecord [SizeTrackRecord -1].y);
  End;

end;

procedure TMainForm.RefreshMarkerList;
var i:integer;
    tmpI :real;
begin
 Settings.MarkerBox.Clear;
 for I := 0 to MarkerCount - 1 do
   begin
     if Markers[I].Caption ='' then
       Markers[I].Caption := '*';

     if UTM then
        GeoToUTM(WGS,Markers[i].B, Markers[i].L,South,Markers[i].x, Markers[i].y,MyZone,False)
       else
         WGSToSK(Markers[i].B, Markers[i].L,0,Markers[i].x, Markers[i].y, MyZone, False);

     Settings.MarkerBox.Items.Add(Markers[I].Caption);

   end;

   Settings.DelMarker.Enabled :=  Settings.markerBox.Items.Count > 0;
   Settings.EditMarker.Enabled := Settings.markerBox.Items.Count > 0;
end;

procedure TMainForm.ReLoadRoutes(FileName: String);
 var
     F : TStringList;
     I, J, I1, I2 : Integer;
     s1, s2 : String ;
     found, isBegin : Boolean;
     _X,_Y,_Z : double;
begin
   F := TStringList.Create;
   RouteCount := 0;

   CurrentRoute :=-1;
   NextRoute := -1;
   DistToNext:=0;
   WorstDist := false;
   FrameCount := 0;
   Frame := false;
   FrameGeo := false;
   BackStep := false;
   BadDist := false;
   ReFlyCurrent := false;
   WorstDist := False;
   LocalR1 := -1;
   LocalR2 := -1;
   TPCount := 0;

   if filename<>'' then
   try
     F.LoadFromFile(FileName);

     J :=0;
     for I := RoutesTabStart-1 to F.Count - 1 do
     if F[i]<>'' then
     begin

        if Settings.ReverseRoutes.Checked then
           i2 := (F.Count - 1) - (i - (RoutesTabStart-1))
          else
             i2 := i;

        isBegin := false;
        case LoadRData.RoutesBE.ItemIndex of
           0: begin
                s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                J := I;
                RouteCount := J+1;
              end;
           1: begin
                 s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                 J := Trunc(I/2);
                 RouteCount := J+1;
                 if I mod 2 = 0 then
                   isBegin := true;
              end;
           2: BEGIN
                s1 := GetCols(F[I2],RoutesNameTab,1, LoadRData.RSpacer.itemIndex);
                isBegin := (Copy(s1,length(s1),1)='a') or (Copy(s1,length(s1),1)='A');
                s1 := Copy(s1,1,length(s1)-1);

                if RouteCount=0 then
                begin
                  J :=0;
                  RouteCount:=1;

                end else
                  begin    /// ИЩУ ПО ИМЕНИ
                    found := false;
                    for J := 0 to RouteCount-1 do
                      if Route[J].Name = s1 then
                      begin
                        found := true;
                        break;
                      end;
                     if not found then
                     begin
                       J := RouteCount;
                       inc(RouteCount);
                     end;
                   end;
              END;
        end;

        Route[J].Name := s1;
        Route[J].Status := 0;

        Route[J].StartTime :='';
        Route[J].EndTime :='';
        Route[J].Rlabel :='';

        Route[J].Geo := (RoutesDatum = WGS) and (isRoutesDatum) and (RoutesCS = 0); //Settings.SK.ItemIndex=0;

        if LoadRData.RoutesBE.ItemIndex = 0 then
        begin

            // начало и конец
            if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

            Route[J].Gx1 := _X;
            Route[J].Gy1 := _Y;
            if RoutesZTab<>-1 then
               Route[J].Gz1 := StrToFloat(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                  else
                    Route[J].Gz1 := 0;

            if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesX2Tab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesY2Tab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesX2Tab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesY2Tab,1, LoadRData.RSpacer.itemIndex));
                end;

            Route[J].Gx1 := _X;
            Route[J].Gy1 := _Y;
            if RoutesZTab<>-1 then
              Route[J].Gz2 := StrToFloat2(GetCols(F[I2],RoutesZ2Tab,1, LoadRData.RSpacer.itemIndex))
                 else
                    Route[J].Gz2 := 0;

        end
          else
            if isBegin then
            begin
                // начало

               if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

                Route[J].Gx1 := _X;
                Route[J].Gy1 := _Y;
                if RoutesZTab<>-1 then
                   Route[J].Gz1 := StrToFloat2(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                     else
                       Route[J].Gz1 := 0;
            end
              else
              begin
                // конец
                if ((isRoutesDatum)and(RoutesCS=0))
                or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
                begin
                 _X := StrToLatLon(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex),false);
                end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I2],RoutesXTab,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I2],RoutesYTab,1, LoadRData.RSpacer.itemIndex));
                end;

                Route[J].Gx2 := _X;
                Route[J].Gy2 := _Y;
                if RoutesZTab<>-1 then
                  Route[J].Gz2 := StrToFloat2(GetCols(F[I2],RoutesZTab,1, LoadRData.RSpacer.itemIndex))
                    else
                      Route[J].Gz2 := 0;

              end;

     end;

     for J := 0 to RouteCount-1 do
      if not Route[J].Geo then
      Begin
         Route[J].Geo := True;
         // ПЕРЕВОД В WGS

          if isRoutesDatum = false then
          begin
            /// RouteCS - CК

            if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                CoordinateSystemToDatum(RoutesCS,
                                    Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                                    Route[J].Gx1, Route[J].Gy1, Route[J].Gz1)
                else
                   CoordinateSystemToDatum(RoutesCS,
                                      Route[J].Gy1, Route[J].Gx1, Route[J].Gz1,
                                      Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);


            Geo1ForceToGeo2(Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);




            if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                CoordinateSystemToDatum(RoutesCS,
                                    Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                                    Route[J].Gx2, Route[J].Gy2, Route[J].Gz2)
                else
                   CoordinateSystemToDatum(RoutesCS,
                                      Route[J].Gy2, Route[J].Gx2, Route[J].Gz2,
                                      Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);

            Geo1ForceToGeo2(Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);


          end
            else
            begin
              /// RouteCS - тип проекции
              case RoutesCS of
                 0: begin
                   // B L
                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;
                 end;

                 1:   begin
                   // XYZ
                   ECEFToGeo(RoutesDatum,  Route[J].Gx1, Route[J].Gy1, Route[J].Gz1,
                             Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                   ECEFToGeo(RoutesDatum,  Route[J].Gx2, Route[J].Gy2, Route[J].Gz2,
                             Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
                 2:  begin
                   // GK
                   GaussKrugerToGeo(Route[J].Gy1, Route[J].Gx1,
                                    Route[J].Gx1, Route[J].Gy1 );
                   GaussKrugerToGeo(Route[J].Gy2, Route[J].Gx2,
                                    Route[J].Gx2, Route[J].Gy2 );

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
                 3,4:  begin
                   // UTM
                   UTMToGeo(RoutesDatum, Route[J].Gy1, Route[J].Gx1, RoutesCS = 4,
                                    Route[J].Gx1, Route[J].Gy1 );
                   UTMToGeo(RoutesDatum, Route[J].Gy2, Route[J].Gy2, RoutesCS = 4,
                                    Route[J].Gx2, Route[J].Gy2 );

                   if RoutesDatum <> WGS then
                   Begin
                     Geo1ForceToGeo2(Route[J].Gx1,Route[J].Gy1,0, RoutesDatum,
                                   WGS, Route[J].Gx1, Route[J].Gy1, Route[J].Gz1);
                     Geo1ForceToGeo2(Route[J].Gx2,Route[J].Gy2,0, RoutesDatum,
                                   WGS, Route[J].Gx2, Route[J].Gy2, Route[J].Gz2);
                   End;

                 end;
              end;
            end;
      End;
    // FrameFile :='';

     Insert ('_f', Filename, Length(filename)-3);
     if Fileexists(Filename) then
     begin
         Frame := true;
         FrameFile := Filename;
         F.LoadFromFile(FileName);
         Frame := True;
         FrameGeo := (RoutesDatum = WGS) and (isRoutesDatum) and (RoutesCS = 0);


         j := 2;

         for I := 0 to F.Count - 1 do
         Begin
              if ((isRoutesDatum)and(RoutesCS=0))
               or((isRoutesDatum = false)and(CoordinateSystemList[RoutesCS].ProjectionType=0)) then
               begin
                 _X := StrToLatLon(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex),true);
                 _Y := StrToLatLon(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex),false);
               end
                else
                begin
                  _X := StrToFloat2(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex));
                  _Y := StrToFloat2(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex));
                end;


             FramePoints[I, j].x := _X;// StrToFloat(GetCols(F[I],1,1, LoadRData.RSpacer.itemIndex));
             FramePoints[I, j].y := _Y;//StrToFloat(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex));
             if RoutesZTab<>-1 then
                FramePoints[I, j].z := StrToFloat2(GetCols(F[I],2,1, LoadRData.RSpacer.itemIndex))
                  else
                    FramePoints[I, j].z := 0;

             inc(FrameCount);
         End;

         if FrameCount>1  then
         begin
            inc(FrameCount);
            FramePoints[FrameCount-1, j].x := FramePoints[0, j].x;
            FramePoints[FrameCount-1, j].y := FramePoints[0, j].y;
         end;


         if not FrameGeo then
            for J := 0 to FrameCount - 1 do
            Begin
               if isRoutesDatum = false then
               begin

                 if  CoordinateSystemList[RoutesCS].ProjectionType <=1 then
                      CoordinateSystemToDatum(RoutesCS,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z)
                      else
                         CoordinateSystemToDatum(RoutesCS,
                                      FramePoints[J, 2].y, FramePoints[J, 2].x, FramePoints[J, 2].z,
                                      FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                 Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                            CoordinateSystemList[RoutesCS].DatumN, WGS,
                            FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                //  ShowMessage(FloaTToStr(FramePoints[J, 2].x)+'  '+ FloaTToStr(FramePoints[J, 2].y))
               end
                else
                BEGIN
                   case RoutesCS of
                   0: begin
                   // B L
                     if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);


                   end;

                   1: begin
                   // XYZ
                     ECEFToGeo(RoutesDatum,  FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z,
                               FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                    if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);


                   end;
                   2:  begin
                   // GK
                     GaussKrugerToGeo(FramePoints[J, 2].y, FramePoints[J, 2].x,
                                      FramePoints[J, 2].x, FramePoints[J, 2].y);

                     if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);

                     // ShowMessage(FloaTToStr(FramePoints[J, 2].x)+'  '+ FloaTToStr(FramePoints[J, 2].y))
                   end;
                   3,4:  begin
                   // UTM
                   UTMToGeo(RoutesDatum, FramePoints[J, 2].y, FramePoints[J, 2].x, RoutesCS = 4,
                                    FramePoints[J, 2].x, FramePoints[J, 2].y );


                    if RoutesDatum <> WGS then
                        Geo1ForceToGeo2(FramePoints[J, 2].x, FramePoints[J, 2].y,0, RoutesDatum,
                                   WGS, FramePoints[J, 2].x, FramePoints[J, 2].y, FramePoints[J, 2].z);



                   end;
                   end;
                END;
            End;
         FrameGeo := True;
     end;

     ///---
   {

            else
            begin
              /// RouteCS - тип проекции

            end;
                  }
     ///---

     ReComputeRoutes(false);
     SetCurrentRoute(0);
 except
   MessageDlg(inf[15],mtError, [mbOk],0);
 end;  
 F.Destroy;

end;

procedure TMainForm.RenderEvent(Sender: TObject);
begin

  if not SmoothScale then
  Begin
     Scale  := TMashtab[Mashtab]/100;
     _Scale := Scale;
  End
     else
        AxelScale;

  ReDrawTrack;

  DrawScaleAndNord(Scale);

  ///if SmoothAzimuth then
     AxelHgts;

  RenderMenus;
end;


procedure TMainForm.RenderMenus;

  procedure DrawMenuButton(n:integer; btnchoosed, btncompound:boolean; btnDopColor: ShortInt);
  var A:Integer;
      Col4: TColor4;
  begin
     A:=190;
     if btnchoosed then
     begin
        A:=255;
        Col4 := cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
              GetRValue(Dop1Color),A);

        AsphCanvas.FillRect(RECT(MenuX+ 0, n*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll),
              AsphDevice.Size.x, (n+1)*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll)),
              Col4);
     end;

     case btnDopColor of
         0 : Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
         1 : Col4 := cRGB4(60,165,40,205);
         2 : Col4 := cRGB4(80,185,50,225);
         3 : Col4 := cRGB4(230+trunc(15*Sin(AsphTicks*0.1)),180,0,255);
         4 : Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
         5 : Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
         6 : Col4 := cRGB4(GetBValue(ChoosedColor),GetGValue(ChoosedColor),GetRValue(ChoosedColor),A);
         7 : Col4 := cRGB4(80,185,50,225);
         8 : Col4 := cRGB4(185,105,50,225);
         9 : Col4 := cRGB4(230,50,50,190);
     end;

     if btnCompound then
     begin
          AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    MenuX + 58, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);

          AsphCanvas.FillRect(RECT( MenuX+ 60, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);
     end
        else
          AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);
  end;

  procedure DrawHgtButton(n:integer; btnchoosed: Boolean; HgtCombination: ShortInt);
  var A:Integer;
      Col1, Col2, Col3, Col4: TColor4;
  begin

     A:=190;
     if btnchoosed then
     begin
        A:=255;
        Col4 := cRGB4(GetBValue(Dop1Color),GetGValue(Dop1Color),
              GetRValue(Dop1Color),A);

        AsphCanvas.FillRect(RECT(MenuX+ 0, n*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll),
              AsphDevice.Size.x, (n+1)*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll)),
              Col4);
     end;

     Col1 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
     Col4 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);

     case HgtCombination of
         0 : begin //// NO AUX

             end;

         1 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col2 := Col4;
               Col3 := Col4;
             end;

         2 : begin  //// BAD R HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col2 := Col4;
               Col3 := cRGB4(80,185,50,225);
             end;

         3 : begin  //// BAD L HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := cRGB4(80,185,50,225);
             end;
         4 : begin  //// BAD ALL
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := Col4;
               Col1 := Col4;
             end;


       //// IF NO R-Altimeter DATA

         10 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
               Col3 := Col4;
             end;

         11 : begin  //// BAD L HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col3 := Col4;
               Col2 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);
             end;

        //// IF NO L-Altimeter DATA

         20 : begin  //// ALL GOOD
               Col4 := cRGB4(80,185,50,225);
               Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
               Col2 := Col4;
             end;

         21 : begin  //// BAD R HGT
               Col4 := cRGB4(200+trunc(55*Sin(AsphTicks*0.1)),0,0,255);
               Col2 := Col4;
               Col3 := cRGB4(GetBValue(IntColor),GetGValue(IntColor),GetRValue(IntColor),A);;
             end;

     end;


     AsphCanvas.FillRect(RECT( MenuX + 2, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    MenuX + 58, (n+1)*MenuButtonSize[MenuN] - 1 + trunc(_MenuScroll)),
                    Col4);

     AsphCanvas.FillRect(RECT( MenuX+ 60, n*MenuButtonSize[MenuN] + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*1/3) - 1 + trunc(_MenuScroll)),
                    Col1);

     AsphCanvas.FillRect(RECT( MenuX+ 60, trunc(n*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]/3) + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*2/3) - 1 + trunc(_MenuScroll)),
                    Col2);

     AsphCanvas.FillRect(RECT( MenuX+ 60, trunc(n*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]*2/3) + 1 + trunc(_MenuScroll),
                    AsphDevice.Size.x-2, trunc((n)*MenuButtonSize[MenuN]+MenuButtonSize[MenuN]) - 1 + trunc(_MenuScroll)),
                    Col3);

  end;

var I, J :Integer;
    B    :Byte;
    Str, Str2  :String;
    Max  : Integer;
    Col : TColor2;
begin

 if ShowMaps then
   AsphCanvas.FillRect(RECT( MenuX, 0,
                    AsphDevice.Size.x, AsphDevice.Size.Y),
                     crgb4(GetBValue(BackGroundColor),GetGValue(BackGroundColor),GetRValue(BackGroundColor),190));
 case SmartMenu of
   true:
    if ChoosedMenu < -1 then
      ChoosedMenu := 0;
   false:
    if ChoosedMenu < 0 then
      ChoosedMenu := 0;
 end;
 

 Max :=  MenuCount[MenuN];
 if (MenuN=5) or (MenuN=6) then
    Max :=  RouteCount-1;

 if ChoosedMenu > Max then
    ChoosedMenu := Max;

 case MenuN of
    1: ////  Основное меню
    Begin
      for I := 0 to MenuCount[MenuN] do
      begin
          if not((AllowAuto=false)and(i = MenuCount[MenuN])) then  /// КНОПКИ "АВТО" МОЖЕТ НЕ БЫТЬ
             DrawMenuButton(i, i=ChoosedMenu , i<3 , 0)
             else
                if ChoosedMenu = MenuCount[MenuN] then
                   ChoosedMenu := MenuCount[MenuN]-1;

      //    if not((HgtID = 3)and(i = 1)) then   //// СПЕЦИАЛЬНЫЙ ДАТЧИК ВСЕХ ВЫСОТ
     //       DrawMenuButton(i, i=ChoosedMenu , i<3 , 0)      ;
             { else
                if ChoosedMenu = MenuCount[MenuN] then
                   ChoosedMenu := MenuCount[MenuN]-1;  }
                       // zxzx

          case I of
             0:  /// SPEED
             Begin

               if Speed> 1000 then
                  Speed :=-1;

               B:=1;
               J := -45;
               if Speed >= MaxSpd then
               begin
                  J := 50 +trunc(10*Sin(AsphTicks*0.1));
                  B := 4;
               end
                 else
                  if Speed >= MaxSpd-10 then
                  begin
                     J := 20;
                     B := 3;
                  end
                    else
                      if Speed >= MaxSpd-30 then
                      begin
                        J := 0;
                        B := 2;
                      end
                        else
                         if Speed >= 30 then
                         begin
                           J := -20;
                           B := 2;
                         end;

               DrawMenuButton(i, i=ChoosedMenu , i<3 , B);

               AsphCanvas.UseImagePx(AsphImages.Image['spd.image'], pxBounds4(0, 0, 64, 32));

               AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN]
                                  + 25 + trunc(_MenuScroll)), Point2(50, 25),
                                  0), clWhite4);

               AsphCanvas.UseImagePx(AsphImages.Image['spd2.image'], pxBounds4(0, 0, 16, 32));

               AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN]
                                  + 45 + trunc(_MenuScroll)), Point2(16, 32),
                                  j*pi/180), clWhite4);

               if BigText then
               Begin
                   AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    'V: ',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    if speed>=0 then
                      Str :=  IntToStr(trunc(Speed))
                       else
                        Str := '-';

                  J:= MenuX+60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               end
                else
                Begin
                  AsphFonts[Font2].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    inf[16],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if speed>=0 then
                    Str :=  IntToStr(trunc(Speed))+ inf[17]
                      else
                        Str := '-'+inf[17];

                  J:= MenuX+60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;


             End;
             2:  /// Azimuth
             Begin

               if BigText then
               Begin
                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    'Az: ', cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (Speed<0) then
                      Azimuth :=0;
                                 // zxzx
                  if Azimuth < 0 then
                      Azimuth := Azimuth + 2*pi;

                  Str :=  IntToStr(trunc(Azimuth*180/pi))+#176;

                  if (Speed<0) then
                      Str := '-';

                  J:= MenuX+60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);     // xzc
               End
                 else
                 Begin
                    AsphFonts[Font2].TextOut(
                      Point2(MenuX+60 + 5.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                      inf[18],                               // IntToStr(Timer.FrameRate);
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    if (Speed<0) then
                      Azimuth :=0;
                                 // zxzx
                    if Azimuth < 0 then
                      Azimuth := Azimuth + 2*pi;

                    Str :=  IntToStr(trunc(Azimuth*180/pi));

                    if (Speed<0) then
                      Str := '-';
                      J:= MenuX+60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                    AsphFonts[Font1].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      J:= MenuX + 32 + MenuW div 2  + Trunc((AsphFonts[Font1].TextWidth(Str)/2));

                    if str<>'-' then
                    AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        'o',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                 End;

                    AsphCanvas.UseImagePx(AsphImages.Image['az.image'], pxBounds4(0, 0, 64, 64));

                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                   azimuth), clWhite4);

             End;
             1:  ///// Altitude
             Begin

               

               if HgtID<>3 then
               BEGIN

                B := 0;
                case HGTID of
                  0: begin
                     Str := CurHgt;
                  end;

                  1: begin
                     Str := CurHgt2;
                     B := 2;
                     if _HAGR > 1.1* MaxHGTR then   //// 10% запас
                        B := 4
                          else
                            if (_HAGR > MaxHgtR) then
                               B := 3;

                     if _HAGR < 0.9* MinHGTR then   //// 10% запас
                        B := 4
                          else
                            if (_HAGR < MinHgtR) then
                               B := 3;
                  end;

                  2: begin
                     Str := CurHgt3;
                     B := 2;
                     if _HAGL > 1.1* MaxHGTL then  //// 10% запас
                        B := 4
                          else
                            if (_HAGL > MaxHgtL) then
                               B := 3;
                     if _HAGL < 0.9* MinHGTL  then   //// 10% запас
                        B := 4
                          else
                            if (_HAGL < MinHgtL) then
                               B := 3;
                  end;

                end;

                if Str='-' then
                  B :=0;

                if B>0 then
                  DrawMenuButton(i, i=ChoosedMenu , i<3 , B);

                if BigText then
                Begin
                  case HGTID of
                        0: Str2 := 'H(A): ';
                        1: Str2 := 'H(R): ';
                        2: Str2 := 'H(L): ';
                      end;

                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] +  4.0+ trunc(_MenuScroll)),
                    Str2, cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  J:= MenuX + 60+Trunc((-AsphFonts[Font6].TextWidth(Str)+MenuW-60) / 2);

                  AsphFonts[Font6].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 15.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End
                  else
                    Begin

                      case HGTID of
                        0: Str2 := inf[19];
                        1: Str2 := inf[63];
                        2: Str2 := inf[64];
                      end;

                      AsphFonts[Font2].TextOut(
                        Point2(MenuX+60+5.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                        Str2,                               // IntToStr(Timer.FrameRate);
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                       J:= MenuX + 60+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW-60) / 2);

                       AsphFonts[Font1].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                        Str,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    End;



                case HGTID of
                  0: AsphCanvas.UseImagePx(AsphImages.Image['h.image'], pxBounds4(0, 0, 64, 64));
                  1: AsphCanvas.UseImagePx(AsphImages.Image['rh.image'], pxBounds4(0, 0, 64, 64));
                  2: AsphCanvas.UseImagePx(AsphImages.Image['lh.image'], pxBounds4(0, 0, 64, 64));
                end;

                AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                  0), clWhite4);

             END
               Else
               BEGIN

                  if CurHgt2='-' then
                  begin
                     if CurHgt3='-' then
                       B := 0
                     else
                       if (HAGL < MaxHgtL) and (HAGL > MinHgtL)  then
                         B := 10
                         else
                            B := 11
                  end
                    else
                  if CurHgt3='-' then
                  begin
                      if (HAGR < MaxHgtR) and (HAGR > MinHgtR)  then
                        B :=  20
                        else
                          B :=  21
                  end
                    else
                     Begin
                        if ((HAGR < MaxHgtR) and (HAGR > MinHgtR))  and ((HAGL < MaxHgtL) and (HAGL > MinHgtL))  then
                          B := 1
                          else
                            if ((HAGR >= MaxHgtR) and (HAGR <= MinHgtR)) and ((HAGL < MaxHgtL) and (HAGL > MinHgtL)) then
                               B := 2
                               else
                               if ((HAGR < MaxHgtR)and (HAGR > MinHgtR)) and ((HAGL >= MaxHgtL)or(HAGL <= MinHgtL)) then
                                  B := 3
                                  else
                                    B := 4
                     End;

                  DrawHgtButton(i, i=ChoosedMenu, B);

                  if BigText then
                  begin
                      j := MenuX +65;
                      AsphFonts[Font5].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 1.0 + trunc(_MenuScroll)),
                        'HA:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font5].TextOut(
                         Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                        'HR:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font5].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 49.0 + trunc(_MenuScroll)),
                        'HL:',
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                      j := MenuX + 110;

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + -3.0 + trunc(_MenuScroll)),
                        CurHgt,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 20.0 + trunc(_MenuScroll)),
                        CurHgt2,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font2].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 44.0 + trunc(_MenuScroll)),
                        CurHgt3,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                  end
                   else
                   begin
                      j := MenuX +62;
                      AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 1.0 + trunc(_MenuScroll)),
                        inf[65],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font3].TextOut(
                         Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                        inf[66],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font3].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 49.0 + trunc(_MenuScroll)),
                        inf[67],
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      j := MenuX + 120;
                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                        CurHgt,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 23.0 + trunc(_MenuScroll)),
                        CurHgt2,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                      AsphFonts[Font4].TextOut(
                        Point2( j, i*MenuButtonSize[MenuN] + 47.0 + trunc(_MenuScroll)),
                        CurHgt3,
                        cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   end;

                  AsphCanvas.UseImagePx(AsphImages.Image['h.image'], pxBounds4(0, 0, 64, 64));
                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX+30, i*MenuButtonSize[MenuN] + 35.0 + trunc(_MenuScroll)), Point2(50, 50),
                                  0), clWhite4);
               END;

             End;

             3:  ///// MODE
             Begin



               if BigText then
               Begin
                  Str := inf[21];
                  if length(Str)>=6 then
                     Str := Copy(inf[21],1,3)+'.:';

                  AsphFonts[Font3].TextOut(
                    Point2(MenuX + 10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeShortNames[MapMode];
                  J:= MenuX + Trunc((-AsphFonts[Font1].TextWidth(Str)
                            - AsphFonts[Font4].TextWidth(MapModeShortSubNames[MapMode])
                            + MenuW) / 2);

                  AsphFonts[Font1].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  J:= J + trunc(AsphFonts[Font1].TextWidth(Str));
                  Str :=  MapModeShortSubNames[MapMode];

                  AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 32.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                else
                Begin
                  AsphFonts[Font2].TextOut(
                    Point2(MenuX + 10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                    inf[21],
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeNames[MapMode];
                  J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);

                  AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 28.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str :=  MapModeSubNames[MapMode];
                  J:= MenuX+Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

                  AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 48.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End;

               j :=0;
                 if BigText then
                      j := 15;

               if not AutoOn then
               Begin
                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 + j div 2,
                  i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  3.14), clWhite4);

                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 180 + j div 2,
                  i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  0), clWhite4);
               End
                Else
                 Begin                                                                    // xz
                   AsphCanvas.UseImagePx(AsphImages.Image['lock.image'], pxBounds4(0, 0, 32, 32));

                   AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 +j,
                   i*MenuButtonSize[MenuN] + 17.0 - j div 3 + trunc(_MenuScroll)), Point2(25, 25),
                                  0), clWhite4);
                 End;

             End;
             4:   //// SCALE
             Begin
               if BigText then
               Begin
                  AsphFonts[Font3].TextOut(
                      Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                      inf[22],
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  Str := MashtabNames[Mashtab];
                  J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);
                  AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                 else
                 Begin
                    AsphFonts[Font2].TextOut(
                      Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 2.0 + trunc(_MenuScroll)),
                      inf[22],
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                    Str := MashtabNames[Mashtab];
                    J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);
                    AsphFonts[Font1].TextOut(
                      Point2(j , i*MenuButtonSize[MenuN] + 28.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                 End;

                 j :=0;
                   if BigText then
                      j := 15;

               if not AutoOn then
               Begin
                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));

                  if Mashtab > 0 then
                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170 +j div 2,
                    i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  3.14), clWhite4);

                  AsphCanvas.UseImagePx(AsphImages.Image['arrow2.image'], pxBounds4(0, 0, 16, 32));
                  if Mashtab < MaxMashtab-1 then
                    AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 180 +j div 2,
                    i*MenuButtonSize[MenuN] + 20.0 - j div 3 + trunc(_MenuScroll)), Point2(10, 20),
                                  0), clWhite4);
               End
                else
                Begin

                  if AutoOn and ChangeAutoM then
                    AsphCanvas.UseImagePx(AsphImages.Image['unlock.image'], pxBounds4(0, 0, 32, 32))
                      else
                         AsphCanvas.UseImagePx(AsphImages.Image['lock.image'], pxBounds4(0, 0, 32, 32));

                  AsphCanvas.TexMap(pRotate4c(Point2(MenuX + 170+j,
                      i*MenuButtonSize[MenuN] + 17.0 - (j div 3) + trunc(_MenuScroll)),
                      Point2(25, 25), 0), clWhite4);
                End;

             End;

             5:  /// CURRENT
             Begin
               if BigText then
               Begin
                  J := MenuX+trunc(AsphFonts[Font3].TextWidth('M0:'));
                  AsphFonts[Font3].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    'M0:',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+40.0, i*MenuButtonSize[MenuN] + 36.0 + trunc(_MenuScroll)),
                    'D: ',                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[CurrentRoute].Name;

                  AsphFonts[Font1].TextOut(
                      Point2( 10 + j, i*MenuButtonSize[MenuN] - 2.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                      if DistToCurrent> 1000 then
                        Str := IntToStr(Round(DistToCurrent/1000)) + ' '+inf[25]
                          else
                            Str := IntToStr(Trunc(DistToCurrent)) + ' '+ inf[20];


                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+65, i*MenuButtonSize[MenuN] + 29.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               End
                Else
                Begin
                  J := MenuX + trunc(AsphFonts[Font4].TextWidth(inf[23]));

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    inf[23],
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font2].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 36.0 + trunc(_MenuScroll)),
                    'D: ',
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[CurrentRoute].Name;

                  AsphFonts[Font1].TextOut(
                    Point2( 10 + j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);



                  if (CurrentRoute=-1)or(CurrentRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                      if DistToCurrent> 1000 then
                        Str := IntToStr(Round(DistToCurrent/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToCurrent)) + inf[20];


                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+40, i*MenuButtonSize[MenuN] + 30.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;

             End;
             6:
             Begin
                if BigText then
               Begin
                   J := MenuX+trunc(AsphFonts[Font3].TextWidth('M1:'));
                   AsphFonts[Font3].TextOut(
                     Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                     'M1:',
                     cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   AsphFonts[Font4].TextOut(
                     Point2(MenuX+50.0, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll)),
                     'MD: ',
                     cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  if (NextRoute=-1)or(NextRoute>RouteCount-1) or (MapMode<3) then
                    Str := '-'
                      else
                        Str := Route[NextRoute].Name;

                  AsphFonts[Font1].TextOut(
                      Point2( 14 + j, i*MenuButtonSize[MenuN] - 2.0 + trunc(_MenuScroll) ),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                   if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                    else
                      if DistToNext> 1000 then
                        Str := IntToStr(Round(DistToNext/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToNext)) + inf[20];

                  AsphFonts[Font1].TextOut(
                    Point2( MenuX+90, i*MenuButtonSize[MenuN] + 29.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
               End
                Else
                Begin

                  J := MenuX+trunc(AsphFonts[Font4].TextWidth(inf[24]));
                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    inf[24],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll)),
                    inf[26],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                  if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                      else
                       Str := Route[NextRoute].Name;

                  AsphFonts[Font1].TextOut(
                    Point2( 10 + j, i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                  if (NextRoute=-1)or(NextRoute>RouteCount-1)or (MapMode<3) then
                    Str := '-'
                    else
                      if DistToNext> 1000 then
                        Str := IntToStr(Round(DistToNext/1000)) + inf[25]
                          else
                            Str := IntToStr(Trunc(DistToNext)) + inf[20];

                  AsphFonts[Font4].TextOut(
                    Point2( MenuX+135, i*MenuButtonSize[MenuN] + 39.0 + trunc(_MenuScroll) ),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
                End;

             End;

             7:  /// Авто
             if AllowAuto then
             Begin
               if AutoOn = false then 
                   DrawMenuButton(i, i=ChoosedMenu , false , 9);
                   
               AsphFonts[Font4].TextOut(
                    Point2(MenuX+10.0, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    inf[27],                               // IntToStr(Timer.FrameRate);
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               if AutoOn then
                 Str := inf[28]
                  else
                   Str := inf[29];

                J:= MenuX+Trunc((-AsphFonts[Font1].TextWidth(Str)+MenuW) / 2);

                AsphFonts[Font1].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 25.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);     // xzc

             End;
          end;


      end;  

    End;
    2: ////  Меню выбора режима
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
         DrawMenuButton(i, i=ChoosedMenu , false , 0);


               Str :=  MapModeNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               Str :=  MapModeSubNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 26.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    3: ////  Меню выбора масштаба
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

               Str :=  MashtabNames[i];
               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    4: ////  Меню действия при превышении дистанции
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
            0: Str := inf[30];
            1: Str := inf[31];
            2: Str := inf[32];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 8.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

          case i of
            0: Str := inf[33];
            1: Str := inf[34];
            2: Str := inf[35];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);

          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 22.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
      end;
    End;

    5, 6: ////  Меню выбора маршрута
    Begin

      for I := 0 to RouteCount-1 do
      begin
          if (i*MenuButtonSize[MenuN] + trunc(_MenuScroll) < DisplaySize.Y)
             and ((i+1)*MenuButtonSize[MenuN] > 0) then
          begin
            DrawMenuButton(i, i=ChoosedMenu , false , 5 + Route[i].Status);
               if BigText then
                   Str :=  inf[36][1] + ' ' +Route[i].Name
                  else
                    Str :=  inf[36] + Route[i].Name;

            //   J:= Trunc((-AsphFonts[Font2].TextWidth(Str)+AsphDevice.Size.x) / 2);
              if BigText then
                AsphFonts[Font2].TextOut(
                    Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0)
                else
                  AsphFonts[Font4].TextOut(
                      Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                      Str,
                      cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

               if BigText then
                 Str :=''
                 else
                   Str := inf[37];

               if BigText then
               begin
                 case Route[i].Status of
                    0 : Str := Str + inf[53];
                    1 : Str := Str + inf[39];
                    2 : Str := Str + inf[54];
                    3 : Str := Str + inf[55];
                 end;
               end else
               case Route[i].Status of
                 0 : Str := Str + inf[38];
                 1 : Str := Str + inf[39];
                 2 : Str := Str + inf[40];
                 3 : Str := Str + inf[41];
               end;

               if BigText then
               Begin
                   J := MenuW - trunc( AsphFonts[Font4].TextWidth(Str) );

                   AsphFonts[Font4].TextOut(
                       Point2( MenuX + J -5 , i*MenuButtonSize[MenuN] + 18.0 + trunc(_MenuScroll)),
                       Str,
                       cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);


                   if (Route[i].Status >=2) and (Route[i].badHgts>25) then
                   Begin
                        /// БРАК ВЫСОТ
                        AsphCanvas.UseImagePx(AsphImages.Image['hgta.image'], pxBounds4(0, 0, 32, 32));

                        AsphCanvas.TexMap(pRotate4c(Point2(MenuX+158, i*MenuButtonSize[MenuN] + 11.0 + trunc(_MenuScroll)), Point2(24, 24),
                                  0), clWhite4);

                        Col := cColor2( $9FFFFFFF, $FFFFFFFF);
                           if Route[i].badHgts>50 then
                              Col := clRed2;

                        AsphFonts[Font3].TextOut(
                          Point2( MenuX + 170.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                          IntToStr(Route[i].badHgts),
                          Col, 1.0);
                   End;                                  // cx
               End
                 else
                 Begin
                   AsphFonts[Font3].TextOut(
                       Point2( MenuX + 8.0 , i*MenuButtonSize[MenuN] + 18.0 + trunc(_MenuScroll)),
                       Str,
                       cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

                        if (Route[i].Status >=2) and (Route[i].badHgts>25) then
                        Begin
                           /// БРАК ВЫСОТ
                           AsphCanvas.UseImagePx(AsphImages.Image['hgta.image'], pxBounds4(0, 0, 32, 32));

                           AsphCanvas.TexMap(pRotate4c(Point2(MenuX+152, i*MenuButtonSize[MenuN] + 11.0 + trunc(_MenuScroll)), Point2(24, 24),
                                  0), clWhite4);

                           Col := cColor2( $9FFFFFFF, $FFFFFFFF);
                           if Route[i].badHgts>50 then
                              Col := clRed2;

                           AsphFonts[Font3].TextOut(
                             Point2( MenuX + 162.0 , i*MenuButtonSize[MenuN] + 0.0 + trunc(_MenuScroll)),
                             IntToStr(Route[i].badHgts)+'%',
                             Col, 1.0);
                        End;
                 End;
          end;

      end;
    End;

    7: ////  Лететь заново?
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[42];
             1 : Str := inf[43];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    8: //// Улет
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[44];
             1 : Str := inf[45];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font2].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font2].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 10.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;

    9: //// Достиг базу
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[46];
             1 : Str := inf[47];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
          AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 4.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

          case i of
             0 : Str := inf[48];
             1 : Str := inf[49];
          end;

          J:= MenuX + Trunc((-AsphFonts[Font3].TextWidth(Str)+MenuW) / 2);
          AsphFonts[Font3].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 24.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);
      end;
    End;

    10: //// Маршруты кончились
    Begin

      for I := 0 to MenuCount[MenuN] do
      begin
          DrawMenuButton(i, i=ChoosedMenu , false , 0);

          case i of
             0 : Str := inf[50];
             1 : Str := inf[51];
             2 : Str := inf[52];
          end;

               J:= MenuX + Trunc((-AsphFonts[Font4].TextWidth(Str)+MenuW) / 2);
               AsphFonts[Font4].TextOut(
                    Point2( j, i*MenuButtonSize[MenuN] + 14.0 + trunc(_MenuScroll)),
                    Str,
                    cColor2( $9FFFFFFF, $FFFFFFFF), 1.0);

      end;
    End;



 end;


end;

procedure TMainForm.ResetMaps;
begin
   ShowMaps := False;
   AsphMapImages.RemoveAll();
   SetLength(MapList,0);
end;

procedure TMainForm.ReDrawBase;
var dx, dy, dx2, dy2, x, y, fi : Double;
    csize: integer;
begin
//// Base
///
     if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     dx := (Center.x - Base[1].x)/ Scale ;
     dy := (Center.y - Base[1].y)/ Scale ;

     dx2 := dx * Cos (Fi) + dy * Sin(Fi);
     dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

     x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
     y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

     csize := 32;
     if BigCur then
        csize := 64;

     if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
         begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['flag_big.image'], pxBounds4(0, 0, 64, 64))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['flag.image'], pxBounds4(0, 0, 32, 32));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

         end;
end;

procedure TMainForm.ReDrawLines(dash:Boolean);
var  i, j, lcount, lstep : Integer;
     x1, y1, x2, y2, dx, dy, dx2, dy2 : Double ;
     Mas, fi    : double ;
begin
    Mas := Scale; //TMashtab[Mashtab]/100 ;

    if MapModeDoRotate[MapMode] then
    begin
        fi := -Azimuth;

        if MapMode= 5 then
           fi := - CurrentRouteAngle;

    end
        else
          fi := 0;

    if Mashtab<MaxMashtab-2 then
      lstep := TMashtab[Mashtab+1]
        else
          lstep := TMashtab[Mashtab];

      if (DisplaySize.X - MenuW) > DisplaySize.y then
          lcount := trunc((DisplaySize.X - MenuW) /2 * mas / lstep)+1
            else
              lcount := trunc(DisplaySize.y /2 * mas / lstep)+1;

    for J := -lcount to lcount do
    Begin

         x1 :=Trunc(Center.x /lstep)*lstep;// + I*lstep;
         y1 :=Trunc(Center.y /lstep)*lstep + J*lstep;

         x2 := x1 + (DisplaySize.X - MenuW) * mas;
         y2 := y1;// + (DisplaySize.X - MenuW) * mas;
         x1 := x1 - (DisplaySize.X - MenuW) * mas;
         y1 := y1;// - (DisplaySize.X - MenuW) * mas;

         dx := (Center.x - x1)/ Mas ;
         dy := (Center.y - y1)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 := -dx * Sin (Fi) + dy * Cos(Fi);

         x1 := round ((DisplaySize.X - MenuW) div 2 - dx2);
         y1 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2) + VYShift;

         dx := (Center.x - x2)/ Mas ;
         dy := (Center.y - y2)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

         x2 := round((DisplaySize.X - MenuW) div 2 - dx2);
         y2 := DisplaySize.y - round(DisplaySize.y div 2 - dy2) + VYShift;

         MyLine(x1, y1, x2, y2, dash, LinesColor);
    end;

    for I := -lcount to lcount do
    begin
         x1 :=Trunc(Center.x /lstep)*lstep + I*lstep;
         y1 :=Trunc(Center.y /lstep)*lstep; //+ J*lstep;

         x2 := x1;// + (DisplaySize.X - MenuW) * mas;
         y2 := y1 + (DisplaySize.X - MenuW) * mas;
         x1 := x1;// - (DisplaySize.X - MenuW) * mas;
         y1 := y1 - (DisplaySize.X - MenuW) * mas;

         dx := (Center.x - x1)/ Mas ;
         dy := (Center.y - y1)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 := -dx * Sin (Fi) + dy * Cos(Fi);

         x1 := round ((DisplaySize.X - MenuW) div 2 - dx2);
         y1 := DisplaySize.y -  round (DisplaySize.y div 2 - dy2) + VYShift;

         dx := (Center.x - x2)/ Mas ;
         dy := (Center.y - y2)/ Mas ;

         dx2 := dx * Cos (Fi) + dy * Sin(Fi);
         dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

         x2 := round((DisplaySize.X - MenuW) div 2 - dx2);
         y2 := DisplaySize.y - round(DisplaySize.y div 2 - dy2) + VYShift;

         MyLine(x1, y1, x2, y2, dash, LinesColor);
    End;

end;

procedure TMainForm.ReDrawMaps;
var  i, j, ImgN : Integer;
     _x, _y : array [1..4] of Double;
     Mas, fi, dx, dy, dx2, dy2, L, xmin, ymin, xmax, ymax : double ;
     Col : TColor4;
begin

 if MapModeDoRotate[MapMode] then
    begin
        fi := -Azimuth;

        if MapMode= 5 then
           fi := - CurrentRouteAngle;

    end
        else
          fi := 0;                


    for I := 0 to Length(MapList) - 1 do
    Begin
       for j := 1 to 4 do
       Begin
          dx := (Center.x - MapList[i].x[j])/ Scale ;
          dy := (Center.y - MapList[i].y[j])/ Scale ;

          dx2 := dx * Cos (Fi) + dy * Sin(Fi);
          dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

          _x[j] := round ((DisplaySize.X - MenuW) div 2 - dx2 );
          _y[j] := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;
       End;

       try
          L := sqrt(sqr(_x[4]-_x[1])+sqr(_y[4]-_y[1]));
       except
         continue;
       end;

       if (L < 5 * MinMap) then
         continue;

       if (L > 5 * MaxMap) then
         continue;


       xmin := _x[1];
       ymin := _y[1];
       xmax := _y[1];
       ymax := _y[1];
       for j := 2 to 4 do
       begin
         if _x[j] < xmin then
           xmin := _x[j];
         if _y[j] < ymin then
           ymin := _y[j];

         if _x[j] > xmax then
           xmax := _x[j];
         if _y[j] > ymax then
           ymax := _y[j];
       end;

       if (xmax<0)and(xmin<0) or (xmax > DisplaySize.X)and(xmin > DisplaySize.X) then
           continue;
           
       if (ymax<0)and(ymin<0) or (ymax > DisplaySize.Y)and(ymin > DisplaySize.Y) then
           continue;


       if L<45 then
           ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName+'_t'] )
          //AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName+'_t'], pxBounds4(0, 0, 32, 32))
           else
           if l<220 then
              ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName+'_s'] )
             //AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName+'_s'], pxBounds4(0, 0, 128, 128))
               else
                 ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName] );
                 // AsphCanvas.UseImagePx(AsphMapImages.Image[MapList[i].imgName], pxBounds4(0, 0, 512, 512));

       if ImgN=-1 then
          ImgN := AsphMapImages.IndexOf( AsphMapImages.Image[MapList[i].imgName] );
       AsphCanvas.UseImagePx(AsphMapImages.Items[ImgN], pxBounds4(0, 0,
                  AsphMapImages.Items[ImgN].PatternSize.x, AsphMapImages.Items[ImgN].PatternSize.y ));

       if MapAlpha=255 then
         Col := ClWhite4
          else
           Col := cRGB4(255,255,255,MapAlpha);

        AsphCanvas.TexMap(Point4( _x[1], _y[1],  _x[2], _y[2],
                          _x[3], _y[3],  _x[4], _y[4]), Col)

                                 
       {AsphCanvas.TexMap(PBounds4( i*300, 0, 300, 300),
              clWhite4)}
   End;


end;

procedure TMainForm.ReDrawMarkers;
var dx, dy, dx2, dy2, x, y, fi: Double;
    csize, i, j, Fnt, w : integer;
    canLabel :boolean;
begin
//// Base
///
     if MarkerCount<1 then
       exit;
       
     if MapModeDoRotate[MapMode] then
       fi := -Azimuth
       else
         fi := 0;

     if MapMode = 5 then
        fi := - CurrentRouteAngle;

     for I := 0 to MarkerCount - 1 do
     Begin
       dx := (Center.x - Markers[I].x)/ Scale ;
       dy := (Center.y - Markers[I].y)/ Scale ;

       dx2 := dx * Cos (Fi) + dy * Sin(Fi);
       dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

       x := round ((DisplaySize.X - MenuW) div 2 - dx2 );
       y := DisplaySize.y -  round (DisplaySize.y div 2 - dy2 ) + VYShift;

       Markers[i].iX := trunc(x);
       Markers[i].iY := trunc(y);
       
       csize := 16;
       if BigCur then
         csize := 32;

       if (x > - csize)and(x < (DisplaySize.X - MenuW) + csize) then
       if (y > - csize)and(y < DisplaySize.y + csize) then
          begin
            if BigCur then
                AsphCanvas.UseImagePx(AsphImages.Image['marker1_big.image'], pxBounds4(0, 0, csize , csize ))
                else
                   AsphCanvas.UseImagePx(AsphImages.Image['marker1.image'], pxBounds4(0, 0, csize , csize ));

             AsphCanvas.TexMap(pRotate4c(Point2(x,
                    y),Point2(csize, csize), 0),
                    cColor4(MenuChoosedColor));

            canLabel := true;
            
            Markers[i].OnScreen := true;

            if Markers[i].Caption<>'*' then
            try

              if BigCur then
                Fnt := Font4
                  else Fnt := Font5;

              w := round(AsphFonts[Fnt].TextWidth(Markers[i].Caption)/2);
              Markers[i].iW := w;

              for J := 0 to MarkerCount - 1 do
                if I<>j then
                 if Markers[j].OnScreen then
                  if (y > Markers[j].iY-csize*2)and(y < Markers[j].iY+csize*2) then
                   if (x+w > Markers[j].iX-Markers[j].iw)and(x-w < Markers[j].iX+Markers[j].iw) then
                     begin
                        canlabel := false;
                        break;
                     end;

              if BigCur then
                dy := 0
                else
                  dy := cSize;

              if CanLabel then
                 AsphFonts[Fnt].TextOut(Point2(trunc(x)-w,trunc(y)-cSize-trunc(dy)),
                                         Markers[i].Caption,clWhite2);
            except
            end;
         end
           else
            Markers[i].OnScreen := false;


     End;
end;


procedure TMainForm.ReDrawRoutes;
       var i  : Integer;
           L      : Double;
           x, y   : integer;
           x2, y2 : Integer;
           _x, _y   : integer;
           _x2, _y2 : Integer;
           cur1, cur2: TMyPoint;
           Mas    : double;
           w, h   : Integer;
           fi, fi2: double;
           dx, dy : double;
           dx2,dy2 : double;
           s      : string;
begin

    if RouteCount = 0  then
      exit ;

      w := (DisplaySize.X - MenuW);
      h := DisplaySize.y;

      Mas := Scale; //TMashtab[Mashtab]/100 ;

      for i := 0 to RouteCount  -1 do
      begin

             if MapModeDoRotate[MapMode] then
             begin
                fi := -Azimuth;
             end
                  else
                    fi := 0;

             if MapMode = 5 then
                fi := - CurrentRouteAngle;

             dx := (Center.x - Route[i].x1)/ Mas ;
             dy := (Center.y - Route[i].y1)/ Mas ;

             dx2 := dx * Cos (Fi) + dy * Sin(Fi);
             dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

             x := round (w div 2 - dx2 );
             y := h -  round (h div 2 - dy2 ) + VYShift;

             dx := (Center.x - Route[i].x2)/ Mas ;
             dy := (Center.y - Route[i].y2)/ Mas ;

             dx2 := dx * Cos (Fi) + dy * Sin(Fi);
             dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

             x2 := round(w div 2 - dx2);
             y2 := h - round(h div 2 - dy2) + VYShift;

             if i = RouteAsk then
                FatLine(x, y, x2, y2, 2+DopFat, false, MenuChoosedColor);

             if i = CurrentRoute then
             Begin

               if (MapMode > 2) and (MapMode < 6) then
               begin
                Cur1.X := x;
                Cur2.X := x2;
                Cur1.y := y;
                Cur2.y := y2
               end
                else
                  FatLine(x, y, x2, y2, 1+DopFat, false, ChoosedColor);

             End
             else
               if i = NextRoute then
               begin
                 FatLine(x, y, x2, y2, 1+DopFat, false, RoutesColor);

                 FatLine(x, y, x2, y2, 0+DopFat, false,
                         cRGB1(GetBValue(ChoosedColor),GetGValue(ChoosedColor),GetRValue(ChoosedColor),50));
               end
                  else
                    if Route[i].Status = 0 then
                      FatLine(x, y, x2, y2, 0+DopFat, false, RoutesColor)
                       else
                       if Route[i].Status >= 2 then
                          FatLine(x, y, x2, y2, 0+DopFat, false, DoneColor);

      end ;

  //////////// FRAME
      
      if Frame and ShowFrame then
         if FrameCount  >1 then
         Begin
            for i := 0 to FrameCount  -2 do
            begin

               dx := (Center.x - FramePoints[i,1].x)/ Mas ;
               dy := (Center.y - FramePoints[i,1].y)/ Mas ;

               dx2 := dx * Cos (Fi) + dy * Sin(Fi);
               dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

               x := round (w div 2 - dx2 );
               y := h -  round (h div 2 - dy2 ) + VYShift;

               dx := (Center.x - FramePoints[i+1,1].x)/ Mas ;
               dy := (Center.y - FramePoints[i+1,1].y)/ Mas ;

               dx2 := dx * Cos (Fi) + dy * Sin(Fi);
               dy2 :=-dx * Sin (Fi) + dy * Cos(Fi);

               x2 := round(w div 2 - dx2);
               y2 := h - round(h div 2 - dy2) + VYShift;

               FatLine(x, y, x2, y2, 1+DopFat, false,
                        cRGB1(GetBValue(MenuChoosedColor),
                        GetGValue(MenuChoosedColor),
                        GetRValue(MenuChoosedColor),75));
            end;
       End;

   ///////////// CURRENT ПОВЕРХ ВСЕГО

     if (MapMode > 2) and (MapMode < 6) then
         if (CurrentRoute > -1)and( CurrentRoute < RouteCount) then
         try

                 if ShowActiveZone then
                  Begin

                    _x := round(Cur1.x); _y := round(Cur1.y); _x2 :=  round(Cur2.x); _y2 :=  round(Cur2.y);

                    fi2 := arctan2(Cur2.x-Cur1.x,Cur2.y-Cur1.y);
                     //zxczxczx
                    dx2 :=  RouteMaxDist /Mas * sin(fi2+pi/2) ;
                    dy2 :=  RouteMaxDist /Mas * cos(fi2+pi/2) ;

                    x :=  round( Cur1.x + dx2  );
                    y :=  round( Cur1.y + dy2 );
                    x2 := round( Cur2.x + dx2 );
                    y2 := round( Cur2.y + dy2 );

                    DrawZone(x, y, x2, y2,_x2,_y2, _x, _y);

                    x :=  round( x - 2* dx2  );
                    y :=  round( y - 2*  dy2 );
                    x2 := round( x2 - 2* dx2 );
                    y2 := round( y2 - 2* dy2 );

                    DrawZone(x, y, x2, y2,_x2,_y2, _x, _y);
                 End;


                 if (ReflyCurrent)and(Sin(AsphTicks*0.1)>0) then
                    FatLine(Cur1.x, Cur1.y, Cur2.x, Cur2.y, 1+DopFat, false, MenuChoosedColor)
                      else
                        FatLine(Cur1.x, Cur1.y, Cur2.x, Cur2.y, 1+DopFat, false, ChoosedColor);


                  L := SQRT(SQR(Cur2.x - Cur1.x)+SQR(Cur2.y - Cur1.y));
                  if L > 0 then
                  begin
                    dx := ( Cur2.x-Cur1.x)/L;
                    dy := ( Cur2.y-Cur1.y)/L;

                    x :=  round( Cur1.x - 4*L*dx );
                    y :=  round( Cur1.y - 4*L*dy );
                    x2 := round( Cur2.x + 4*L*dx );
                    y2 := round( Cur2.y + 4*L*dy );

                    FatLine(x, y, x2, y2, 0+DopFat, true, ChoosedColor);

                    fi2 := arctan2(x2-x,y2-y);
                     //zxczxczx
                    dx2 :=  RouteMaxDist /Mas * {Cos (pi/2-Fi )} sin(fi2+pi/2) ;
                    dy2 :=  RouteMaxDist /Mas * {Sin (pi/2-Fi )} cos(fi2+pi/2) ;

                    x :=  round( x +  dx2  );
                    y :=  round( y +  dy2 );
                    x2 := round( x2 + dx2 );
                    y2 := round( y2 + dy2 );

                    _x := x; _y := y;  _x2 := x2; _y2 := y2;

                    FatLine(x, y, x2, y2, 0+DopFat, true, RouteOkColor);

                    x :=  round( x - 2* dx2  );
                    y :=  round( y - 2*  dy2 );
                    x2 := round( x2 - 2* dx2 );
                    y2 := round( y2 - 2* dy2 );

                    FatLine(x, y, x2, y2, 0+DopFat, true, RouteOkColor);


                  end;
       except           
       End;

end;

procedure TMainForm.RxMemoKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_F1 then
  begin
    Timer.Enabled:= False;
    Settings.ShowModal;
  end;

  if Key = VK_F5 then
      Panel5.Visible := not Panel5.Visible;
end;

procedure TMainForm.SaveLogFile;
var s :String;
    i :integer;
    RoutesRemain : TSTringList;
begin

  if RealTime then
  Begin
    if GPSLog.Count> MaxLogSize then
    begin
      for I := 1 to LogsMax do
      begin
        s := _GPSLogFileName+'_'+ IntTostr(i) +'.GPS';
        if not Fileexists(s) then
        begin
           GPSLogFileName  := s;
           GPSLog.SaveToFile(GPSLogFileName);
           GPSLog.Clear;
           break;
        end;
      end;
    end
      else
       GPSLog.SaveToFile(GPSLogFileName);

    Odo.Clear;
    Odo.Add(FloatToStr(Odometr));
    Odo.SaveToFile(LogDir+'Odo.log');         
  End;

  if Report.Count >4  then
  Begin
    if RealTime then
       Report.SaveToFile(ReportFileName+'_routes.txt')
       else
         Report.SaveToFile(ReportFileName+'_emulroutes.txt');
  End;


  RoutesRemain := TSTringList.Create;
  for I := 0 to RouteCount - 1 do
  Begin    
    if Route[i].Status < 2 then
    Begin
      RoutesRemain.Add(Route[i].Name+'a' + #$9 + FloatToStr(Route[i].Gx1) 
                         + #$9 + FloatToStr(Route[i].Gy1));
                         
      RoutesRemain.Add(Route[i].Name+'b' + #$9 + FloatToStr(Route[i].Gx2) 
                         + #$9 + FloatToStr(Route[i].Gy2));
      
    End;
    
  End;

  if RoutesRemain.Count > 0 then
  Begin

    if RealTime then
    Begin
     RoutesRemain.SaveToFile(Report2FileName+'_remain(WGS).txt');
     if Frame then
       CopyFile(PChar(FrameFile), PChar(Report2FileName+'_remain(WGS)_f.txt'),true);
    End
      else
      Begin
        RoutesRemain.SaveToFile(Report2FileName+'_emulremain(WGS).txt');
        if Frame then
          CopyFile(PChar(FrameFile), PChar(Report2FileName+'_emulremain(WGS)_f.txt'),true)
      End;
      
  End;

  RoutesRemain.Destroy;
end;


function SecToHMS(Sec : double) :string ;
var H,M: Integer;
    s, Hh :Double;
    sH, sM, sS, SMm : String;
begin

  Hh := Sec/3600;

  H := trunc(Hh);
  M := trunc(frac(Hh)*60);
  s := (frac(Hh)*60-M)*60;

  if round(s*1000) >= 60000 then
  begin
     s := s - 60;
     if s < 0 then
       s := 0;
     inc(M);
  end;
  if M >=60 then
  begin
     M := M - 60;
     if M < 0 then
       M := 0;
     inc(H);
  end;

  sH  := inttostr(H);
  sM  := inttostr(M);
  sS  := format('%.2f',[s]);

  if M < 10 then
  begin
    sM := '0' + sM;
  end;

  if s < 10 then
    sS := '0' + sS;

  Result:= sH + ':'+ sM + ':' + Ss ;
end;

procedure TMainForm.SaveTrack;
var I :integer;
    s : String;
    TrackS : TStringList;
begin
   if SizeTrackRecord = 0 then
      exit;

      for I := 1 to LogsMax do
      begin
        s := TrackFileName+'_track_'+ IntTostr(i) +'.txt';
        if not Fileexists(s) then
           break;
      end;

     TrackS := TStringList.Create;
                                              
     for I := 0 to SizeTrackRecord - 1 do
       with TrackRecord[i] do
           TrackS.Add(SectoHMS(Time) + #$9 +  DegToDMS(Lat,0) + #$9 +
                    DegToDMS(Long,0) + #$9 + format('%n',[h]) + #$9 +
                    format('%n',[OdoMr]) + #$9 + RouteNm + #$9 +
                    format('%.1f',[RDist/10]) + #$9 +
                    format('%n',[x]) +#$9 + format('%n',[y]) + #$9 +
                    format('%n',[hg])+#$9 + IntToStr(hr) + #$9 + IntToStr(hl)+ #$9 +
                    IntToStr(RPRogress));

     TrackS.SaveToFile(s);


     TrackS.Clear;
     TrackS.Add(s);
     TrackS.Add(IntToStr(MinHGTR));
     TrackS.Add(IntToStr(MaxHGTR));
     TrackS.Add(IntToStr(MinHGTL));
     TrackS.Add(IntToStr(MaxHGTL));
     TrackS.Add(IntToStr(RouteMaxDist));
     TrackS.Add(Settings.Languages.Items[Settings.Languages.ItemIndex]);
     TrackS.SaveToFile(DataDir+'LastTrack.log');
     TrackS.Destroy;

end;

procedure TMainForm.SetCurrentRoute(RouteN: integer);
var i: Integer;
    OldRoute : integer;
begin
  OldRoute := CurrentRoute;

 if RouteN<>-1 then
  if RouteN < RouteCount then
  Begin
       if Route[RouteN].Status = 0 then
       begin
          if (CurrentRoute<>-1) then
          if Route[CurrentRoute].Status = 1 then
             Route[CurrentRoute].Status := 0;

          CurrentRoute := RouteN;
          Route[RouteN].Status := 1;

          CurrentRouteAngle := GetRouteAngle(RouteN);
          GetNextRoute;

          ReFlyCurrent := False;
          NumDist := 0;
          SumDist := 0;
          NumBadHgt := 0;

          CurToNextDist;

          WorstDist:= false;
          BadDist := False;
          SumDist := 0;
          NumDist := 0;
          NumBadHgt := 0;
       end;
  End;
  if OldRoute <> CurrentRoute then
     PrevRoute := OldRoute;
end;

procedure TMainForm.SetCurrentRouteByName(RouteName: string);
var i, RouteN: Integer;
begin
 RouteN :=-1;

 for I := 0 to RouteCount - 1 do
   if RouteName = Route[i].Name then
   begin
      RouteN := I;
      break;
   end;

 SetCurrentRoute(RouteN);


end;

procedure TMainForm.SetNewRouteStatus(N, Stat: Integer);
var RF : boolean;
begin
  try
    if Route[N].Status<>1 then
       Route[N].Status := Stat
        else
         begin
           RF := ReFlyCurrent;
           ReFlyCurrent := true;
           Route[N].Status := Stat;
           GoToNextRoute;
           ReFlyCurrent := RF;
         end;
     ReComputeRoutes(false);
  except
  end;
end;

procedure TMainForm.ShiftMap(Key: Byte);
var Mas, mShiftX, mShiftY :real;
begin
  Mas := Scale;
  mShiftX := 0;
  mShiftY := 0;
  case Key of
   0: if Mashtab < MaxMashtab-1 then
          Inc(Mashtab);
   1: if Mashtab > 0 then
          Dec(Mashtab);

   2:  mShiftY := DisplaySize.y *0.15;
   3:  mShiftY := -DisplaySize.y *0.15;
   4:  mShiftX := (DisplaySize.X - MenuW) *0.25;
   5:  mShiftX := -(DisplaySize.X - MenuW) *0.25;

 end;

 if AutoOn then
  begin
    if ChangeAutoM then
    begin
       case MapMode of
         1,2,6,7 : if Speed < 10 then
                    AutoM[1] :=  Mashtab
                      else
                        AutoM[3] :=  Mashtab;
         3,4,5 : if not (BeforeBegin or AfterEnd or ReflyCurrent) then
                     AutoM[5] :=  Mashtab
                           else
                             AutoM[7] :=  Mashtab;
       end;
    end;
  end;

 Center.x := Center.x - MShiftX*Mas ;
 Center.y := Center.y + MShiftY*Mas ;
end;

procedure TMainForm.SKToWGS(x, y, h: Double; var B, L: Double);
var B2, L2, H2, h1 : Double;
begin

  GaussKrugerToGeo(x, y, B2, L2);
  Geo1ToGeo2(B2, L2, 0, SK, WGS, B, L, H1);

end;

procedure TMainForm.SmartMenuKeyCommand(Key: Byte);
begin
 ///
 case Key of
    1: Begin  /// UP
       if SmartN > 4 then
         SmartN := SmartN-4;
       if SmartN < 0 then
         SmartN := SmartN+4;
    End;

    2: Begin   /// DOWN
      if SmartN<= SmartCount then
         SmartN := SmartN+4;
      if SmartN > SmartCount then
         SmartN := SmartN-4;    
    End;

    3: Begin   /// LEFT
      if SmartN<=0 then
         SmartN := SmartCount
           else
          dec(SmartN);
         
       if SmartN < 0 then
         SmartN := SmartCount;
    End;

    4: Begin
     // if SmartN = 0 then
     //  SmartN := 5
     //  else
        //if (SmartN <> 4) then
         inc(SmartN)  ;
        //  else SmartN := 0; 

      if SmartN > SmartCount then
         SmartN := 0;
    End;

    5: Begin   ///  ENTER
        case SmartN of
          -1, 0: inSmart := false;
	        1: begin
            ShowInfo := not (ShowInfo);

          end;
          2: begin
             if MaxDotsVisible = 0 then
               MaxDotsVisible := MaxDotsCount
             else
             if MaxDotsVisible = MaxDotsCount then
              MaxDotsVisible := 1000
              else
                if MaxDotsVisible = 1000 then
                   MaxDotsVisible := 0
          end;
          3: begin 
            if Length(MapList)<>0 then
                ShowMaps := not ShowMaps;
            if ShowMaps then
                RecomputeMaps(False);
          end;
          4: begin
             Timer.Enabled:= False;
             Settings.ShowModal;
            
          end;
          5: begin
             ConnectCOM(ComPort1);
          end;
          6: begin
             ConnectCOM(ComPort2);
          end;

          7: begin
            HgtLine := not (HgtLine);
          end;

          8: Begin

          End;
        end;

    End;

    6: Begin   ///  ESC
       
       inSmart := false;

    End;

  end;
end;

procedure TMainForm.SpeedButton1Click(Sender: TObject);
begin
  EmulSpeed := 0;
end;

procedure TMainForm.SpeedButton2Click(Sender: TObject);
begin
  EmulSpeed := 1;
end;

procedure TMainForm.SpeedButton3Click(Sender: TObject);
begin
  EmulSpeed := EmulSpeed div 2;
end;

procedure TMainForm.SpeedButton4Click(Sender: TObject);
begin
  if Emulspeed = 0 then
     Emulspeed := 2;

  if EmulSpeed< 1024 then
    EmulSpeed := EmulSpeed *2;
end;

//---------------------------------------------------------------------------
procedure TMainForm.WGSToSK(B, L, H: Double; var x, y: Double; Zone: Integer;
  autozone: boolean);
var Bsk, Lsk, Hsk : Double;
begin

  Geo1ToGeo2(B, L, H, WGS, SK, Bsk, Lsk, Hsk);
  GeoToGaussKruger(Bsk, Lsk, y, x, Zone, AutoZone);

  if AutoZone then
  begin
     MyZone := Zone;
  end;
end;

procedure TMainForm.WMDisplayChange(var message: TMessage);
begin
 // This event happens when user changes screen resolution.
 //
 // We also detect if the screen resolution has changed because of our
 // full screen mode, in which case we simply exit.
 if (Tag = 1) then Exit;

 if (AsphDevice <> nil)and(AsphDevice.Active)and(AsphDevice.Windowed) then
  AsphDevice.Reset();
end;

//---------------------------------------------------------------------------
end.
